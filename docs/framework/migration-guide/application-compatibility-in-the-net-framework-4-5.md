---
title: "Compatibilidad de aplicaciones en .NET Framework 4.5 | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net-framework"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-clr"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "compatibilidad de aplicaciones, .NET Framework"
  - "cambios importantes [.NET Framework]"
ms.assetid: 5c50747c-806c-44a9-ac58-5bbe12a284fa
caps.latest.revision: 76
author: "rpetrusha"
ms.author: "ronpet"
manager: "wpickett"
caps.handback.revision: 76
---
# Compatibilidad de aplicaciones en .NET Framework 4.5
En este tema se describen los problemas de compatibilidad de las aplicaciones entre las versiones 4 y 4.5 de .NET Framework, incluidas las revisiones y los cambios basados en los comentarios de los clientes. La mayoría de estos cambios no exigen que realice ningún tipo de modificación de programación en sus aplicaciones. Para ver los cambios que podrían implicar modificaciones, consulte la columna Impacto de las tablas.  
  
> [!IMPORTANT]
>  Tenga en cuenta que [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] no es compatible con [!INCLUDE[winxp](../../../includes/winxp-md.md)].  
  
 Para obtener información sobre los problemas de compatibilidad entre .NET Framework 4.5 y 4.5.1, consulte [Compatibilidad de aplicaciones en 4.5.1](../../../docs/framework/migration-guide/application-compatibility-in-the-net-framework-4-5-1.md).  
  
 En este tema se describen los cambios notables en las siguientes áreas:  
  
-   [Principal](#core)  
  
-   [Datos](#sql)  
  
-   [Redes](#network)  
  
-   [Serialización](#serialize)  
  
-   [Impresión](#Printing)  
  
-   [Herramientas y recursos](#tools)  
  
-   [ASP.NET](#asp)  
  
-   [ClickOnce](#ClickOnce)  
  
-   [Managed Extensibility Framework \(MEF\)](#mef)  
  
-   [Aplicaciones Web](#web)  
  
-   [Windows Communication Foundation \(WCF\)](#wcf)  
  
-   [Windows Forms](#winForms)  
  
-   [Windows Presentation Foundation \(WPF\)](#wpf)  
  
-   [Windows Workflow Foundation (WF)](../../../docs/framework/migration-guide/application-compatibility-in-the-net-framework-4-5.md#wwf)  
  
-   [XML, XSLT](#xml)  
  
 En este tema no se describen los tipos y miembros que se han declarado obsoletos en [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]. Para obtener una lista de ellos, consulte [Lo obsoleto en la biblioteca de clases](../../../docs/framework/whats-new/whats-obsolete.md). Para obtener información sobre las características nuevas, consulte [Novedades](../../../docs/framework/whats-new/index.md).  
  
<a name="core"></a>   
## Principal  
 Además de los siguientes problemas de compatibilidad de aplicaciones, consulte la sección [Serialización](#serialize) para conocer problemas relacionados con la serialización.  
  
|Característica|Cambio|Impacto|  
|--------------------|------------|-------------|  
|Métodos [BlockingCollection\<T\>.TryTakeFromAny\(BlockingCollection\<T\>\<xref:System.Collections.Concurrent.BlockingCollection%601.TryTakeFromAny%28System.Collections.Concurrent.BlockingCollection%7B%600%7D%5B%5D%2C%600%40%29?displayProperty=fullName> y <xref:System.Collections.Concurrent.BlockingCollection%601.TakeFromAny%2A?displayProperty=fullName>|El método [BlockingCollection\<T\>.TryTakeFromAny\(BlockingCollection\<T\>\<xref:System.Collections.Concurrent.BlockingCollection%601.TryTakeFromAny%28System.Collections.Concurrent.BlockingCollection%7B%600%7D%5B%5D%2C%600%40%29?displayProperty=fullName> ya no devuelve \-1 ni produce una excepción. El método <xref:System.Collections.Concurrent.BlockingCollection%601.TakeFromAny%2A?displayProperty=fullName> ya no produce una excepción si una de las colecciones está marcada como completada.|Este cambio permite trabajar con colecciones cuando una de las colecciones está vacía o completa y la otra colección todavía tiene elementos que se pueden recuperar.|  
|<xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=fullName>|Si un ensamblado de expresiones regulares compiladas se crea con [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] pero tiene como destino [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], si se intenta usar una de las expresiones regulares de dicho ensamblado en un sistema con [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)] instalado, se producirá una excepción.|Para evitar este problema, realice una de las acciones siguientes:<br /><br /> Cree el ensamblado que contenga las expresiones regulares con [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)].<br /><br /> Use una expresión regular interpretada.|  
|Eliminación de <xref:System.Threading.Tasks.Task?displayProperty=fullName>|A excepción de `Task.IAsyncResult.AsyncWaitHandle`, los métodos <xref:System.Threading.Tasks.Task?displayProperty=fullName> ya no producen una excepción <xref:System.ObjectDisposedException> después de desechar el objeto.|Este cambio admite el uso de tareas almacenadas en memoria caché. Por ejemplo, un método puede devolver una tarea almacenada en caché para representar una operación completada en lugar de asignar una nueva tarea. Esto no era posible en versiones anteriores de .NET Framework, ya que cualquier consumidor de la tarea podía desecharla, lo que hacía que se volviera inutilizable.|  
|Excepciones inadvertidas en las operaciones de <xref:System.Threading.Tasks.Task?displayProperty=fullName>|Dado que la clase <xref:System.Threading.Tasks.Task?displayProperty=fullName> representa una operación asincrónica, detecta todas las excepciones no graves que se producen durante el procesamiento asincrónico. En [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], si no se detecta una excepción y el código nunca espera a que se complete la tarea, la excepción ya no se propagará en el subproceso finalizador y bloqueará el proceso durante la recolección de elementos no utilizados.|Este cambio mejora la confiabilidad de las aplicaciones que utilizan la clase <xref:System.Threading.Tasks.Task> para realizar un procesamiento asincrónico inadvertido. El comportamiento anterior puede restaurarse proporcionando un controlador adecuado para el evento <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException?displayProperty=fullName>.|  
|Métodos <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> con argumentos de tiempo de espera|En [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], estos métodos se comportaban de forma incoherente. Cuando se agotaba el tiempo de espera, si una o varias tareas se completaban o cancelaban antes de la llamada al método, el método producía una excepción <xref:System.AggregateException>. Cuando se agotaba el tiempo de espera, si no se completaba ni cancelaba ninguna tarea antes de la llamada al método pero una o varias tareas entraban en estos estados después de la llamada al método, el método devolvía `false`.<br /><br /> En [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], estas sobrecargas de método ahora devuelven `false` si las tareas siguen en ejecución cuando se agota el intervalo de tiempo de espera y producen una excepción <xref:System.AggregateException> solo si se ha cancelado una tarea de entrada \(independientemente de si se canceló antes o después de la llamada al método\) y no hay ninguna tarea en ejecución.|Este cambio hace que el comportamiento del método sea coherente. Sin embargo, es posible \(aunque improbable\) que el código de la aplicación dependa de las sobrecargas de <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=fullName> habilitadas con tiempo de espera para producir una excepción cuando al menos ha habido un error en una tarea o esta se ha cancelado antes de que se agotara el tiempo de espera. En ese caso, la propiedad <xref:System.Threading.Tasks.Task.IsCanceled%2A?displayProperty=fullName> puede utilizarse para el mismo propósito.|  
|Compatibilidad con el reenvío de tipos al utilizar la compatibilidad con múltiples versiones \(multi\-targeting\)|Una nueva característica de CodeDOM permite a un compilador realizar la compilación en la versión de destino de mscorlib.dll en lugar de en la versión [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] de mscorlib.dll.|Este cambio evita que aparezcan advertencias del compilador \(y errores de compilación en los casos en los que las advertencias se traten como errores\) cuando CodeDOM encuentra dos definiciones de tipos con reenvío de tipos. Este cambio solo puede tener efectos secundarios imprevistos si en una única ubicación se combinan diferentes versiones de los ensamblados de referencia.|  
|<xref:System.Collections.Generic.List%601.ForEach%2A?displayProperty=fullName>|El enumerador inicia una excepción <xref:System.InvalidOperationException> si se modifica un elemento de la colección.|Este cambio solo se utiliza en las aplicaciones cuyo destino es [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] y no debería tener ningún impacto negativo. Protege la integridad de los datos y hace que sea más probable que se identifiquen las condiciones de carrera.|  
|<xref:System.Uri?displayProperty=fullName>|Dos cambios en el análisis de identificadores de recursos internacionales \(IRI\) afectan a los URI de las aplicaciones diseñadas para [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]:<br /><br /> [\<análisisIRI\>](../../../docs/framework/configure-apps/file-schema/network/iriparsing-element-uri-settings.md) está habilitado de manera predeterminada y no se puede desactivar. Anteriormente, estaba deshabilitado de forma predeterminada.<br /><br /> La forma de normalización Unicode C \(NFC\) ya no se aplicará a las partes no hospedadas de los URI. Anteriormente, NFC se aplicaba a todo el identificador URI cuando `<iriParsing>` estaba habilitado.|Los URI que contienen nombres de archivo normalizados que no son NFC \(forma de normalización C\) no se normalizarán a la forma C. Puede producirse un error en la aplicación si el análisis IRI usa cadenas no normalizadas para acceder a archivos con nombres de archivo normalizados. Esto solo afecta a las aplicaciones diseñadas para [!INCLUDE[net_v45](../../../includes/net-v45-md.md)].|  
|<xref:System.Uri?displayProperty=fullName>|Una dirección URL `mailto:` no válida inicia una excepción en el constructor de clases <xref:System.Uri>.|Esto solo afecta a las aplicaciones que se vuelven a compilar y que tienen como destino [!INCLUDE[net_v45](../../../includes/net-v45-md.md)].|  
|<xref:System.Uri?displayProperty=fullName>|En aplicaciones cuyo destino es [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], se conservan los puntos situados al final de un segmento de ruta de acceso en las cadenas URI originales \(por ejemplo, `http://www.proseware.com/LLC./About.aspx`\). \(Tenga en cuenta los segmentos de ruta de acceso que constan exactamente de uno o dos puntos, como `http://www.proseware.com/..` o `http://www.proseware.com/./default.htm`, se quitan, aunque se conservan los segmentos de ruta de acceso que tienen más de dos puntos consecutivos, como `http://localhost/dir1/.../dir2`\).|Este cambio solo afecta a las aplicaciones que tienen como destino [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]. Las aplicaciones que se basan en los puntos finales eliminados pueden experimentar errores.|  
|<xref:System.Uri?displayProperty=fullName>|En aplicaciones que tienen como destino [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], están permitidas las consultas de una URI `file://`; el carácter ? no está precedido por un carácter de escape porque se interpreta como parte de la ruta de acceso.|Este cambio solo afecta a las aplicaciones que tienen como destino [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]. Las aplicaciones que dependen del uso de un carácter de escape antes del carácter ? pueden experimentar errores.|  
|<xref:System.Uri?displayProperty=fullName>|En aplicaciones que tienen como destino [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], los caracteres de control Unicode comprendidos entre U\+0080 y U\+009F no se codifican correctamente.|Normalmente, los caracteres de control Unicode no se usan en los URI.|  
|<xref:System.Uri.EscapeDataString%2A?displayProperty=fullName>, <xref:System.Uri.EscapeUriString%2A?displayProperty=fullName> y <xref:System.Uri.UnescapeDataString%2A?displayProperty=fullName>|La lista de caracteres reservados y no reservados admite ahora [RFC 3986](http://tools.ietf.org/html/rfc3986).|Cambios concretos:<br /><br /> El método <xref:System.Uri.EscapeDataString%2A> incluye los caracteres reservados entre caracteres de escape de con arreglo a RFC 3986.<br /><br /> El método <xref:System.Uri.EscapeUriString%2A> no incluye entre caracteres de escape los caracteres reservados.<br /><br /> El método <xref:System.Uri.UnescapeDataString%2A> no inicia una excepción si encuentra una secuencia de escape no válida.<br /><br /> Los caracteres de escape no reservados no se incluyen en una secuencia de escape.|  
|<xref:System.Uri.IsWellFormedUriString%2A?displayProperty=fullName>|A partir de .NET Framework 4.5, las cadenas se consideran siempre bien formadas de acuerdo con [RFC 3986](http://tools.ietf.org/html/rfc3986) y [RFC 3987](http://tools.ietf.org/html/rfc3987). En versiones anteriores de .NET Framework, una cadena se considera bien formada de acuerdo con RFC 3986 y RFC 3987 únicamente si el análisis de URI y el análisis de IDN están habilitados.|Para las aplicaciones que tienen como destino .NET Framework 4.5 o versiones posteriores, este método devuelve `false` para algunos URI que se consideran bien formados por parte de aplicaciones que tienen como destino versiones anteriores de .NET Framework. Por ejemplo, un URI relativo que incluye un signo de dos puntos en su primer segmento \(por ejemplo, "2013.05.29\_14:33:41"\) ya no se considera bien formado.<br /><br /> Tenga en cuenta que este cambio solo afecta a las aplicaciones que tienen como destino .NET Framework 4.5 o versiones posteriores.|  
|<xref:System.Threading.Tasks.TaskFactory.FromAsync%2A?displayProperty=fullName>|<xref:System.Threading.Tasks.TaskFactory.FromAsync%2A?displayProperty=fullName> ahora puede acceder a la propiedad <xref:System.IAsyncResult.CompletedSynchronously%2A?displayProperty=fullName>. Es posible que las implementaciones incorrectas de <xref:System.IAsyncResult.CompletedSynchronously%2A?displayProperty=fullName> ahora tengan como resultado un comportamiento indefinido en las llamadas de método <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A?displayProperty=fullName>.|La tarea resultante no se completará si la implementación de la propiedad <xref:System.IAsyncResult.CompletedSynchronously%2A?displayProperty=fullName> devuelve `true` por error.|  
  
<a name="sql"></a>   
## Datos  
  
### SQLClient  
  
|Característica|Cambio|Impacto|  
|--------------------|------------|-------------|  
|Capacidad para conectarse a una base de datos de SQL Server desde el código administrado que se ejecuta en [!INCLUDE[net_v45](../../../includes/net-v45-md.md)].|Se ha modificado la ruta de acceso al código de la API sincrónica existente para incorporar compatibilidad asincrónica.|La presencia de Proveedores de servicios de base \(BSP\) Winsock que no son IFS o de Proveedores de servicios por capas \(LSP\) puede interferir con la capacidad de conectarse a SQL Server. Para más información, consulte [La API SetFileCompletionNotificationModes hace que un puerto de finalización de E\/S no funcione correctamente con un LSP instalado que no es IFS](http://go.microsoft.com/fwlink/p/?LinkId=256032) en el sitio web de soporte técnico de Microsoft.|  
|Tipo de <xref:System.Data.SqlClient.SqlConnection?displayProperty=fullName>|Ya no se admiten las conexiones a las bases de datos de SQL Server 1997.|Las aplicaciones que se ejecutan en [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] no pueden conectarse a las bases de datos de SQL Server 1997.|  
|Tipo de <xref:System.Data.SqlClient.SqlConnection?displayProperty=fullName>|Ya no se admiten las conexiones a las bases de datos de SQL Server que utilizan el protocolo VIA \(adaptador de interfaz virtual\).|Las aplicaciones que se ejecutan en [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] no pueden conectarse a las bases de datos de SQL Server mediante VIA.|  
|Tipo de <xref:System.Data.SqlClient.SqlBulkCopy?displayProperty=fullName>|Al insertar datos en una columna, <xref:System.Data.SqlClient.SqlBulkCopy> utiliza la codificación de la columna de destino en lugar de la codificación predeterminada para los tipos `VARCHAR` y `CHAR`.|Este cambio elimina la posibilidad de que se produzcan daños en los datos al usar la codificación predeterminada cuando la columna de destino no utiliza la codificación predeterminada. En raras ocasiones, una aplicación existente podría producir una excepción <xref:System.Data.SqlClient.SqlException> si el cambio de codificación produce datos que son demasiado grandes como para caber en la columna de destino.|  
|Secuencia de intercalación de <xref:System.Data.SqlClient?displayProperty=fullName>|Los datos de `sql_variant` utilizan la intercalación de `sql_variant` en lugar de la intercalación de base de datos.|Este cambio soluciona posibles daños en los datos si la intercalación de la base de datos difiere de la intercalación de `sql_variant`. Las aplicaciones que se basan en datos dañados pueden experimentar errores.|  
  
### Entity Framework  
  
|Característica|Cambio|Impacto|  
|--------------------|------------|-------------|  
|Archivos de registro creados por el método <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A?displayProperty=fullName>|Cuando se llama al método <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A>, ya sea directamente o mediante Code First con el proveedor SqlClient y un valor `AttachDBFilename` en la cadena de conexión, se crea un archivo de registro denominado *nombreDeArchivo*\_log.ldf en lugar de *nombreDeArchivo*.ldf \(donde *nombreDeArchivo* es el nombre del archivo especificado mediante el valor `AttachDBFilename`\).|Este cambio mejora la depuración al proporcionar un archivo de registro cuyo nombre se ajusta a las especificaciones de SQL Server. No debería tener ningún efecto secundario inesperado.|  
|API de lenguaje de definición de datos \(DDL\)|El comportamiento de las API de DDL cuando se especifica `AttachDBFilename` ha cambiado tal y como se describe a continuación:<br /><br /> Las cadenas de conexión no necesitan especificar un valor `Initial Catalog`. Anteriormente se requería `AttatchDBFilename` e `Initial Catalog`.<br /><br /> Si se especifican `AttatchDBFilename` e `Initial Catalog` y existe el archivo MDF indicado, el método <xref:System.Data.Objects.ObjectContext.DatabaseExists%2A?displayProperty=fullName> devuelve `true`. Anteriormente devolvía `false`.<br /><br /> Si se especifican `AttatchDBFilename` e `Initial Catalog` y existe el archivo MDF indicado, al llamar al método <xref:System.Data.Objects.ObjectContext.DeleteDatabase%2A?displayProperty=fullName> se eliminan los archivos.<br /><br /> Si se llama a <xref:System.Data.Objects.ObjectContext.DeleteDatabase%2A?displayProperty=fullName> cuando la cadena de conexión especifica un valor `AttachDBFilename` con un archivo MDF y un `Initial Catalog` que no existen, el método inicia una excepción <xref:System.InvalidOperationException>. Anteriormente iniciaba una excepción <xref:System.Data.SqlClient.SqlException>.|Estos cambios facilitan la creación de herramientas y aplicaciones que utilizan las API de DDL. Estos cambios pueden afectar a la compatibilidad de las aplicaciones en los escenarios siguientes:<br /><br /> El usuario escribe código que ejecuta directamente un comando `DROP DATABASE` en lugar de llamar al método <xref:System.Data.Objects.ObjectContext.DeleteDatabase%2A?displayProperty=fullName> si el método <xref:System.Data.Objects.ObjectContext.DatabaseExists%2A?displayProperty=fullName> devuelve `true`. Esto interrumpe el código existente si la base de datos no está asociada pero el archivo MDF existe.<br /><br /> El usuario escribe código en el que espera que el método <xref:System.Data.Objects.ObjectContext.DeleteDatabase%2A?displayProperty=fullName> inicie una excepción <xref:System.Data.SqlClient.SqlException> en lugar de una excepción <xref:System.InvalidOperationException> si `Initial Catalog` ni el archivo MDF existen.|  
|Métodos <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A?displayProperty=fullName> y <xref:System.Data.Common.DbProviderServices.CreateDatabase%2A?displayProperty=fullName>|Si se produce un error en la creación de objetos de base de datos después de crear una base de datos vacía, el método intenta quitar la creación de base de datos y propaga la excepción <xref:System.Data.SqlClient.SqlException> original. Si no se puede quitar la base de datos, el método inicia una excepción <xref:System.InvalidOperationException>.|Este cambio impide que se cree una base de datos vacía inutilizable. El control de excepciones puede presentar alguna variación, ya que la eliminación correcta de la base de datos ahora propaga la excepción <xref:System.Data.SqlClient.SqlException> original.|  
|Métodos <xref:System.Data.Objects.ObjectContext.Translate%2A?displayProperty=fullName> y <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A?displayProperty=fullName>|Si `T` es un tipo de enumeración, el método devuelve correctamente los datos de la base de datos.  Anteriormente, no se admitían tipos de enumeraciones, por lo que el resultado siempre daba cero o se convertía al tipo de la enumeración. Los tipos subyacentes no admitidos por Entity Framework, como <xref:System.UInt16>, <xref:System.UInt32> y <xref:System.UInt64>, siguen devolviendo cero o se convierten al tipo de la enumeración con el valor subyacente cero.|La compatibilidad con las enumeraciones es nueva en Entity Framework de [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]. Sin embargo, si el código del desarrollador depende de que el resultado sea cero, podría producirse un error en la aplicación, dependiendo del código en concreto.|  
  
### LINQ  
  
|Característica|Cambio|Impacto|  
|--------------------|------------|-------------|  
|Método <xref:System.Linq.Enumerable.Empty%2A?displayProperty=fullName>|El método devuelve una instancia interna almacenada en caché en lugar de devolver un nuevo tipo <xref:System.Collections.Generic.IEnumerable%601>.|Este cambio produce una mejora del rendimiento. Sin embargo, el código que dependa de que se obtengan dos tipos vacíos únicos en varias llamadas a <xref:System.Linq.Enumerable.Empty%2A?displayProperty=fullName> producirá un error.|  
  
<a name="network"></a>   
## Redes  
  
|Característica|Cambio|Impacto|  
|--------------------|------------|-------------|  
|Tipos y miembros del espacio de nombres <xref:System.Net.PeerToPeer.Collaboration?displayProperty=fullName>|Estos tipos y miembros no se admiten en [!INCLUDE[win8](../../../includes/win8-md.md)]. Al intentar llamarlos, se inicia una excepción <xref:System.PlatformNotSupportedException>.|Las aplicaciones ya no pueden usar estos tipos y miembros en [!INCLUDE[win8](../../../includes/win8-md.md)].|  
|Serialización y deserialización de objetos <xref:System.Net.Mail.MailMessage>.|En .NET Framework 4.5, los mensajes de correo electrónico pueden incluir caracteres no ASCII. En .NET Framework 4, solo se admiten caracteres ASCII.|Los objetos <xref:System.Net.Mail.MailMessage> que contienen caracteres no ASCII y que están serializados en .NET Framework 4.5 no se pueden deserializar en .NET Framework 4.|  
  
<a name="Printing"></a>   
## Impresión  
  
|Característica|Cambio|Impacto|  
|--------------------|------------|-------------|  
|<xref:System.Printing.PrintSystemJobInfo.JobStream%2A?displayProperty=fullName>|Esta propiedad expone la secuencia de un trabajo de impresión y permite que el usuario envíe datos sin formato a los componentes de impresión del sistema operativo subyacente mediante la escritura en esta secuencia.<br /><br /> A partir de .NET Framework 4.5 en Windows 8 y las versiones posteriores del sistema operativo Windows, los datos que se escriben en esta secuencia deben estar en formato XPS como una secuencia de paquete.|Para mostrar contenido de impresión, puede realizar una de las acciones siguientes:<br /><br /> Utilice la clase <xref:System.Windows.Xps.XpsDocumentWriter> para mostrar contenido de impresión. Esta es la alternativa recomendada.<br /><br /> Asegúrese de que los datos enviados a la secuencia que devuelve la propiedad <xref:System.Printing.PrintSystemJobInfo.JobStream%2A?displayProperty=fullName> están en formato XPS como una secuencia de paquete.|  
  
<a name="serialize"></a>   
## Serialización  
  
|Característica|Cambio|Impacto|  
|--------------------|------------|-------------|  
|Serialización con la clase <xref:System.Xml.Serialization.XmlSerializer>|En WCF 4.5, la clase <xref:System.Xml.Serialization.XmlSerializer> se optimizó para quitar su dependencia del compilador de C\#. Este cambio ofrece importantes mejoras de rendimiento para los escenarios de arranque en frío.|Este cambio puede causar problemas en el código de serialización de XML que se compiló en WCF 4, pero se ejecuta en WCF 4.5. Si encuentra problemas al ejecutar el código de serialización de XML existente en WCF 4.5, utilice el siguiente elemento de configuración para revertir al comportamiento de XmlSerializer en WCF 4:<br /><br /> `<configuration>    <system.xml.serialization>    <xmlSerializer useLegacySerializerGeneration="true"/>    </system.xml.serialization> </configuration>`|  
|Serialización y deserialización con la clase <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter?displayProperty=fullName>|La serialización mediante <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> puede codificar el estado interno de un objeto, que no se garantiza que sea el mismo entre distintas versiones de .NET Framework.  Si hay diferencias, el contenido serializado en una versión de .NET Framework puede que no se deserialice en otras versiones.|La clase <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> no garantiza la compatibilidad entre versiones. En su lugar, utilice las clases <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter?displayProperty=fullName> y <xref:System.Runtime.Serialization.NetDataContractSerializer?displayProperty=fullName>.|  
  
<a name="tools"></a>   
## Herramientas y recursos  
  
|Característica|Cambio|Impacto|  
|--------------------|------------|-------------|  
|MSBuild|Al ejecutar MSBuild en el símbolo del sistema, se respetarán los archivos de configuración de la solución que deshabilitan compilaciones de proyectos concretos.|MSBuild se comporta de igual forma cuando lo llama Visual Studio y cuando se ejecuta desde un símbolo del sistema. No tiene que crear soluciones independientes ni quitar proyectos de una solución para compilar un subconjunto de proyectos de una solución.|  
|MSBuild|La propiedad `TreatAsLocalProperty` de los archivos de proyecto de MSBuild evita que determinadas propiedades, incluida la propiedad `OutDir`, se invaliden globalmente.|Las invalidaciones de la propiedad `OutDir` pueden producir una posible interrupción si `OutDir` es una propiedad global que se invalida después de importar el archivo MS.Common.Targets.|  
|Informes de errores de Windows: depósitos de Watson|Los bloqueos administrados se agrupaban en categorías según diversos criterios, uno de los cuales era la versión del ensamblado. En [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], se usa la versión del archivo en lugar de la versión del ensamblado.|Dado que la versión del ensamblado solo cambia entre las versiones principales, si se usa como categoría la versión del archivo en lugar de la versión del ensamblado, será posible determinar la versión específica de un ensamblado que ha estado implicada en un bloqueo administrado.|  
|MSBuild|Los datos de los proyectos en la colección de <xref:Microsoft.Build.Evaluation.ProjectCollection?displayProperty=fullName> no son reclamados automáticamente por el recolector de elementos no utilizados.|Si carga los proyectos de manera explícita en la colección de <xref:Microsoft.Build.Evaluation.ProjectCollection>, deberá llamar al método <xref:Microsoft.Build.Evaluation.ProjectCollection.UnloadProject%28Microsoft.Build.Evaluation.Project%29> por cada miembro de la colección.|  
  
<a name="asp"></a>   
## ASP.NET  
  
|Característica|Cambio|Impacto|  
|--------------------|------------|-------------|  
|Herramienta de registro de IIS en ASP.NET \(aspnet\_regiis.exe\)|En [!INCLUDE[win8](../../../includes/win8-md.md)], no se admiten las opciones `–i` y `–u` para instalar y desinstalar ASP.NET.|Para instalar o desinstalar ASP.NET 4.5 con IIS 8, use el cuadro de diálogo **Activar o desactivar características de Windows**, la herramienta de administración del servidor o la herramienta de línea de comandos `dism.exe`.|  
|Control <xref:System.Web.UI.WebControls.EntityDataSource?displayProperty=fullName>|El evento <xref:System.Web.UI.Page.LoadComplete?displayProperty=fullName> ya no hace que el control <xref:System.Web.UI.WebControls.EntityDataSource?displayProperty=fullName> llame al enlace de datos cuando se producen cambios al crear, actualizar o eliminar parámetros.|Este cambio elimina un viaje superfluo a la base de datos, impide que se restablezcan los valores de los controles y produce un comportamiento coherente con otros controles de datos, como <xref:System.Web.UI.WebControls.SqlDataSource> y <xref:System.Web.UI.WebControls.ObjectDataSource>. Este cambio produce un comportamiento diferente en el caso improbable de que las aplicaciones invoquen el enlace de datos en el evento <xref:System.Web.UI.Page.LoadComplete?displayProperty=fullName>.|  
|Métodos <xref:System.Net.WebUtility.HtmlDecode%2A?displayProperty=fullName>, <xref:System.Net.WebUtility.UrlDecode%2A?displayProperty=fullName> y [System.Web.Helpers.Json.Decode](https://msdn.microsoft.com/library/system.web.helpers.json.decode.aspx)|De forma predeterminada, los métodos de descodificación ya no descodifican secuencias de entrada no válidas en una cadena UTF\-16 no válida. En su lugar, devuelven la entrada original.|El cambio en la salida del descodificador solo es importante si se almacenan datos binarios en lugar de datos UTF\-16 en cadenas. Para controlar este comportamiento de manera explícita, establezca el atributo `aspnet:AllowRelaxedUnicodeDecoding` del elemento [\<configuraciónAplicación\>](http://msdn.microsoft.com/es-es/0d65a3f1-c522-423d-89b6-44921b6daebb) en `true` para activar el comportamiento heredado o en `false` para activar el comportamiento actual.|  
|Método <xref:System.Net.WebUtility.HtmlEncode%2A?displayProperty=fullName>|En las aplicaciones que tienen como destino [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], los caracteres que no pertenecen a Basic Multilingual Plane \(BMP\) hacen el recorrido de ida y vuelta correctamente cuando se pasan al método <xref:System.Net.WebUtility.HtmlDecode%2A?displayProperty=fullName>.|Este cambio no debe tener ningún efecto en las aplicaciones actuales. Para restaurar el comportamiento original, establezca el atributo `targetFramework` del elemento [\<httpRuntime\>](http://msdn.microsoft.com/library/e1f13641\(v=vs.100\).aspx) en una cadena distinta de "4.5". También puede establecer los atributos `unicodeEncodingConformance` y `unicodeDecodingConformance` del elemento de configuración `<webUtility>` para controlar este comportamiento con independencia de la versión de .NET Framework que se use como destino.|  
|Propiedad <xref:System.Web.HttpRequest.ContentEncoding%2A?displayProperty=fullName>|La codificación UTF\-7 está prohibida.|Los datos de las aplicaciones que dependen de los datos de entrada UTF\-7 no se descodificarán correctamente en algunos casos. Aunque no es frecuente, puede restaurar el comportamiento heredado mediante el atributo `aspnet:AllowUtf7RequestContentEncoding` del elemento [\<configuraciónAplicación\>](http://msdn.microsoft.com/es-es/0d65a3f1-c522-423d-89b6-44921b6daebb).|  
|<xref:System.Web.HttpUtility.JavaScriptStringEncode%2A?displayProperty=fullName>|A partir de [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], el método incluye un carácter de escape antes del carácter de Y comercial \(&\).|Si la aplicación utiliza el comportamiento anterior de este método, puede agregar un valor `aspnet:JavaScriptDoNotEncodeAmpersand` al [elemento appSettings de ASP.NET](http://msdn.microsoft.com/es-es/bb60e711-0669-4118-a54d-8dd71e009a00) en el archivo de configuración.|  
|Métodos <xref:System.Web.Security.MachineKey.Encode%2A?displayProperty=fullName> y <xref:System.Web.Security.MachineKey.Decode%2A?displayProperty=fullName>|Estos métodos están obsoletos.|La compilación del código que llama a estos métodos genera una advertencia del compilador. Las alternativas recomendadas son <xref:System.Web.Security.MachineKey.Protect%2A?displayProperty=fullName> y <xref:System.Web.Security.MachineKey.Unprotect%2A?displayProperty=fullName>.|  
  
<a name="ClickOnce"></a>   
## ClickOnce  
  
|Característica|Cambio|Impacto|  
|--------------------|------------|-------------|  
|Aplicaciones publicadas con ClickOnce que usan un certificado de firma de código SHA\-256.|El archivo ejecutable está firmado con SHA\-256. Antes se firmaba con SHA1, independientemente de si el certificado de firma de código era SHA\-1 o SHA\-256. Esto se aplica a lo siguiente:<br /><br /> Todas las aplicaciones compiladas con Visual Studio 2012 o versiones posteriores.<br /><br /> Aplicaciones compiladas con Visual Studio 2010 o versiones anteriores en sistemas con .NET Framework 4.5.<br /><br /> Además, si está presente .NET Framework 4.5 o versiones posteriores, el manifiesto de ClickOnce también está firmado con SHA\-256 para certificados SHA\-256, independientemente de la versión de .NET Framework con la que se compiló.|El cambio en la firma del ejecutable ClickOnce solo afecta a los sistemas Windows Server 2003; necesitan que [KB 938397](http://support.microsoft.com/kb/938397) esté instalado.<br /><br /> El cambio al firmar el manifiesto con SHA\-256, incluso cuando una aplicación tiene como destino .NET Framework 4 o versiones anteriores, introduce una dependencia de tiempo de ejecución en .NET Framework 4.5 o versiones posteriores. Este problema se resolvió en Visual Studio 2013 Update 3 y en [!INCLUDE[net_v46](../../../includes/net-v46-md.md)]. Para la resolución [!INCLUDE[net_v46](../../../includes/net-v46-md.md)], consulte [Cambios en tiempo de ejecución](../../../docs/framework/migration-guide/runtime-changes-in-the-net-framework-4-6.md).|  
  
<a name="mef"></a>   
## Managed Extensibility Framework \(MEF\)  
  
|Característica|Cambio|Impacto|  
|--------------------|------------|-------------|  
|<xref:System.ComponentModel.Composition.Primitives.ComposablePartCatalog?displayProperty=fullName> y sus clases derivadas|A partir de [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], los catálogos de MEF implementan <xref:System.Collections.IEnumerable> y, por consiguiente, ya no se pueden utilizar para crear un serializador \(objeto <xref:System.Xml.Serialization.XmlSerializer>\).|Al intentar serializar un catálogo de MEF se inicia una excepción.|  
  
<a name="web"></a>   
## Aplicaciones Web  
  
|Característica|Cambio|Impacto|  
|--------------------|------------|-------------|  
|Controles de hospedaje de explorador administrados de .NET Framework 1.1 y 2.0|El hospedaje de estos controles está bloqueado en Internet Explorer.|Internet Explorer no podrá iniciar una aplicación que use controles de hospedaje de explorador administrados. El comportamiento anterior se puede restaurar estableciendo el valor EnableIEHosting de la subclave del Registro HKLM\/SOFTWARE\/MICROSOFT\/.NETFramework en 1 para sistemas x86 y para procesos de 32 bits en sistemas x64 y estableciendo el valor EnableIEHosting de la subclave del Registro HKLM\/SOFTWARE\/Wow6432Node\/Microsoft\/.NETFramework en 1 para procesos de 64 bits en sistemas x64.|  
  
<a name="wcf"></a>   
## Windows Communication Foundation \(WCF\)  
 Además de los siguientes problemas de compatibilidad de aplicaciones, consulte la sección [Serialización](#serialize) para conocer problemas relacionados con la serialización.  
  
|Característica|Cambio|Impacto|  
|--------------------|------------|-------------|  
|Mensajes de los servicios Web de WCF hospedados en Internet Information Services \(IIS\) o ASP.NET que superan el valor `maxRequestLength` \(en ASP.NET\) o `maxReceivedMessageSize` \(en WCF\)|El código de estado HTTP ha cambiado de 400 \(Solicitud incorrecta\) a 413 \(Entidad de solicitud demasiado grande\), y los mensajes que superan el valor `maxRequestLength` o `maxReceivedMessageSize` inician una excepción <xref:System.ServiceModel.ProtocolException>. Esto incluye los casos en los que el modo de transferencia es <xref:System.ServiceModel.TransferMode>.|Este cambio facilita la depuración en los casos en los que la longitud del mensaje supera los límites permitidos por ASP.NET o WCF.<br /><br /> Debe modificar cualquier código que realice el procesamiento basándose en un código de estado HTTP 400.|  
|`Replace` en las direcciones URL de OData|El método `Replace` de las direcciones URL de OData está deshabilitado de forma predeterminada.|Cuando el método `Replace` de OData está deshabilitado \(ahora de forma predeterminada\), la solicitud del usuario iniciará una excepción y se producirá un error en la solicitud.|  
|<xref:System.ServiceModel.Web.WebServiceHost?displayProperty=fullName>|El objeto <xref:System.ServiceModel.Web.WebServiceHost?displayProperty=fullName> ya no agrega un extremo predeterminado si el código de la aplicación ha agregado un extremo explícito.|Si una aplicación cliente intenta conectarse a un extremo que ya no se agrega de forma predeterminada, se producirá un error de HTTP.|  
  
<a name="winForms"></a>   
## Windows Forms  
  
|Característica|Cambio|Impacto|  
|--------------------|------------|-------------|  
|System.Drawing.dll|La propiedad `CheckForOverflowUnderflow` del ensamblado está establecida en `true`.|Anteriormente, cuando se producían desbordamientos, el resultado se truncaba de manera silenciosa. Ahora se inicia una excepción <xref:System.OverflowException>.|  
|Constructor <xref:System.Drawing.Imaging.EncoderParameter.%23ctor%28System.Drawing.Imaging.Encoder%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29?displayProperty=fullName>|El constructor está desusado.|El constructor no funciona en sistemas de 64 bits. Use el constructor <xref:System.Drawing.Imaging.EncoderParameter.%23ctor%28System.Drawing.Imaging.Encoder%2CSystem.Int32%2CSystem.Drawing.Imaging.EncoderParameterValueType%2CSystem.IntPtr%29?displayProperty=fullName> en su lugar.|  
  
<a name="wpf"></a>   
## Windows Presentation Foundation \(WPF\)  
 Además de los siguientes problemas de compatibilidad de aplicaciones, consulte la sección [Serialización](#serialize) para conocer problemas relacionados con la serialización.  
  
|Característica|Cambio|Impacto|  
|--------------------|------------|-------------|  
|Propiedad <xref:System.Windows.Controls.Primitives.TextBoxBase.UndoLimit%2A?displayProperty=fullName>|El límite predeterminado para el número máximo de operaciones de deshacer en las clases <xref:System.Windows.Controls.TextBox> y <xref:System.Windows.Controls.RichTextBox> ha cambiado de \-1 \(sin límite\) a 100.|Este cambio no debería tener ningún impacto negativo. Sin embargo, puede establecer explícitamente la propiedad <xref:System.Windows.Controls.Primitives.TextBoxBase.UndoLimit%2A> después de crear una instancia del control.|  
|Enumeración <xref:System.Windows.Controls.PageRangeSelection?displayProperty=fullName>|Se han agregado los miembros <xref:System.Windows.Controls.PageRangeSelection> y <xref:System.Windows.Controls.PageRangeSelection> a la enumeración.|Este cambio no debería tener ningún impacto en las aplicaciones existentes. El valor predeterminado es <xref:System.Windows.Controls.PageRangeSelection?displayProperty=fullName> para los miembros existentes que utilizan esta enumeración.|  
|Elementos <xref:System.Windows.DataTemplate>|Los elementos <xref:System.Windows.DataTemplate> ahora aparecen en la vista de control del árbol de automatización de la interfaz de usuario \(UIA\).|Este cambio mejora la accesibilidad. Sin embargo, afecta a las herramientas de prueba que usan la estructura anterior del árbol de UIA para buscar elementos vecinos.|  
|Sincronización de la propiedad <xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=fullName> y de la propiedad a la que está enlazada|En algunos casos, la propiedad <xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=fullName> refleja un valor anterior al valor de propiedad de enlace de datos si la propiedad se modifica durante una operación de escritura de enlace de datos.|Esto no debería tener ningún impacto negativo. Sin embargo, puede restaurar el comportamiento anterior estableciendo la propiedad <xref:System.Windows.FrameworkCompatibilityPreferences.KeepTextBoxDisplaySynchronizedWithTextProperty%2A?displayProperty=fullName> en `false`.|  
|Propiedad <xref:System.Windows.Controls.TextBox?displayProperty=fullName>|Cuando un control <xref:System.Windows.Controls.TextBox?displayProperty=fullName> está inactivo, el texto seleccionado en el cuadro aparece en un color diferente que cuando el cuadro de texto está activo.|Puede restaurar el comportamiento anterior estableciendo la propiedad <xref:System.Windows.FrameworkCompatibilityPreferences.AreInactiveSelectionHighlightBrushKeysSupported%2A?displayProperty=fullName> en `false`.|  
|<xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName>|Si un control derivado de <xref:System.Windows.Controls.Primitives.MultiSelector> con <xref:System.Windows.Controls.Primitives.MultiSelector.CanSelectMultipleItems%2A> establecido en `true` tiene duplicados en su colección <xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName>, los elementos duplicados aparecen más de una vez. Si estos elementos se quitan del origen de datos \(por ejemplo, llamando a `Items.Clear`\), no se quitan de la colección <xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName>; solo se quita la primera instancia.<br /><br /> El uso posterior de la colección <xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName>, como una llamada a `SelectedItems.Clear`, puede tener problemas, como una excepción <xref:System.ArgumentException>, porque la colección <xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName> contiene elementos que ya no están en el origen de datos.|Este problema se ha corregido en [!INCLUDE[net_v462](../../../includes/net-v462-md.md)]. Si una colección <xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName> tiene elementos duplicados, quítelos del origen de datos. Si quiere seguir trabajando con la colección <xref:System.Windows.Controls.Primitives.MultiSelector.SelectedItems%2A?displayProperty=fullName>, actualice a [!INCLUDE[net_v462](../../../includes/net-v462-md.md)].|  
|<xref:System.Windows.Threading.DispatcherSynchronizationContext.CreateCopy%2A?displayProperty=fullName>|En [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], el método devuelve una referencia a la instancia actual. En [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], devuelve una nueva instancia.|El código que presupone que las referencias iguales indican que el subproceso en ejecución está en el contexto correcto ahora se ejecutará correctamente. Sin embargo, debido a este cambio, es necesario comprobar el código que llama a <xref:System.Windows.Threading.DispatcherSynchronizationContext.CreateCopy%2A?displayProperty=fullName>.|  
|Supervisar los mensajes `WM_POWERBROADCAST` con un controlador agregado mediante una llamada al método <xref:System.Windows.Interop.HwndSource.AddHook%2A?displayProperty=fullName>.|Debe registrarse de forma explícita una ventana para notificaciones `WM_POWERBROADCAST` pasando su controlador de la función [RegisterPowerSettingNotification](https://msdn.microsoft.com/library/windows/desktop/aa373196.aspx). WPF hizo esta acción de forma automática para todas las ventanas mediante [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)]. A partir de [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], WPF registra automáticamente una ventana especial, pero no registra automáticamente la mayoría de las ventanas de la aplicación.|No se ejecuta el código que administra las notificaciones `WM_POWERBROADCAST`.<br /><br /> Para continuar recibiendo notificaciones `WM_POWERBROADCAST`, llame a la función [RegisterPowerSettingNotification](https://msdn.microsoft.com/library/windows/desktop/aa373196.aspx) para registrar una ventana de WPF \(normalmente la ventana de la aplicación principal\) para notificaciones `WM_POWERBROADCAST`. En las aplicaciones WPF que desarrolle con C\#, también debe seleccionar la casilla **Permitir código no seguro** en la pestaña **Compilar** de las propiedades del proyecto.<br /><br /> Además, si va a registrar una ventana que no se conserva hasta que cierre de la aplicación, se debe anular su registro mediante una llamada a la función [UnregisterPowerSettingNotification](https://msdn.microsoft.com/library/windows/desktop/aa373237.aspx), pasándole el controlador `HPOWERNOTIFY` que devuelve la llamada a la función [RegisterPowerSettingNotification](https://msdn.microsoft.com/library/windows/desktop/aa373196.aspx).|  
  
<a name="wwf"></a>   
## Windows Workflow Foundation \(WF\)  
  
|Característica|Cambio|Impacto|  
|--------------------|------------|-------------|  
|Seguridad de System.Activities.dll|El ensamblado está marcado con el atributo <xref:System.Security.AllowPartiallyTrustedCallersAttribute>.|Las clases derivadas no se pueden marcar con el atributo <xref:System.Security.SecurityCriticalAttribute>. Anteriormente, los tipos derivados tenían que marcarse con el atributo <xref:System.Security.SecurityCriticalAttribute>. Sin embargo, este cambio no debería tener ningún impacto.|  
|Tipos y miembros de WF 3.0|Los tipos y miembros de WF 3.0 ahora están marcados como obsoletos.|Si intenta compilar un código fuente que utilice tipos o miembros de WF 3.0, se generará un error del compilador. Debe usar los tipos y miembros de WF 4 en los espacios de nombres <xref:System.Activities>.|  
|Clase <xref:System.Activities.Presentation.DragDropHelper?displayProperty=fullName>|La clase <xref:System.Activities.Presentation.DragDropHelper> incluye nuevos métodos que admiten operaciones de arrastrar y colocar con varios objetos. Los métodos de arrastrar y colocar existentes que permiten arrastrar un solo objeto están obsoletos. \(Para obtener más información, vea [Lo obsoleto en la biblioteca de clases](../../../docs/framework/whats-new/whats-obsolete.md)\).|Aunque se hayan dejado de usar los métodos antiguos, se siguen admitiendo en el compilador y en Common Language Runtime. Sin embargo, los nuevos métodos proporcionan mayor funcionalidad. Los cambios recomendados para algunos de los métodos existentes son los siguientes:<br /><br /> Use <xref:System.Activities.Presentation.DragDropHelper.DoDragMove%28System.Activities.Presentation.WorkflowViewElement%2CSystem.Windows.Point%29?displayProperty=fullName> en lugar de <xref:System.Activities.Presentation.DragDropHelper.DoDragMove%28System.Activities.Presentation.WorkflowViewElement%2CSystem.Windows.Point%29?displayProperty=fullName>.<br /><br /> Use <xref:System.Activities.Presentation.DragDropHelper.GetCompositeView%28System.Activities.Presentation.WorkflowViewElement%29> en lugar de <xref:System.Activities.Presentation.DragDropHelper.GetCompositeView%28System.Windows.DragEventArgs%29>.<br /><br /> Use <xref:System.Activities.Presentation.DragDropHelper.GetDraggedModelItems%28System.Windows.DragEventArgs%29> en lugar de <xref:System.Activities.Presentation.DragDropHelper.GetDraggedModelItem%28System.Windows.DragEventArgs%29>.<br /><br /> Use <xref:System.Activities.Presentation.DragDropHelper.GetDroppedObjects%28System.Windows.DependencyObject%2CSystem.Windows.DragEventArgs%2CSystem.Activities.Presentation.EditingContext%29> en lugar de <xref:System.Activities.Presentation.DragDropHelper.GetDroppedObject%28System.Windows.DependencyObject%2CSystem.Windows.DragEventArgs%2CSystem.Activities.Presentation.EditingContext%29>.|  
|Resolución de sobrecargas de llamadas al método <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=fullName>|[!INCLUDE[net_v45](../../../includes/net-v45-md.md)] agrega nuevas sobrecargas que incluyen un parámetro de tipo <xref:System.Action?displayProperty=fullName>. Cuando el código existente se vuelve a compilar, los compiladores pueden resolver llamadas a métodos <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=fullName> que tienen un parámetro <xref:System.Delegate> como llamadas a métodos <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=fullName> con un parámetro <xref:System.Action?displayProperty=fullName>.|Si una llamada a una sobrecarga <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=fullName> con un parámetro <xref:System.Delegate> se resuelve como una llamada a una sobrecarga <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=fullName> con un parámetro <xref:System.Action?displayProperty=fullName>, pueden producirse las siguientes diferencias de comportamiento:<br /><br /> Si se produce una excepción, no se inician los eventos <xref:System.Windows.Threading.Dispatcher.UnhandledExceptionFilter?displayProperty=fullName> y <xref:System.Windows.Threading.Dispatcher.UnhandledException?displayProperty=fullName>. En su lugar, las excepciones se controlan mediante el evento <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException>.<br /><br /> Las llamadas a algunos miembros, como <xref:System.Windows.Threading.DispatcherOperation.Result%2A?displayProperty=fullName>, se bloquean hasta que se completa la operación.|  
|Clase <xref:System.Activities.Expressions.Literal%601?displayProperty=fullName>|El objeto <xref:System.Windows.Markup.ValueSerializer> asociado convertirá un objeto <xref:System.DateTime> o <xref:System.DateTimeOffset> cuyos componentes `Second` y `Millisecond` sean distintos de cero y \(para un valor <xref:System.DateTime>\) cuya propiedad <xref:System.DateTime.Kind%2A?displayProperty=fullName> no sea <xref:System.DateTimeKind> a la sintaxis del elemento de propiedad en lugar de a una cadena.|Este cambio permite realizar un recorrido de ida y vuelta por los valores <xref:System.DateTime> y <xref:System.DateTimeOffset>. Los analizadores XAML personalizados que presuponen que la entrada XAML está en la sintaxis del atributo no funcionarán correctamente.|  
  
<a name="xml"></a>   
## XML, XSLT  
  
|Característica|Cambio|Impacto|  
|--------------------|------------|-------------|  
|Método `XDocument.Validate`|Si el valor de <xref:System.Xml.Linq.LoadOptions?displayProperty=fullName> se pasa al método <xref:System.Xml.Linq.XDocument.Load%2A> y se produce un error de validación, las propiedades <xref:System.Xml.Schema.XmlSchemaException.LineNumber%2A?displayProperty=fullName> y <xref:System.Xml.Schema.XmlSchemaException.LinePosition%2A?displayProperty=fullName> contendrán ahora la información de línea.|El código de control de excepciones que depende de los valores de las propiedades <xref:System.Xml.Schema.XmlSchemaException.LineNumber%2A?displayProperty=fullName> y <xref:System.Xml.Schema.XmlSchemaException.LinePosition%2A?displayProperty=fullName> ya no funcionará.|  
|Carga de archivos XML con <xref:System.Xml.XmlTextReader?displayProperty=fullName>|La expansión de entidades DTD está limitada a 10.000.000 caracteres.|La carga de archivos XML sin expansión de entidades DTD o con expansión de entidades DTD limitada no se verá afectada. Los archivos con entidades de DTD que se expanden a más de 10.000.000 caracteres no se podrán cargar y ahora iniciarán una excepción.|  
|Modo de compatibilidad con versiones posteriores de la clase <xref:System.Xml.Xsl.XslCompiledTransform?displayProperty=fullName>|En [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], la compatibilidad con versiones posteriores de XSLT 1.0 presentaba los siguientes problemas:<br /><br /> La carga de una hoja de estilos no se realizaba correctamente si su versión estaba establecida en 2.0 y el analizador encontraba una construcción de XSLT 1.0 desconocida.<br /><br /> La construcción `xsl:sort` no podía ordenar los datos si la versión de la hoja de estilos estaba establecida en 1.1.<br /><br /> En [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], se han corregido estos problemas y el modo de compatibilidad con versiones posteriores de XSLT 1.0 funciona correctamente.|El modo de compatibilidad con versiones posteriores de XSLT 1.0 ahora funciona como antes.|  
|Mensajes de excepción cuando un archivo XSLT es demasiado complejo|En [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], el texto del mensaje de error cuando un archivo XSLT es demasiado complejo es “La hoja de estilos es demasiado compleja”. En versiones anteriores, el mensaje de error era “Error de compilación de XSLT”.|El código de aplicación que se base en el texto del mensaje de error ya no funcionará. Sin embargo, los tipos de excepción siguen siendo iguales, por lo que este cambio no debería tener un verdadero impacto.|  
|Validación del esquema XML para xsd:anyURI|En [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], la validación del esquema XML es más estricta. Si usa xsd:anyURI para validar un identificador URI, como un protocolo mailto, la validación producirá un error si hay espacios en el URI. En versiones anteriores de .NET Framework, la validación se realizaba correctamente.|El cambio solo afecta a las aplicaciones que tienen como destino [!INCLUDE[net_v45](../../../includes/net-v45-md.md)].|  
  
## Vea también  
 [Lo obsoleto en la biblioteca de clases](../../../docs/framework/whats-new/whats-obsolete.md)   
 [Novedades](../../../docs/framework/whats-new/index.md)   
 [Compatibilidad de aplicaciones](../../../docs/framework/migration-guide/application-compatibility.md)   
 [Compatibilidad de aplicaciones en 4.5.1](../../../docs/framework/migration-guide/application-compatibility-in-the-net-framework-4-5-1.md)   
 [Compatibilidad de aplicaciones en 4.5.2](../../../docs/framework/migration-guide/application-compatibility-in-the-net-framework-4-5-2.md)