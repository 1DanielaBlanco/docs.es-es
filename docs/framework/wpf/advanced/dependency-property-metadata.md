---
title: "Metadatos de las propiedades de dependencia | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net-framework"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-wpf"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "API, metadatos"
  - "propiedades de dependencia, metadatos"
  - "metadatos, para propiedades de dependencia"
  - "invalidar metadatos"
ms.assetid: d01ed009-b722-41bf-b82f-fe1a8cdc50dd
caps.latest.revision: 24
author: "dotnet-bot"
ms.author: "dotnetcontent"
manager: "wpickett"
caps.handback.revision: 23
---
# Metadatos de las propiedades de dependencia
El sistema de propiedades de [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] incluye un sistema de informe de metadatos que va más allá de lo que se puede informar de una propiedad mediante reflexión o características generales de [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)].  Los metadatos para una [propiedad de dependencia](GTMT) pueden asignarse también de forma única mediante la clase que define una [propiedad de dependencia](GTMT), pueden modificarse cuando la [propiedad de dependencia](GTMT) se agrega a una clase diferente y pueden ser invalidados específicamente por todas las clases derivadas que hereden la [propiedad de dependencia](GTMT) de la clase base de la definición.  
  
   
  
<a name="prerequisites"></a>   
## Requisitos previos  
 En este tema se asume que entiende las propiedades de dependencia desde la perspectiva de un consumidor de las propiedades de dependencia existentes en las clases de [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] y que ha leído el tema [Información general sobre las propiedades de dependencia](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md).  Para seguir los ejemplos de este tema, también debe entender [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] y debe saber escribir aplicaciones de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  
  
<a name="dp_metadata_contents"></a>   
## Cómo se utilizan los metadatos de propiedades de dependencia  
 Los metadatos de propiedad de dependencia existen como un objeto que se puede consultar para examinar las características de una propiedad de dependencia.  El sistema de propiedades tiene acceso también con frecuencia a estos metadatos cuando procesa cualquier propiedad de dependencia determinada.  El objeto de metadatos para una propiedad de dependencia puede contener los tipos siguientes de información:  
  
-   Valor predeterminado para la propiedad de dependencia, si no se puede determinar ningún otro valor para la propiedad de dependencia por valor local, estilo, herencia, etc.  Para ver una explicación en profundidad de cómo los valores predeterminados participan en la prioridad utilizada por el sistema de propiedades al asignar valores para las propiedades de dependencia, vea [Prioridad de los valores de propiedades de dependencia](../../../../docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
-   Referencias a las implementaciones de devolución de llamada que afectan a comportamientos de coerción o notificación de cambios propietario por propietario.  Tenga en cuenta que estas devoluciones de llamada se definen a menudo con un nivel de acceso no público, así que en general no es posible obtener las referencias reales de los metadatos a menos que estén dentro el ámbito de acceso permitido.  Para obtener más información acerca de las devoluciones de llamada de propiedad, vea [Devoluciones de llamada y validación de las propiedades de dependencia](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
-   Si la propiedad de dependencia en cuestión se considera una propiedad del [nivel de marco de trabajo de WPF](GTMT), los metadatos pueden contener características de propiedad del [nivel de marco de trabajo de WPF](GTMT), que proporcionan información e indican el estado de servicios tales como el motor de diseño del [nivel de marco de trabajo de WPF](GTMT) y la lógica de herencia de propiedad.  Para obtener más información sobre este aspecto de los metadatos de propiedad de dependencia, vea [Metadatos de las propiedades de marco de trabajo](../../../../docs/framework/wpf/advanced/framework-property-metadata.md).  
  
<a name="APIs"></a>   
## API de metadatos  
 El tipo que informa de la mayor parte de la información de los metadatos utilizados por el sistema de propiedad es la clase <xref:System.Windows.PropertyMetadata>.  Las instancias de metadatos se especifican opcionalmente cuando se registran propiedades de dependencia con el sistema de propiedades y pueden especificarse de nuevo para tipos adicionales que se agregan a sí mismos como propietarios o invalidan los metadatos que heredan de la definición de propiedad de dependencia de la clase base.  \(Para los casos donde un registro de propiedad no especifica metadatos, se crea un objeto <xref:System.Windows.PropertyMetadata> predeterminado con valores predeterminados para esa clase.\) Los metadatos registrados se devuelven como <xref:System.Windows.PropertyMetadata> al llamar a las diversas sobrecargas de <xref:System.Windows.DependencyProperty.GetMetadata%2A> que obtienen metadatos de una propiedad de dependencia de una instancia de <xref:System.Windows.DependencyObject>.  
  
 Entonces se deriva la clase <xref:System.Windows.PropertyMetadata> para proporcionar metadatos más concretos para divisiones arquitectónicas tales como las clases de [nivel de marco de trabajo de WPF](GTMT).  <xref:System.Windows.UIPropertyMetadata> agrega informe de animación y <xref:System.Windows.FrameworkPropertyMetadata> proporciona las propiedades de [nivel de marco de trabajo de WPF](GTMT) mencionadas en la sección anterior.  Cuando se registra propiedades de dependencia, se puede registrarlas con estas clases derivadas de <xref:System.Windows.PropertyMetadata>.  Cuando se examina los metadatos, el tipo <xref:System.Windows.PropertyMetadata> base se puede convertir en las clases derivadas para poder examinar las propiedades más concretas.  
  
> [!NOTE]
>  Las características de propiedad que se pueden especificar en <xref:System.Windows.FrameworkPropertyMetadata> se citan a veces en esta documentación como "marcadores".  Al crear nuevas instancias de metadatos para su uso en registros de propiedad de dependencia o invalidaciones de metadatos, debe especificar estos valores mediante la enumeración basada en marcadores <xref:System.Windows.FrameworkPropertyMetadataOptions> y, a continuación, proporcionar valores de la enumeración posiblemente concatenados al constructor <xref:System.Windows.FrameworkPropertyMetadata>.  Sin embargo, una vez construidas, estas características de opción se exponen dentro de un objeto <xref:System.Windows.FrameworkPropertyMetadata> como una serie de propiedades booleanas en lugar del valor de enumeración de construcción.  Las propiedades booleanas permiten comprobar cada condicional, en lugar de exigir que se aplique una máscara a un valor de enumeración basado en marcas para obtener la información de interés.  El constructor utiliza la enumeración <xref:System.Windows.FrameworkPropertyMetadataOptions> concatenada para mantener la longitud de la firma del constructor dentro de lo razonable, mientras que los metadatos construidos reales exponen las propiedades discretas para hacer que la consulta de los metadatos sea más intuitiva.  
  
<a name="override_or_subclass"></a>   
## Cuándo invalidar metadatos, cuándo derivar una clase  
 El sistema de propiedades de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] ha establecido funciones para modificar algunas características de las propiedades de dependencia sin necesidad de implementarlas de nuevo por completo.  Esto se logra construyendo una instancia diferente de los metadatos de propiedad para la propiedad de dependencia tal como existe en un tipo determinado.  Tenga en cuenta que la mayoría de las propiedades de dependencia existentes no son propiedades virtuales así que, en rigor, su "reimplementación" en clases heredadas solamente podría lograrse sombreando el miembro existente.  
  
 Si el escenario que está intentando habilitar para una propiedad de dependencia en un tipo no se puede lograr modificando características de propiedades de dependencia existentes, puede que sea necesario crear una clase derivada y, a continuación, declarar una propiedad de dependencia personalizada en la clase derivada.  Una propiedad de dependencia personalizada se comporta de forma idéntica a las propiedades de dependencia definidas por las [!INCLUDE[TLA#tla_api#plural](../../../../includes/tlasharptla-apisharpplural-md.md)] de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].  Para obtener información más detallada sobre las propiedades de dependencia personalizadas, vea [Propiedades de dependencia personalizadas](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
 Una característica notable de una propiedad de dependencia que no se puede invalidar es su tipo de valor.  Si está heredando una propiedad de dependencia que tiene el comportamiento aproximado que necesita, pero necesita que tenga un tipo diferente, tendrá que implementar una propiedad de dependencia personalizada y, quizá, vincular las propiedades mediante conversión de tipos u otra implementación en la clase personalizada.  Además, no es posible invalidar un objeto <xref:System.Windows.ValidateValueCallback>existente, porque esta devolución de llamada existe en el propio campo de registro y no dentro de sus metadatos.  
  
<a name="scenarios"></a>   
## Escenarios para modificar metadatos existentes  
 Si está trabajando con metadatos de una propiedad de dependencia existente, un escenario común para modificar metadatos de propiedades de dependencia consiste en modificar el valor predeterminado.  Cambiar o agregar devoluciones de llamada del sistema de propiedades es un escenario más avanzado.  Quizá desee hacerlo si la implementación de una clase derivada tiene diferentes interrelaciones entre propiedades de dependencia.  Uno de los condicionantes de tener un modelo de programación que admita tanto código como el uso declarativo es que las propiedades deben poder establecerse en cualquier orden.  En consecuencia, las propiedades dependientes deben establecerse en el momento, sin contexto, y no pueden apoyarse en el conocimiento de un orden de configuración, tal como el que podría encontrarse en un constructor.  Para obtener más información sobre este aspecto del sistema de propiedades, vea [Devoluciones de llamada y validación de las propiedades de dependencia](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  Observe que las devoluciones de llamada de la validación no forman parte de los metadatos; forman parte del identificador de propiedad de dependencia.  Por consiguiente, las devoluciones de llamada de validación no se pueden modificar reemplazando metadatos.  
  
 En algunos casos, quizá desee también modificar las opciones de metadatos de propiedad del [nivel de marco de trabajo de WPF](GTMT) en propiedades de dependencia existentes.  Estas opciones comunican ciertos condicionales conocidos sobre propiedades del [nivel de marco de trabajo de WPF](GTMT) a otros procesos del [nivel de marco de trabajo de WPF](GTMT) tales como el sistema de diseño.  La configuración de opciones, en general, solamente se hace cuando se registra una nueva propiedad de dependencia, pero también es posible cambiar los metadatos de la propiedad de [nivel de marco de trabajo de WPF](GTMT) como parte de una llamada a <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> o a <xref:System.Windows.DependencyProperty.AddOwner%2A>.  Para ver los valores específicos a utilizar y más información, vea [Metadatos de las propiedades de marco de trabajo](../../../../docs/framework/wpf/advanced/framework-property-metadata.md).  Para obtener más información relativa a cómo deben establecerse estas opciones para una propiedad de dependencia recién registrada, vea [Propiedades de dependencia personalizadas](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
<a name="dp_override_metadata"></a>   
### Invalidar metadatos  
 El propósito de invalidar metadatos es, principalmente, ofrecer la oportunidad de modificar los diversos comportamientos derivados de metadatos que se aplican a la propiedad de dependencia tal como existe en el tipo.  Las razones para ello se explican con más detalle en la sección [Metadatos](#dp_metadata_contents).  Para obtener más información, incluidos algunos ejemplos de código, vea [Invalidar metadatos en una propiedad de dependencia](../../../../docs/framework/wpf/advanced/how-to-override-metadata-for-a-dependency-property.md).  
  
 Los metadatos de propiedad se pueden proporcionar para una propiedad de dependencia durante la llamada de registro \(<xref:System.Windows.DependencyProperty.Register%2A>\).  Sin embargo, en muchos casos, quizá desee proporcionar metadatos específicos del tipo para la clase cuando herede esa propiedad de dependencia.  Puede hacerlo llamando al método <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>.  Para ver un ejemplo de las [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], la clase <xref:System.Windows.FrameworkElement> es el tipo que registra en primer lugar la propiedad de dependencia <xref:System.Windows.UIElement.Focusable%2A>.  Sin embargo, la clase <xref:System.Windows.Controls.Control> reemplaza los metadatos para la propiedad de dependencia, para proporcionar su propio valor predeterminado inicial, cambiándolo de `false` a `true`; por lo demás, reutiliza la implementación original de <xref:System.Windows.UIElement.Focusable%2A>.  
  
 Cuando se reemplazan metadatos, las distintas características de los metadatos se combinan o se reemplazan.  
  
-   <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> se combina.  Si agrega una nueva <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>, esa devolución de llamada se almacena en los metadatos.  Si no especifica una <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> en la invalidación, el valor de <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> se promueve como una referencia del antecesor más próximo que lo especifique en los metadatos.  
  
-   El comportamiento real del sistema de propiedades para <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> es que las implementaciones correspondientes a todos los propietarios de metadatos de la jerarquía se retienen y se agregan a una tabla, de tal forma que el orden de ejecución en el sistema de propiedades consiste en invocar primero las devoluciones de llamada de la clase más derivada.  
  
-   Se reemplaza <xref:System.Windows.PropertyMetadata.DefaultValue%2A>.  Si no especifica una <xref:System.Windows.PropertyMetadata.DefaultValue%2A> en la invalidación, el valor de <xref:System.Windows.PropertyMetadata.DefaultValue%2A> procede del antecesor más próximo que lo especifique en los metadatos.  
  
-   Se reemplazan las implementaciones de <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>.  Si agrega una nueva <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>, esa devolución de llamada se almacena en los metadatos.  Si no especifica una <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> en la invalidación, el valor de <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> se promueve como una referencia del antecesor más próximo que lo especifique en los metadatos.  
  
-   El comportamiento del sistema de propiedades consiste en invocar únicamente la <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> de los metadatos inmediatos.  Se retiene ninguna referencia a otras implementaciones de <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> en la jerarquía.  
  
 Este comportamiento se implementa mediante <xref:System.Windows.PropertyMetadata.Merge%2A> y se puede invalidar en las clases de metadatos derivadas.  
  
#### Invalidar metadatos de propiedades asociadas  
 En [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], las [propiedades asociadas](GTMT) se implementan como propiedades de dependencia.  Esto significa que también tienen metadatos de propiedad, que las clases individuales pueden invalidar.  Las consideraciones de ámbito para una propiedad asociada en [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] son generalmente que cualquier objeto <xref:System.Windows.DependencyObject> puede tener una propiedad asociada establecida.  Por consiguiente, cualquier clase derivada de <xref:System.Windows.DependencyObject> puede invalidar los metadatos de cualquier propiedad asociada, pues podrían establecerse en una instancia de la clase.  Puede invalidar valores predeterminados, devoluciones de llamada o propiedades de informe de características de [nivel de marco de trabajo de WPF](GTMT).  Si la propiedad asociada se establece en una instancia de la clase, se aplicarán las características de los metadatos de la propiedad de reemplazo.  Por ejemplo, puede invalidar el valor predeterminado, de modo que se informe del valor de invalidación como valor de la propiedad asociada en las instancias de la clase, siempre que la propiedad no se establezca de otra manera.  
  
> [!NOTE]
>  La propiedad <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> no es relevante para propiedades asociadas.  
  
<a name="dp_add_owner"></a>   
### Agregar una clase como propietaria de una propiedad de dependencia existente  
 Una clase se puede agregar a sí misma como propietaria de una propiedad de dependencia que ya se haya registrado, utilizando el método <xref:System.Windows.DependencyProperty.AddOwner%2A>.  Esto permite que la clase utilice una propiedad de dependencia registrada originalmente para un tipo diferente.  La clase que se agrega no es, normalmente, una clase derivada del tipo que registró como propietario esa propiedad en primer lugar.  En la práctica, esto permite que la clase y sus clases derivadas "hereden" una implementación de la [propiedad de dependencia](GTMT) sin que la clase propietaria original y la clase que se agrega estén en la misma jerarquía de clases real.  Además, la clase que se agrega \(y todas las clases derivadas también\) pueden proporcionar metadatos específicos del tipo de propiedad para la propiedad de dependencia original.  
  
 Además de agregarse a sí misma como propietaria mediante los métodos accesorios del sistema de propiedades, la clase que se agrega debe declarar miembros públicos adicionales en sí misma para convertir la [propiedad de dependencia](GTMT) en un participante completo en el sistema de propiedades, con exposición tanto a código como a marcado.  Una clase que agrega una propiedad de dependencia existente tiene las mismas responsabilidades en cuanto a la exposición del modelo de objetos para esa propiedad de dependencia como una clase que defina una nueva propiedad de dependencia personalizada.  El primer miembro que se debe exponer es un campo identificador de la propiedad de dependencia.  Este campo debe ser un campo `public static readonly` de tipo <xref:System.Windows.DependencyProperty>, que esté asignado al valor que devuelve la llamada a <xref:System.Windows.DependencyProperty.AddOwner%2A>.  El segundo miembro a definir es la propiedad "contenedora" de [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)].  El contenedor hace que sea mucho más cómo manipular la propiedad de dependencia en el código \(evita llamar cada vez a <xref:System.Windows.DependencyObject.SetValue%2A> realizando esa llamada una sola vez en el propio contenedor\).  El contenedor se implementa de forma idéntica a cómo se implementaría si se estuviera registrando una [propiedad de dependencia](GTMT) personalizada.  Para obtener más información sobre cómo implementar una [propiedad de dependencia](GTMT), vea [Propiedades de dependencia personalizadas](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md) y [Agregar un tipo de propietario para una propiedad de dependencia](../../../../docs/framework/wpf/advanced/how-to-add-an-owner-type-for-a-dependency-property.md).  
  
#### AddOwner y propiedades asociadas  
 Puede llamar a <xref:System.Windows.DependencyProperty.AddOwner%2A> para una propiedad de dependencia que la clase propietaria defina como propiedad asociada.  Generalmente, la razón para hacerlo es exponer la propiedad previamente asociada como una propiedad de dependencia no asociada.  A continuación expondrá el valor devuelto por <xref:System.Windows.DependencyProperty.AddOwner%2A> como un campo `public static readonly` para su uso como identificador de la propiedad de dependencia y definirá las propiedades "contenedoras" adecuadas para que la propiedad aparezca en la tabla de miembros y admita un uso de propiedad no asociado en la clase.  
  
## Vea también  
 <xref:System.Windows.PropertyMetadata>   
 <xref:System.Windows.DependencyObject>   
 <xref:System.Windows.DependencyProperty>   
 <xref:System.Windows.DependencyProperty.GetMetadata%2A>   
 [Información general sobre las propiedades de dependencia](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)   
 [Metadatos de las propiedades de marco de trabajo](../../../../docs/framework/wpf/advanced/framework-property-metadata.md)