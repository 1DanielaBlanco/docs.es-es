---
title: Compartir bucles de mensajes entre Win32 y WPF
ms.date: 03/30/2017
helpviewer_keywords:
- Win32 code [WPF], sharing message loops
- message loops [WPF]
- sharing message loops [WPF]
- interoperability [WPF], Win32
ms.assetid: 39ee888c-e5ec-41c8-b11f-7b851a554442
ms.openlocfilehash: 35a908cc26e6b70c9acd8732521837f2b20eaf5b
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 05/04/2018
ms.locfileid: "33548820"
---
# <a name="sharing-message-loops-between-win32-and-wpf"></a><span data-ttu-id="93825-102">Compartir bucles de mensajes entre Win32 y WPF</span><span class="sxs-lookup"><span data-stu-id="93825-102">Sharing Message Loops Between Win32 and WPF</span></span>
<span data-ttu-id="93825-103">Este tema describe cómo implementar un bucle de mensajes para la interoperación con [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], ya sea mediante existente mensaje exposición de bucle en <xref:System.Windows.Threading.Dispatcher> o mediante la creación de un bucle de mensajes independiente en el [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] lado de su código de interoperación.</span><span class="sxs-lookup"><span data-stu-id="93825-103">This topic describes how to implement a message loop for interoperation with [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], either by using existing message loop exposure in <xref:System.Windows.Threading.Dispatcher> or by creating a separate message loop on the [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] side of your interoperation code.</span></span>  
  
## <a name="componentdispatcher-and-the-message-loop"></a><span data-ttu-id="93825-104">ComponentDispatcher y el bucle de mensajes</span><span class="sxs-lookup"><span data-stu-id="93825-104">ComponentDispatcher and the Message Loop</span></span>  
 <span data-ttu-id="93825-105">Un escenario normal para la compatibilidad con eventos de interoperación y teclado consiste en implementar <xref:System.Windows.Interop.IKeyboardInputSink>, o para crear subclases de clases que ya implementan <xref:System.Windows.Interop.IKeyboardInputSink>, como <xref:System.Windows.Interop.HwndSource> o <xref:System.Windows.Interop.HwndHost>.</span><span class="sxs-lookup"><span data-stu-id="93825-105">A normal scenario for interoperation and keyboard event support is to implement <xref:System.Windows.Interop.IKeyboardInputSink>, or to subclass from classes that already implement <xref:System.Windows.Interop.IKeyboardInputSink>, such as <xref:System.Windows.Interop.HwndSource> or <xref:System.Windows.Interop.HwndHost>.</span></span> <span data-ttu-id="93825-106">Sin embargo, la compatibilidad con el receptor de teclado no abordar las necesidades de bucle de mensajes posibles que tenga al enviar y recibir mensajes a través de los límites de interoperación.</span><span class="sxs-lookup"><span data-stu-id="93825-106">However, keyboard sink support does not address all possible message loop needs you might have when sending and receiving messages across your interoperation boundaries.</span></span> <span data-ttu-id="93825-107">Para ayudar a formalizar una arquitectura de bucle de mensajes de aplicación, [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] proporciona el <xref:System.Windows.Interop.ComponentDispatcher> (clase), que define un protocolo simple de un bucle de mensajes debe seguir.</span><span class="sxs-lookup"><span data-stu-id="93825-107">To help formalize an application message loop architecture, [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] provides the <xref:System.Windows.Interop.ComponentDispatcher> class, which defines a simple protocol for a message loop to follow.</span></span>  
  
 <span data-ttu-id="93825-108"><xref:System.Windows.Interop.ComponentDispatcher> es una clase estática que expone a varios miembros.</span><span class="sxs-lookup"><span data-stu-id="93825-108"><xref:System.Windows.Interop.ComponentDispatcher> is a static class that exposes several members.</span></span> <span data-ttu-id="93825-109">El ámbito de cada método implícitamente está asociado al subproceso que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="93825-109">The scope of each method is implicitly tied to the calling thread.</span></span> <span data-ttu-id="93825-110">Un bucle de mensajes debe llamar a algunas de ellas [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] en los momentos críticos (según se define en la sección siguiente).</span><span class="sxs-lookup"><span data-stu-id="93825-110">A message loop must call some of those [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] at critical times (as defined in the next section).</span></span>  
  
 <span data-ttu-id="93825-111"><xref:System.Windows.Interop.ComponentDispatcher> Proporciona eventos que pueden escuchar otros componentes (por ejemplo, el receptor de teclado).</span><span class="sxs-lookup"><span data-stu-id="93825-111"><xref:System.Windows.Interop.ComponentDispatcher> provides events that other components (such as the keyboard sink) can listen for.</span></span> <span data-ttu-id="93825-112">El <xref:System.Windows.Threading.Dispatcher> llamadas todos los controles de la clase <xref:System.Windows.Interop.ComponentDispatcher> métodos en un orden adecuado.</span><span class="sxs-lookup"><span data-stu-id="93825-112">The <xref:System.Windows.Threading.Dispatcher> class calls all the appropriate <xref:System.Windows.Interop.ComponentDispatcher> methods in an appropriate sequence.</span></span> <span data-ttu-id="93825-113">Si implementa su propio bucle de mensajes, el código es responsable de llamar a <xref:System.Windows.Interop.ComponentDispatcher> métodos de una manera similar.</span><span class="sxs-lookup"><span data-stu-id="93825-113">If you are implementing your own message loop, your code is responsible for calling <xref:System.Windows.Interop.ComponentDispatcher> methods in a similar fashion.</span></span>  
  
 <span data-ttu-id="93825-114">Al llamar a <xref:System.Windows.Interop.ComponentDispatcher> métodos en un subproceso, sólo se invocarán los controladores de eventos que se registraron en ese subproceso.</span><span class="sxs-lookup"><span data-stu-id="93825-114">Calling <xref:System.Windows.Interop.ComponentDispatcher> methods on a thread will only invoke event handlers that were registered on that thread.</span></span>  
  
## <a name="writing-message-loops"></a><span data-ttu-id="93825-115">Escribir bucles de mensajes</span><span class="sxs-lookup"><span data-stu-id="93825-115">Writing Message Loops</span></span>  
 <span data-ttu-id="93825-116">La siguiente es una lista de comprobación de <xref:System.Windows.Interop.ComponentDispatcher> los miembros que se va a usar si escribe su propio bucle de mensajes:</span><span class="sxs-lookup"><span data-stu-id="93825-116">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you write your own message loop:</span></span>  
  
-   <span data-ttu-id="93825-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>: el bucle de mensajes debe llamar a este método para indicar que el subproceso es modal.</span><span class="sxs-lookup"><span data-stu-id="93825-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>: your message loop should call this to indicate that the thread is modal.</span></span>  
  
-   <span data-ttu-id="93825-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>: el bucle de mensajes debe llamar a este método para indicar que el subproceso ha dejado de ser modal.</span><span class="sxs-lookup"><span data-stu-id="93825-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>:your message loop should call this to indicate that the thread has reverted to nonmodal.</span></span>  
  
-   <span data-ttu-id="93825-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>: el bucle de mensajes debe llamar a este método para indicar que <xref:System.Windows.Interop.ComponentDispatcher> debería desencadenar el <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> eventos.</span><span class="sxs-lookup"><span data-stu-id="93825-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>: your message loop should call this to indicate that <xref:System.Windows.Interop.ComponentDispatcher> should raise the <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> event.</span></span> <span data-ttu-id="93825-120"><xref:System.Windows.Interop.ComponentDispatcher> no se producirá <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> si <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> es `true`, pero pueden elegir bucles de mensajes llamar a <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> incluso si <xref:System.Windows.Interop.ComponentDispatcher> no puede responder a él mientras está en estado modal.</span><span class="sxs-lookup"><span data-stu-id="93825-120"><xref:System.Windows.Interop.ComponentDispatcher> will not raise <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> if <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> is `true`, but message loops may choose to call <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> even if <xref:System.Windows.Interop.ComponentDispatcher> cannot respond to it while in modal state.</span></span>  
  
-   <span data-ttu-id="93825-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>: el bucle de mensajes debe llamar a este método para indicar que hay un nuevo mensaje.</span><span class="sxs-lookup"><span data-stu-id="93825-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>: your message loop should call this to indicate that a new message is available.</span></span> <span data-ttu-id="93825-122">El valor devuelto indica si un agente de escucha para un <xref:System.Windows.Interop.ComponentDispatcher> controla el mensaje de evento.</span><span class="sxs-lookup"><span data-stu-id="93825-122">The return value indicates whether a listener to a <xref:System.Windows.Interop.ComponentDispatcher> event handled the message.</span></span> <span data-ttu-id="93825-123">Si <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> devuelve `true` (controlará), el distribuidor no debe hacer nada más con el mensaje.</span><span class="sxs-lookup"><span data-stu-id="93825-123">If <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> returns `true` (handled), the dispatcher should do nothing further with the message.</span></span> <span data-ttu-id="93825-124">Si el valor devuelto es `false`, el distribuidor se espera que llame el [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] función `TranslateMessage`, a continuación, llamar a `DispatchMessage`.</span><span class="sxs-lookup"><span data-stu-id="93825-124">If the return value is `false`, the dispatcher is expected to call the [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] function `TranslateMessage`, then call `DispatchMessage`.</span></span>  
  
## <a name="using-componentdispatcher-and-existing-message-handling"></a><span data-ttu-id="93825-125">Utilizar ComponentDispatcher y el control de mensajes existente</span><span class="sxs-lookup"><span data-stu-id="93825-125">Using ComponentDispatcher and Existing Message Handling</span></span>  
 <span data-ttu-id="93825-126">La siguiente es una lista de comprobación de <xref:System.Windows.Interop.ComponentDispatcher> los miembros que se va a usar si confía en el inherente [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] bucle de mensajes.</span><span class="sxs-lookup"><span data-stu-id="93825-126">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you rely on the inherent [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] message loop.</span></span>  
  
-   <span data-ttu-id="93825-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>: devuelve si la aplicación ha convertido en modal (por ejemplo, se ha insertado un bucle de mensajes modal).</span><span class="sxs-lookup"><span data-stu-id="93825-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>: returns whether the application has gone modal (e.g., a modal message loop has been pushed).</span></span> <span data-ttu-id="93825-128"><xref:System.Windows.Interop.ComponentDispatcher> puede realizar un seguimiento de este estado porque la clase mantiene un recuento de <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> y <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> llamadas desde el bucle de mensajes.</span><span class="sxs-lookup"><span data-stu-id="93825-128"><xref:System.Windows.Interop.ComponentDispatcher> can track this state because the class maintains a count of <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> and <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> calls from the message loop.</span></span>  
  
-   <span data-ttu-id="93825-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> y <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> eventos siguen las reglas estándares para las invocaciones del delegado.</span><span class="sxs-lookup"><span data-stu-id="93825-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> and <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> events follow the standard rules for delegate invocations.</span></span> <span data-ttu-id="93825-130">Los delegados se invocan en un orden no especificado y todos los delegados se invocan aun cuando la primera de ellas marca el mensaje como controlado.</span><span class="sxs-lookup"><span data-stu-id="93825-130">Delegates are invoked in an unspecified order, and all delegates are invoked even if the first one marks the message as handled.</span></span>  
  
-   <span data-ttu-id="93825-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>: indica un momento adecuado y eficaz para el procesamiento en inactividad (no hay ningún otro mensaje pendiente para el subproceso).</span><span class="sxs-lookup"><span data-stu-id="93825-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>: indicates an appropriate and efficient time to do idle processing (there are no other pending messages for the thread).</span></span> <span data-ttu-id="93825-132"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> no se generará si el subproceso es modal.</span><span class="sxs-lookup"><span data-stu-id="93825-132"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> will not be raised if the thread is modal.</span></span>  
  
-   <span data-ttu-id="93825-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>: genera para todos los mensajes que procesa el suministro de mensajes.</span><span class="sxs-lookup"><span data-stu-id="93825-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>: raised for all messages that the message pump processes.</span></span>  
  
-   <span data-ttu-id="93825-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>: genera para todos los mensajes que no se administraron durante <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>.</span><span class="sxs-lookup"><span data-stu-id="93825-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>: raised for all messages that were not handled during <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>.</span></span>  
  
 <span data-ttu-id="93825-135">Se considera un mensaje si administrado después de la <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> eventos o <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> eventos, el `handled` parámetro pasado por referencia en los datos del evento es `true`.</span><span class="sxs-lookup"><span data-stu-id="93825-135">A message is considered handled if after the <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> event or <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> event, the `handled` parameter passed by reference in event data is `true`.</span></span> <span data-ttu-id="93825-136">Controladores de eventos deben pasar por alto el mensaje si `handled` es `true`, ya que significa que el controlador distinto ha administrado el mensaje primero.</span><span class="sxs-lookup"><span data-stu-id="93825-136">Event handlers should ignore the message if `handled` is `true`, because that means the different handler handled the message first.</span></span> <span data-ttu-id="93825-137">Controladores de eventos para ambos eventos pueden modificar el mensaje.</span><span class="sxs-lookup"><span data-stu-id="93825-137">Event handlers to both events may modify the message.</span></span> <span data-ttu-id="93825-138">El distribuidor debe enviar el mensaje modificado y no en el mensaje original sin cambios.</span><span class="sxs-lookup"><span data-stu-id="93825-138">The dispatcher should dispatch the modified message and not the original unchanged message.</span></span> <span data-ttu-id="93825-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> se entrega a todos los agentes de escucha, pero la intención de la arquitectura es que sólo la ventana de nivel superior que contiene el HWND en el que los mensajes de destino deben invocar código en respuesta al mensaje.</span><span class="sxs-lookup"><span data-stu-id="93825-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is delivered to all listeners, but the architectural intention is that only the top-level window containing the HWND at which the messages targeted should invoke code in response to the message.</span></span>  
  
## <a name="how-hwndsource-treats-componentdispatcher-events"></a><span data-ttu-id="93825-140">Cómo trata HwndSource los eventos ComponentDispatcher</span><span class="sxs-lookup"><span data-stu-id="93825-140">How HwndSource Treats ComponentDispatcher Events</span></span>  
 <span data-ttu-id="93825-141">Si el <xref:System.Windows.Interop.HwndSource> es una ventana de nivel superior (ningún elemento primario HWND), registrará con <xref:System.Windows.Interop.ComponentDispatcher>.</span><span class="sxs-lookup"><span data-stu-id="93825-141">If the <xref:System.Windows.Interop.HwndSource> is a top-level window (no parent HWND), it will register with <xref:System.Windows.Interop.ComponentDispatcher>.</span></span> <span data-ttu-id="93825-142">Si <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> se genera, y si el mensaje está diseñado para la <xref:System.Windows.Interop.HwndSource> o ventanas secundarias, <xref:System.Windows.Interop.HwndSource> llamadas su <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> secuencia de receptor de teclado.</span><span class="sxs-lookup"><span data-stu-id="93825-142">If <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is raised, and if the message is intended for the <xref:System.Windows.Interop.HwndSource> or child windows, <xref:System.Windows.Interop.HwndSource> calls its <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> keyboard sink sequence.</span></span>  
  
 <span data-ttu-id="93825-143">Si el <xref:System.Windows.Interop.HwndSource> no es una ventana de nivel superior (tiene un HWND primario), no habrá ningún control.</span><span class="sxs-lookup"><span data-stu-id="93825-143">If the <xref:System.Windows.Interop.HwndSource> is not a top-level window (has a parent HWND), there will be no handling.</span></span> <span data-ttu-id="93825-144">La ventana de nivel superior se espera que haga el control y no existe, se espera que una ventana de nivel superior con compatibilidad con el teclado receptor como parte de cualquier escenario de interoperación.</span><span class="sxs-lookup"><span data-stu-id="93825-144">Only the top level window is expected to do the handling, and there is expected to be a top level window with keyboard sink support as part of any interoperation scenario.</span></span>  
  
 <span data-ttu-id="93825-145">Si <xref:System.Windows.Interop.HwndHost.WndProc%2A> en un <xref:System.Windows.Interop.HwndSource> se llama sin un método de receptor de teclado correspondiente que se llama en primer lugar, la aplicación recibirá los eventos de teclado de nivel superior como <xref:System.Windows.UIElement.KeyDown>.</span><span class="sxs-lookup"><span data-stu-id="93825-145">If <xref:System.Windows.Interop.HwndHost.WndProc%2A> on an <xref:System.Windows.Interop.HwndSource> is called without an appropriate keyboard sink method being called first, your application will receive the higher level keyboard events such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="93825-146">Sin embargo, no hay ningún método de receptor de teclado se llamará, lo que evita la características de modelo de entrada de teclado deseable como la posibilidad de clave de acceso.</span><span class="sxs-lookup"><span data-stu-id="93825-146">However, no keyboard sink methods will be called, which circumvents desirable keyboard input model features such as access key support.</span></span> <span data-ttu-id="93825-147">Esto podría deberse a que el bucle de mensajes no correctamente notificó al subproceso pertinente en el <xref:System.Windows.Interop.ComponentDispatcher>, o porque el elemento primario HWND no invocó las respuestas de receptor de teclado adecuado.</span><span class="sxs-lookup"><span data-stu-id="93825-147">This might happen because the message loop did not properly notify the relevant thread on the <xref:System.Windows.Interop.ComponentDispatcher>, or because the parent HWND did not invoke the proper keyboard sink responses.</span></span>  
  
 <span data-ttu-id="93825-148">Un mensaje que entra en el receptor de teclado podría no enviarse al HWND si se han agregado enlaces para ese mensaje utilizando el <xref:System.Windows.Interop.HwndSource.AddHook%2A> método.</span><span class="sxs-lookup"><span data-stu-id="93825-148">A message that goes to the keyboard sink might not be sent to the HWND if you added hooks for that message by using the <xref:System.Windows.Interop.HwndSource.AddHook%2A> method.</span></span> <span data-ttu-id="93825-149">El mensaje se podría haber detectado en el nivel de bombeo de mensajes directamente y no se envían a la `DispatchMessage` (función).</span><span class="sxs-lookup"><span data-stu-id="93825-149">The message might have been handled at the message pump level directly and not submitted to the `DispatchMessage` function.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="93825-150">Vea también</span><span class="sxs-lookup"><span data-stu-id="93825-150">See Also</span></span>  
 <xref:System.Windows.Interop.ComponentDispatcher>  
 <xref:System.Windows.Interop.IKeyboardInputSink>  
 [<span data-ttu-id="93825-151">Interoperabilidad de WPF y Win32</span><span class="sxs-lookup"><span data-stu-id="93825-151">WPF and Win32 Interoperation</span></span>](../../../../docs/framework/wpf/advanced/wpf-and-win32-interoperation.md)  
 [<span data-ttu-id="93825-152">Modelo de subprocesos</span><span class="sxs-lookup"><span data-stu-id="93825-152">Threading Model</span></span>](../../../../docs/framework/wpf/advanced/threading-model.md)  
 [<span data-ttu-id="93825-153">Información general sobre acciones del usuario</span><span class="sxs-lookup"><span data-stu-id="93825-153">Input Overview</span></span>](../../../../docs/framework/wpf/advanced/input-overview.md)
