---
title: "Asignación entre JSON y XML"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 22ee1f52-c708-4024-bbf0-572e0dae64af
caps.latest.revision: "10"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.openlocfilehash: 9bf104af8c88413298412d3ec3a29cd934558e2d
ms.sourcegitcommit: ce279f2d7fe2220e6ea0a25a8a7a5370ddf8d9f0
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 12/02/2017
---
# <a name="mapping-between-json-and-xml"></a><span data-ttu-id="43913-102">Asignación entre JSON y XML</span><span class="sxs-lookup"><span data-stu-id="43913-102">Mapping Between JSON and XML</span></span>
<span data-ttu-id="43913-103">Los sistemas de lectura y escritura generados por el <xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory> proporcionan una API de XML sobre contenido de notación de objetos JavaScript (JSON)</span><span class="sxs-lookup"><span data-stu-id="43913-103">The readers and writers produced by the <xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory> provide an XML API over JavaScript Object Notation (JSON) content.</span></span> <span data-ttu-id="43913-104">JSON codifica datos mediante un subconjunto de literales de objeto de JavaScript.</span><span class="sxs-lookup"><span data-stu-id="43913-104">JSON encodes data using a subset of the object literals of JavaScript.</span></span> <span data-ttu-id="43913-105">También se utilizan los sistemas de lectura y escritura producidos por este generador cuando las aplicaciones de [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] envían o reciben contenido JSON utilizando el <xref:System.ServiceModel.Channels.WebMessageEncodingBindingElement> o <xref:System.ServiceModel.WebHttpBinding>.</span><span class="sxs-lookup"><span data-stu-id="43913-105">The readers and writers produced by this factory are also used when JSON content is being sent or received by [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] applications using the <xref:System.ServiceModel.Channels.WebMessageEncodingBindingElement> or the <xref:System.ServiceModel.WebHttpBinding>.</span></span>  
  
 <span data-ttu-id="43913-106">Cuando se inicializa con contenido de JSON, el lector de JSON se comporta del mismo modo que un lector XML textual sobre una instancia de XML.</span><span class="sxs-lookup"><span data-stu-id="43913-106">When initialized with JSON content, the JSON reader behaves in the same way that a textual XML reader does over an instance of XML.</span></span> <span data-ttu-id="43913-107">El sistema de escritura de JSON, cuando se proporciona una secuencia de llamadas que en un lector XML textual genera una cierta instancia XML, escribe contenido JSON.</span><span class="sxs-lookup"><span data-stu-id="43913-107">The JSON writer, when given a sequence of calls that on a textual XML reader produces a certain XML instance, writes out JSON content.</span></span> <span data-ttu-id="43913-108">La asignación entre esta instancia de XML y el contenido de JSON se describe en este tema para su uso en escenarios avanzados.</span><span class="sxs-lookup"><span data-stu-id="43913-108">The mapping between this instance of XML and the JSON content is described in this topic for use in advanced scenarios.</span></span>  
  
 <span data-ttu-id="43913-109">Internamente, JSON se representa como un conjunto de información XML cuando [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] lo procesa.</span><span class="sxs-lookup"><span data-stu-id="43913-109">Internally, JSON is represented as an XML infoset when processed by [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)].</span></span> <span data-ttu-id="43913-110">Normalmente no tiene que preocuparse por esta representación interna, puesto que la asignación solo es una representación lógica: JSON no se convierte normalmente en XML en memoria ni se convierte a JSON a partir de XML.</span><span class="sxs-lookup"><span data-stu-id="43913-110">Normally you do not have to be concerned with this internal representation as the mapping is only a logical one: JSON is normally not physically converted to XML in memory or converted to JSON from XML.</span></span> <span data-ttu-id="43913-111">La asignación significa que API XML se utilizan para obtener acceso al contenido de JSON.</span><span class="sxs-lookup"><span data-stu-id="43913-111">The mapping means that XML APIs are used to access JSON content.</span></span>  
  
 <span data-ttu-id="43913-112">Cuando [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] utiliza JSON, el escenario habitual es que el <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> sea conectado automáticamente mediante el comportamiento <xref:System.ServiceModel.Description.WebScriptEnablingBehavior>, o, cuando sea apropiado, mediante el comportamiento <xref:System.ServiceModel.Description.WebHttpBehavior>.</span><span class="sxs-lookup"><span data-stu-id="43913-112">When [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] uses JSON, the usual scenario is that the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> is automatically plugged in by the <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> behavior, or by the <xref:System.ServiceModel.Description.WebHttpBehavior> behavior when appropriate.</span></span> <span data-ttu-id="43913-113"><xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> entiende la asignación entre JSON y los conjuntos de información XML y actúa como si tratase directamente con JSON.</span><span class="sxs-lookup"><span data-stu-id="43913-113">The <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> understands the mapping between JSON and the XML infoset and acts as if it is dealing with JSON directly.</span></span> <span data-ttu-id="43913-114">(Es posible utilizar el <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> con cualquier sistema de lectura o escritura XML, siempre que se comprenda que el XML cumple la asignación siguiente).</span><span class="sxs-lookup"><span data-stu-id="43913-114">(It is possible to use the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> with any XML reader or writer, with the understanding that the XML conforms to the following mapping.)</span></span>  
  
 <span data-ttu-id="43913-115">En escenarios avanzados, puede volverse necesario tener acceso directamente a la siguiente asignación.</span><span class="sxs-lookup"><span data-stu-id="43913-115">In advanced scenarios, it may become necessary to directly access the following mapping.</span></span> <span data-ttu-id="43913-116">Estos escenarios se producen cuando desea serializar y deserializar JSON de maneras personalizadas, sin basarse en el <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>, o cuando se trata directamente con el tipo <xref:System.ServiceModel.Channels.Message> para mensajes que contienen JSON.</span><span class="sxs-lookup"><span data-stu-id="43913-116">These scenarios occur when you want to serialize and deserialize JSON in custom ways, without relying on the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>, or when dealing with the <xref:System.ServiceModel.Channels.Message> type directly for messages containing JSON.</span></span> <span data-ttu-id="43913-117">La asignación JSON-XML también se utiliza para el registro de mensajes.</span><span class="sxs-lookup"><span data-stu-id="43913-117">The JSON-XML mapping is also used for message logging.</span></span> <span data-ttu-id="43913-118">Al utilizar la característica de registro de mensajes en [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], los mensajes de JSON se registran como XML de acuerdo con la asignación descrita en la siguiente sección.</span><span class="sxs-lookup"><span data-stu-id="43913-118">When using the message logging feature in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], JSON messages is logged as XML according to the mapping described in the next section.</span></span>  
  
 <span data-ttu-id="43913-119">Para aclarar el concepto de asignación, se proporciona el siguiente ejemplo, que procede de un documento JSON.</span><span class="sxs-lookup"><span data-stu-id="43913-119">To clarify the concept of a mapping, the following example is of a JSON document.</span></span>  
  
```json  
{"product":"pencil","price":12}  
```  
  
 <span data-ttu-id="43913-120">Para leer este documento JSON mediante uno de los lectores previamente mencionados, utilice la misma secuencia de llamadas a <xref:System.Xml.XmlDictionaryReader> que utilizaría para leer el siguiente documento XML.</span><span class="sxs-lookup"><span data-stu-id="43913-120">To read this JSON document using one of the readers previously mentioned, use the same sequence of <xref:System.Xml.XmlDictionaryReader> calls as you would to read the following XML document.</span></span>  
  
```xml  
<root type="object">  
    <product type="string">pencil</product>  
    <price type="number">12</price>  
</root>  
```  
  
 <span data-ttu-id="43913-121">Es más, si [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] recibe el mensaje de JSON del ejemplo y lo registra, vería el fragmento XML en el registro anterior.</span><span class="sxs-lookup"><span data-stu-id="43913-121">Furthermore, if the JSON message in the example is received by [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] and logged, you would see the XML fragment in the preceding log.</span></span>  
  
## <a name="mapping-between-json-and-the-xml-infoset"></a><span data-ttu-id="43913-122">Asignación entre JSON y el conjunto de información XML</span><span class="sxs-lookup"><span data-stu-id="43913-122">Mapping Between JSON and the XML Infoset</span></span>  
 <span data-ttu-id="43913-123">Formalmente, la asignación es entre JSON como se describe en [RFC 4627](http://go.microsoft.com/fwlink/?LinkId=98808) (excepto con ciertas restricciones estrictas y algunas otras restricciones que se agregan) y el XML infoset (y no textual XML) como se describe en [información XML Establecer](http://go.microsoft.com/fwlink/?LinkId=98809) .</span><span class="sxs-lookup"><span data-stu-id="43913-123">Formally, the mapping is between JSON as described in [RFC 4627](http://go.microsoft.com/fwlink/?LinkId=98808) (except with certain restrictions relaxed and certain other restrictions added) and the XML infoset (and not textual XML) as described in [XML Information Set](http://go.microsoft.com/fwlink/?LinkId=98809) .</span></span> <span data-ttu-id="43913-124">Vea este tema para las definiciones de *elementos de información* y campos entre [corchetes].</span><span class="sxs-lookup"><span data-stu-id="43913-124">See this topic for the definitions of *information items* and fields in [square brackets].</span></span>  
  
 <span data-ttu-id="43913-125">Un documento de JSON en blanco se asigna a un documento XML en blanco, y un documento XML en blanco se asigna a un documento JSON en blanco.</span><span class="sxs-lookup"><span data-stu-id="43913-125">A blank JSON document maps to blank XML document, and a blank XML document maps to a blank JSON document.</span></span> <span data-ttu-id="43913-126">En la asignación de XML a JSON, no se permiten espacios iniciales ni finales después del documento.</span><span class="sxs-lookup"><span data-stu-id="43913-126">On the XML to JSON mapping, preceding whitespace and trailing whitespace after the document are not allowed.</span></span>  
  
 <span data-ttu-id="43913-127">La asignación se define entre un elemento de información de documento (DII) o un elemento de información de elemento (EII) y JSON.</span><span class="sxs-lookup"><span data-stu-id="43913-127">The mapping is defined between either a Document Information Item (DII) or an Element Information Item (EII) and JSON.</span></span> <span data-ttu-id="43913-128">El EII o la propiedad [document element] (elemento de documento) del DII, se conoce como el elemento JSON raíz.</span><span class="sxs-lookup"><span data-stu-id="43913-128">The EII, or the DII’s [document element] property, is referred to as the Root JSON Element.</span></span> <span data-ttu-id="43913-129">Observe que los fragmentos del documento (XML con varios elementos raíz) no se admiten en esta asignación.</span><span class="sxs-lookup"><span data-stu-id="43913-129">Note that document fragments (XML with multiple root elements) are not supported in this mapping.</span></span>  
  
 <span data-ttu-id="43913-130">Ejemplo: el documento siguiente:</span><span class="sxs-lookup"><span data-stu-id="43913-130">Example: The following document:</span></span>  
  
 `<?xml version="1.0"?>`  
  
 `<root type="number">42</root>`  
  
 <span data-ttu-id="43913-131">Y el siguiente elemento:</span><span class="sxs-lookup"><span data-stu-id="43913-131">And the following element:</span></span>  
  
 `<root type="number">42</root>`  
  
 <span data-ttu-id="43913-132">Ambos tienen una asignación a JSON.</span><span class="sxs-lookup"><span data-stu-id="43913-132">Both have a mapping to JSON.</span></span> <span data-ttu-id="43913-133">El <`root`> es el elemento JSON raíz en ambos casos.</span><span class="sxs-lookup"><span data-stu-id="43913-133">The <`root`> element is the Root JSON Element in both cases.</span></span>  
  
 <span data-ttu-id="43913-134">Es más, en el caso de un DII, se debería tener considerar lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="43913-134">Furthermore, in the case of a DII, the following should be considered:</span></span>  
  
-   <span data-ttu-id="43913-135">Algunos elementos en la lista [children] (elemento secundario) no deben estar presentes.</span><span class="sxs-lookup"><span data-stu-id="43913-135">Some items in the [children] list must not be present.</span></span> <span data-ttu-id="43913-136">No se base en este hecho al leer XML asignado desde JSON.</span><span class="sxs-lookup"><span data-stu-id="43913-136">Do not rely on this fact when reading XML mapped from JSON.</span></span>  
  
-   <span data-ttu-id="43913-137">La lista [children] no conserva elementos de información de comentarios.</span><span class="sxs-lookup"><span data-stu-id="43913-137">The [children] list holds no comment information items.</span></span>  
  
-   <span data-ttu-id="43913-138">La lista [children] no conserva elementos de información de DTD.</span><span class="sxs-lookup"><span data-stu-id="43913-138">The [children] list holds no DTD information items.</span></span>  
  
-   <span data-ttu-id="43913-139">La lista [children] no conserva ningún elemento de información personal de información (PI) (la \<? xml... > declaración no se considera un elemento de información de PI)</span><span class="sxs-lookup"><span data-stu-id="43913-139">The [children] list holds no personal Information (PI) information items (the \<?xml…> declaration is not considered a PI information item)</span></span>  
  
-   <span data-ttu-id="43913-140">El conjunto [notations] (notaciones) está vacío.</span><span class="sxs-lookup"><span data-stu-id="43913-140">The [notations] set is empty.</span></span>  
  
-   <span data-ttu-id="43913-141">El conjunto [unparsed entities] (entidades no analizadas) está vacío.</span><span class="sxs-lookup"><span data-stu-id="43913-141">The [unparsed entities] set is empty.</span></span>  
  
 <span data-ttu-id="43913-142">Ejemplo: el siguiente documento no tiene ninguna asignación a JSON porque [children] conserva un PI y un comentario.</span><span class="sxs-lookup"><span data-stu-id="43913-142">Example: The following document has no mapping to JSON because [children] holds a PI and a comment.</span></span>  
  
 `<?xml version="1.0"?>`  
  
 `<!--comment--><?pi?>`  
  
 `<root type="number">42</root>`  
  
 <span data-ttu-id="43913-143">El EII del elemento JSON raíz tiene las siguientes características:</span><span class="sxs-lookup"><span data-stu-id="43913-143">The EII for the Root JSON Element has the following characteristics:</span></span>  
  
-   <span data-ttu-id="43913-144">[local name] (nombre local) tiene el valor "root" (raíz).</span><span class="sxs-lookup"><span data-stu-id="43913-144">[local name] has the value "root".</span></span>  
  
-   <span data-ttu-id="43913-145">[namespace name] (nombre de espacio de nombres) no tiene ningún valor.</span><span class="sxs-lookup"><span data-stu-id="43913-145">[namespace name] has no value.</span></span>  
  
-   <span data-ttu-id="43913-146">[prefix] (prefijo) no tiene ningún valor.</span><span class="sxs-lookup"><span data-stu-id="43913-146">[prefix] has no value.</span></span>  
  
-   <span data-ttu-id="43913-147">[children] puede contener elementos EII (que representan los elementos internos, tal y como se describe más adelante) o elementos CII (elementos de información de caracteres, tal y como se describe más adelante) o ninguno de éstos, pero no ambos.</span><span class="sxs-lookup"><span data-stu-id="43913-147">[children] may either contain EIIs (which represent Inner Elements as described further) or CIIs (Character Information Items as described further) or none of these, but not both.</span></span>  
  
-   <span data-ttu-id="43913-148">[attributes] (atributos) puede contener los siguientes elementos de información de atributos opcionales (AII)</span><span class="sxs-lookup"><span data-stu-id="43913-148">[attributes] may contain the following optional attribute information items (AIIs)</span></span>  
  
-   <span data-ttu-id="43913-149">El atributo de tipo JSON ("type"), tal y como se describe más adelante.</span><span class="sxs-lookup"><span data-stu-id="43913-149">The JSON Type Attribute ("type") as described further.</span></span> <span data-ttu-id="43913-150">Este atributo se utiliza para conservar el tipo JSON (cadena, número, booleano, objeto, matriz o nulo) en el XML asignado.</span><span class="sxs-lookup"><span data-stu-id="43913-150">This attribute is used to preserve the JSON type (string, number, boolean, object, array or null) in the mapped XML.</span></span>  
  
-   <span data-ttu-id="43913-151">El atributo de nombre del contrato de datos ("__type") tal y como se describe más adelante.</span><span class="sxs-lookup"><span data-stu-id="43913-151">The Data Contract Name Attribute ("__type") as described further.</span></span> <span data-ttu-id="43913-152">Este atributo solo puede estar presente si el atributo de tipo de JSON también está presente y su [normalized value] (valor normalizado) es "object".</span><span class="sxs-lookup"><span data-stu-id="43913-152">This attribute is can only be present if the JSON type attribute is also present and its [normalized value] is "object".</span></span> <span data-ttu-id="43913-153">`DataContractJsonSerializer` utiliza este atributo para conservar información del tipo de contrato de datos; por ejemplo, en casos polimórficos donde se serializa un tipo derivado y donde se espera un tipo base.</span><span class="sxs-lookup"><span data-stu-id="43913-153">This attribute is used by the `DataContractJsonSerializer` to preserve data contract type information - for example, in polymorphic cases where a derived type is serialized and where a base type is expected.</span></span> <span data-ttu-id="43913-154">Si no está trabajando con el `DataContractJsonSerializer`, en la mayoría de los casos, se pasa por alto este atributo.</span><span class="sxs-lookup"><span data-stu-id="43913-154">If you are not working with the `DataContractJsonSerializer`, in most cases, this attribute is ignored.</span></span>  
  
-   <span data-ttu-id="43913-155">[in-scope namespaces] (espacios de nombres en el ámbito) contiene el enlace de "xml" a "http://www.w3.org/XML/1998/namespace" tal y como requiere la especificación del conjunto de información.</span><span class="sxs-lookup"><span data-stu-id="43913-155">[in-scope namespaces] contains the binding of "xml" to "http://www.w3.org/XML/1998/namespace" as mandated by the infoset specification.</span></span>  
  
-   <span data-ttu-id="43913-156">[children], [attributes] e [in-scope namespaces] no deben tener elementos distintos de los especificados previamente y [namespace attributes] (atributos del espacio de nombres) no debe tener ningún miembro, pero no se base en estos hechos al leer XML asignado a partir de JSON.</span><span class="sxs-lookup"><span data-stu-id="43913-156">[children], [attributes] and [in-scope namespaces] must not have any items other than as specified previously and [namespace attributes] must have no members, but do not rely on these facts when reading XML mapped from JSON.</span></span>  
  
 <span data-ttu-id="43913-157">Ejemplo: el siguiente documento no tiene ninguna asignación a JSON porque [namespace attributes] no está vacío.</span><span class="sxs-lookup"><span data-stu-id="43913-157">Example: The following document has no mapping to JSON because [namespace attributes] is not empty.</span></span>  
  
 `<?xml version="1.0"?>`  
  
 `<root  xmlns:a="myattributevalue">42</root>`  
  
 <span data-ttu-id="43913-158">El AII para el atributo de tipo JSON tiene las siguientes características:</span><span class="sxs-lookup"><span data-stu-id="43913-158">The AII for the JSON Type Attribute has the following characteristics:</span></span>  
  
-   <span data-ttu-id="43913-159">[namespace name] (nombre de espacio de nombres) no tiene ningún valor.</span><span class="sxs-lookup"><span data-stu-id="43913-159">[namespace name] has no value.</span></span>  
  
-   <span data-ttu-id="43913-160">[prefix] (prefijo) no tiene ningún valor.</span><span class="sxs-lookup"><span data-stu-id="43913-160">[prefix] has no value.</span></span>  
  
-   <span data-ttu-id="43913-161">[local name] es "type".</span><span class="sxs-lookup"><span data-stu-id="43913-161">[local name] is "type".</span></span>  
  
-   <span data-ttu-id="43913-162">[normalized value] es uno de los valores de tipo posibles descritos en la siguiente sección.</span><span class="sxs-lookup"><span data-stu-id="43913-162">[normalized value] is one of the possible type values described in the following section.</span></span>  
  
-   <span data-ttu-id="43913-163">[specified] (especificado) es `true`.</span><span class="sxs-lookup"><span data-stu-id="43913-163">[specified] is `true`.</span></span>  
  
-   <span data-ttu-id="43913-164">[attribute type] (tipo de atributo) no tiene valor.</span><span class="sxs-lookup"><span data-stu-id="43913-164">[attribute type] has no value.</span></span>  
  
-   <span data-ttu-id="43913-165">[references] (referencias) no tiene valor.</span><span class="sxs-lookup"><span data-stu-id="43913-165">[references] has no value.</span></span>  
  
 <span data-ttu-id="43913-166">El AII para el atributo de nombre del contrato de datos tiene las siguientes características:</span><span class="sxs-lookup"><span data-stu-id="43913-166">The AII for the Data Contract Name Attribute has the following characteristics:</span></span>  
  
-   <span data-ttu-id="43913-167">[namespace name] (nombre de espacio de nombres) no tiene ningún valor.</span><span class="sxs-lookup"><span data-stu-id="43913-167">[namespace name] has no value.</span></span>  
  
-   <span data-ttu-id="43913-168">[prefix] (prefijo) no tiene ningún valor.</span><span class="sxs-lookup"><span data-stu-id="43913-168">[prefix] has no value.</span></span>  
  
-   <span data-ttu-id="43913-169">[local name] es "__type" (dos caracteres de subrayado y, a continuación, "type").</span><span class="sxs-lookup"><span data-stu-id="43913-169">[local name] is "__type" (two underscores and then "type").</span></span>  
  
-   <span data-ttu-id="43913-170">[normalized value] (valor normalizado) es cualquier cadena Unicode válida (la asignación de esta cadena a JSON se describe en la siguiente sección).</span><span class="sxs-lookup"><span data-stu-id="43913-170">[normalized value] is any valid Unicode string – the mapping of this string to JSON is described in the following section.</span></span>  
  
-   <span data-ttu-id="43913-171">[specified] (especificado) es `true`.</span><span class="sxs-lookup"><span data-stu-id="43913-171">[specified] is `true`.</span></span>  
  
-   <span data-ttu-id="43913-172">[attribute type] (tipo de atributo) no tiene valor.</span><span class="sxs-lookup"><span data-stu-id="43913-172">[attribute type] has no value.</span></span>  
  
-   <span data-ttu-id="43913-173">[references] (referencias) no tiene valor.</span><span class="sxs-lookup"><span data-stu-id="43913-173">[references] has no value.</span></span>  
  
 <span data-ttu-id="43913-174">Los elementos internos contenidos dentro del elemento JSON raíz u otros elementos internos tienen las siguientes características:</span><span class="sxs-lookup"><span data-stu-id="43913-174">Inner elements contained within the Root JSON Element or other inner elements have the following characteristics:</span></span>  
  
-   <span data-ttu-id="43913-175">[local name] puede tener cualquier valor, tal y como se describe más adelante</span><span class="sxs-lookup"><span data-stu-id="43913-175">[local name] may have any value as described further</span></span>  
  
-   <span data-ttu-id="43913-176">[namespace name], [prefix], [children], [attributes], [namespace attributes] e [in-scope namespaces] están sujetos a las mismas reglas que el elemento JSON raíz.</span><span class="sxs-lookup"><span data-stu-id="43913-176">[namespace name], [prefix], [children], [attributes], [namespace attributes], and [in-scope namespaces] are subject to the same rules as the Root JSON Element.</span></span>  
  
 <span data-ttu-id="43913-177">En el elemento JSON raíz y los elementos internos, el atributo de tipo JSON define la asignación a JSON y el posible [children] (elemento secundario) y su interpretación.</span><span class="sxs-lookup"><span data-stu-id="43913-177">In both the Root JSON Element and the inner elements, the JSON Type Attribute defines the mapping to JSON and the possible [children] and their interpretation.</span></span> <span data-ttu-id="43913-178">El [normalized value] (valor normalizado) del atributo distingue entre mayúsculas y minúsculas y debe ser estar en minúsculas y no puede contener espacios.</span><span class="sxs-lookup"><span data-stu-id="43913-178">The attribute’s [normalized value] is case-sensitive and must be lowercase, and cannot contain whitespace.</span></span>  
  
|<span data-ttu-id="43913-179">[normalized value] del AII del `JSON Type Attribute`</span><span class="sxs-lookup"><span data-stu-id="43913-179">[normalized value] of `JSON Type Attribute`’s AII</span></span>|<span data-ttu-id="43913-180">[children] permitido del EII correspondiente</span><span class="sxs-lookup"><span data-stu-id="43913-180">Allowed [children] of the corresponding EII</span></span>|<span data-ttu-id="43913-181">Asignación a JSON</span><span class="sxs-lookup"><span data-stu-id="43913-181">Mapping to JSON</span></span>|  
|---------------------------------------------------------|---------------------------------------------------|---------------------|  
|<span data-ttu-id="43913-182">`string` (o ausencia del AII de tipo JSON)</span><span class="sxs-lookup"><span data-stu-id="43913-182">`string` (or absence of the JSON type AII)</span></span><br /><br /> <span data-ttu-id="43913-183">Una `string` y la ausencia del AII de tipo JSON son lo mismo, y hace que `string` sea el valor predeterminado.</span><span class="sxs-lookup"><span data-stu-id="43913-183">A `string` and the absence of the JSON type AII are the same makes `string` the default.</span></span><br /><br /> <span data-ttu-id="43913-184">De modo que, `<root> string1</root>``string` asigna a la "string1"  de JSON.</span><span class="sxs-lookup"><span data-stu-id="43913-184">So, `<root> string1</root>` maps to the JSON `string` "string1".</span></span>|<span data-ttu-id="43913-185">0 o más CII</span><span class="sxs-lookup"><span data-stu-id="43913-185">0 or more CIIs</span></span>|<span data-ttu-id="43913-186">`string` JSON (RFC de JSON, sección 2.5).</span><span class="sxs-lookup"><span data-stu-id="43913-186">A JSON `string` (JSON RFC, section 2.5).</span></span> <span data-ttu-id="43913-187">Cada `char` es un carácter que corresponde al [character code] (código de carácter) del CII.</span><span class="sxs-lookup"><span data-stu-id="43913-187">Each `char` is a character that corresponds to the [character code] from the CII.</span></span> <span data-ttu-id="43913-188">Si no hay ningún CII, asigna a una `string`de JSON vacía.</span><span class="sxs-lookup"><span data-stu-id="43913-188">If there are no CIIs, it maps to an empty JSON `string`.</span></span><br /><br /> <span data-ttu-id="43913-189">Ejemplo: el elemento siguiente se asigna a un fragmento de JSON:</span><span class="sxs-lookup"><span data-stu-id="43913-189">Example: The following element maps to a JSON fragment:</span></span><br /><br /> `<root type="string">42</root>`<br /><br /> <span data-ttu-id="43913-190">El fragmento de JSON es "42".</span><span class="sxs-lookup"><span data-stu-id="43913-190">The JSON fragment is "42".</span></span><br /><br /> <span data-ttu-id="43913-191">En la asignación de XML a JSON, los caracteres que deben establecerse como secuencia de escape se asignan a caracteres con escape, el resto se asigna a caracteres sin escape.</span><span class="sxs-lookup"><span data-stu-id="43913-191">On XML to JSON mapping, characters that must be escaped map to escaped characters, all others map to characters that are not escaped.</span></span> <span data-ttu-id="43913-192">El carácter "/" es especial: que sea de escape aunque no tiene que ser (escrito como "\\/").</span><span class="sxs-lookup"><span data-stu-id="43913-192">The "/" character is special – it is escaped even though it does not have to be (written out as "\\/").</span></span><br /><br /> <span data-ttu-id="43913-193">Ejemplo: el elemento siguiente se asigna a un fragmento de JSON.</span><span class="sxs-lookup"><span data-stu-id="43913-193">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="string">the "da/ta"</root>`<br /><br /> <span data-ttu-id="43913-194">El fragmento JSON es "la \\" DAS\\/ta\\"".</span><span class="sxs-lookup"><span data-stu-id="43913-194">The JSON fragment is "the \\"da\\/ta\\"".</span></span><br /><br /> <span data-ttu-id="43913-195">En la asignación de JSON a XML, cualquier carácter con escape y sin escape se asignan correctamente al [character code] correspondiente.</span><span class="sxs-lookup"><span data-stu-id="43913-195">On JSON to XML mapping, any escaped characters and characters that are not escaped map correctly to the corresponding [character code].</span></span><br /><br /> <span data-ttu-id="43913-196">Ejemplo: el fragmento de JSON "\u0041BC" se asigna al siguiente elemento XML.</span><span class="sxs-lookup"><span data-stu-id="43913-196">Example: The JSON fragment "\u0041BC", maps to the following XML element.</span></span><br /><br /> `<root type="string">ABC</root>`<br /><br /> <span data-ttu-id="43913-197">La cadena puede estar rodeada por espacios ('ws' en la sección 2 de JSON RFC) que no se asignan a XML.</span><span class="sxs-lookup"><span data-stu-id="43913-197">The string can be surrounded by whitespace ('ws' in section 2 of the JSON RFC) that does not get mapped to XML.</span></span><br /><br /> <span data-ttu-id="43913-198">Ejemplo: el fragmento de JSON           "ABC", (hay espacios antes de la primera comilla doble) asigna al siguiente elemento XML.</span><span class="sxs-lookup"><span data-stu-id="43913-198">Example: The JSON fragment           "ABC", (there are spaces before the first double quote), maps to the following XML element.</span></span><br /><br /> `<root type="string">ABC</root>`<br /><br /> <span data-ttu-id="43913-199">Cualquier espacio en XML se asigna a un espacio en JSON.</span><span class="sxs-lookup"><span data-stu-id="43913-199">Any whitespace in XML maps to whitespace in JSON.</span></span><br /><br /> <span data-ttu-id="43913-200">Ejemplo: el elemento XML siguiente se asigna a un fragmento de JSON.</span><span class="sxs-lookup"><span data-stu-id="43913-200">Example: The following XML element maps to a JSON fragment.</span></span><br /><br /> `<root type="string">  A BC      </root>`<br /><br /> <span data-ttu-id="43913-201">El fragmento de JSON es " A BC ".</span><span class="sxs-lookup"><span data-stu-id="43913-201">The JSON fragment is " A BC ".</span></span>|  
|`number`|<span data-ttu-id="43913-202">1 o más CII</span><span class="sxs-lookup"><span data-stu-id="43913-202">1 or more CIIs</span></span>|<span data-ttu-id="43913-203">Un `number` de JSON (JSON RFC, sección 2.4), posiblemente rodeado por espacios.</span><span class="sxs-lookup"><span data-stu-id="43913-203">A JSON `number` (JSON RFC, section 2.4), possibly surrounded by whitespace.</span></span> <span data-ttu-id="43913-204">Cada carácter en la combinación de número/espacio en blanco es un carácter que corresponde al [character code] del CII.</span><span class="sxs-lookup"><span data-stu-id="43913-204">Each character in the number/whitespace combination is a character that corresponds to the [character code] from the CII.</span></span><br /><br /> <span data-ttu-id="43913-205">Ejemplo: el elemento siguiente se asigna a un fragmento de JSON.</span><span class="sxs-lookup"><span data-stu-id="43913-205">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="number">    42</root>`<br /><br /> <span data-ttu-id="43913-206">El fragmento JSON es    42</span><span class="sxs-lookup"><span data-stu-id="43913-206">The JSON fragment is    42</span></span><br /><br /> <span data-ttu-id="43913-207">(Se conserva el espacio en blanco).</span><span class="sxs-lookup"><span data-stu-id="43913-207">(Whitespace is preserved).</span></span>|  
|`boolean`|<span data-ttu-id="43913-208">4 ó 5 CII (que corresponde a `true` o `false`), posiblemente rodeado por CII de espacios adicionales.</span><span class="sxs-lookup"><span data-stu-id="43913-208">4 or 5 CIIs (which corresponds to `true` or `false`), possibly surrounded by additional whitespace CIIs.</span></span>|<span data-ttu-id="43913-209">Una secuencia de CII que corresponde a la cadena "true" se asigna al `true` literal, y una secuencia de CII que corresponde a la cadena "false" se asigna al `false` literal.</span><span class="sxs-lookup"><span data-stu-id="43913-209">A CII sequence that corresponds to the string "true" is mapped to the literal `true`, and a CII sequence that corresponds to the string "false" is mapped to the literal `false`.</span></span> <span data-ttu-id="43913-210">Se conservan los espacios envolventes.</span><span class="sxs-lookup"><span data-stu-id="43913-210">Surrounding whitespace is preserved.</span></span><br /><br /> <span data-ttu-id="43913-211">Ejemplo: el elemento siguiente se asigna a un fragmento de JSON.</span><span class="sxs-lookup"><span data-stu-id="43913-211">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="boolean"> false</root>`<br /><br /> <span data-ttu-id="43913-212">El fragmento de JSON es `false`.</span><span class="sxs-lookup"><span data-stu-id="43913-212">The JSON fragment is `false`.</span></span>|  
|`null`|<span data-ttu-id="43913-213">Ninguno permitido.</span><span class="sxs-lookup"><span data-stu-id="43913-213">None allowed.</span></span>|<span data-ttu-id="43913-214">El literal `null`.</span><span class="sxs-lookup"><span data-stu-id="43913-214">The literal `null`.</span></span> <span data-ttu-id="43913-215">En la asignación de JSON a XML, el valor `null` puede estar rodeado por espacios (‘ws’ en la sección 2) que no se asignan a XML.</span><span class="sxs-lookup"><span data-stu-id="43913-215">On JSON to XML mapping, the `null` may be surrounded by whitespace (‘ws’ in section 2) that does not get mapped to XML.</span></span><br /><br /> <span data-ttu-id="43913-216">Ejemplo: el elemento siguiente se asigna a un fragmento de JSON.</span><span class="sxs-lookup"><span data-stu-id="43913-216">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="null"/>`<br /><br /> <span data-ttu-id="43913-217">o</span><span class="sxs-lookup"><span data-stu-id="43913-217">or</span></span><br /><br /> `<root type="null"></root>`<br /><br /> <span data-ttu-id="43913-218">:</span><span class="sxs-lookup"><span data-stu-id="43913-218">:</span></span><br /><br /> <span data-ttu-id="43913-219">El fragmento de JSON es en ambos casos `Null`.</span><span class="sxs-lookup"><span data-stu-id="43913-219">The JSON fragment in both cases is `Null`.</span></span>|  
|`object`|<span data-ttu-id="43913-220">0 o más EII.</span><span class="sxs-lookup"><span data-stu-id="43913-220">0 or more EIIs.</span></span>|<span data-ttu-id="43913-221">`begin-object` (llave izquierda) como en la sección 2.2 de la RFC de JSON, seguida por un registro de miembros para cada EII, tal y como se describe más adelante.</span><span class="sxs-lookup"><span data-stu-id="43913-221">A `begin-object` (left curly brace) as in section 2.2 of the JSON RFC, followed by a member record for each EII as described further.</span></span> <span data-ttu-id="43913-222">Si hay más de un EII, hay separadores de valores (comas) entre los registros de miembros.</span><span class="sxs-lookup"><span data-stu-id="43913-222">If there is more than one EII, there are value-separators (commas) between the member records.</span></span> <span data-ttu-id="43913-223">Todo esto va seguido de un objeto de fin (llave derecha).</span><span class="sxs-lookup"><span data-stu-id="43913-223">All this is followed by an end-object (right curly brace).</span></span><br /><br /> <span data-ttu-id="43913-224">Ejemplo: el elemento siguiente se asigna al fragmento de JSON.</span><span class="sxs-lookup"><span data-stu-id="43913-224">Example: The following element maps to the JSON fragment.</span></span><br /><br /> <span data-ttu-id="43913-225">\<tipo de raíz = "object" ></span><span class="sxs-lookup"><span data-stu-id="43913-225">\<root type="object"></span></span><br /><br /> <span data-ttu-id="43913-226">\<tipo de type1 = "string" > aaa\</type1 ></span><span class="sxs-lookup"><span data-stu-id="43913-226">\<type1 type="string">aaa\</type1></span></span><br /><br /> <span data-ttu-id="43913-227">\<tipo de type2 = "string" > bbb\</type2 ></span><span class="sxs-lookup"><span data-stu-id="43913-227">\<type2 type="string">bbb\</type2></span></span><br /><br /> <span data-ttu-id="43913-228">\</ root ></span><span class="sxs-lookup"><span data-stu-id="43913-228">\</root ></span></span><br /><br /> <span data-ttu-id="43913-229">El fragmento de JSON es {"type1":"aaa","type2":"bbb"}.</span><span class="sxs-lookup"><span data-stu-id="43913-229">The JSON fragment is {"type1":"aaa","type2":"bbb"}.</span></span><br /><br /> <span data-ttu-id="43913-230">Si el atributo del tipo de contrato de datos está presente en la asignación de XML a JSON, se inserta un registro de miembro adicional al principio.</span><span class="sxs-lookup"><span data-stu-id="43913-230">If the Data Contract Type Attribute is present on XML to JSON mapping, then an additional Member Record is inserted at the beginning.</span></span> <span data-ttu-id="43913-231">Su nombre es el [local name] del atributo del tipo de contrato de datos ("__type") y su valor es el [normalized value] del atributo.</span><span class="sxs-lookup"><span data-stu-id="43913-231">Its name is the [local name] of the Data Contract Type Attribute ("__type"), and its value is the attribute's [normalized value].</span></span> <span data-ttu-id="43913-232">Por el contrario, en JSON para la asignación de XML, si el primer miembro-nombre del registro es el [local name] del atributo de tipo de contrato de datos (es decir, "\_e_scriba"), un atributo de tipo de contrato de datos correspondiente está presente en el XML asignado, pero no es de un EII correspondiente está presente.</span><span class="sxs-lookup"><span data-stu-id="43913-232">Conversely, on JSON to XML mapping, if the first member-record’s name is the [local name] of the Data Contract Type Attribute (that is, "\__type"), a corresponding Data Contract Type Attribute is present in the mapped XML, but a corresponding EII is not present.</span></span> <span data-ttu-id="43913-233">Observe que este registro de miembro debe producirse primero en el objeto JSON para que se aplique esta asignación especial.</span><span class="sxs-lookup"><span data-stu-id="43913-233">Note that this member record must occur first in the JSON object for this special mapping to apply.</span></span> <span data-ttu-id="43913-234">Esto representa una salida del procesamiento de JSON habitual, donde el orden de los registros de miembros no es importante.</span><span class="sxs-lookup"><span data-stu-id="43913-234">This represents a departure from usual JSON processing, where the order of member records is not significant.</span></span><br /><br /> <span data-ttu-id="43913-235">Ejemplo:</span><span class="sxs-lookup"><span data-stu-id="43913-235">Example:</span></span><br /><br /> <span data-ttu-id="43913-236">El siguiente fragmento de JSON se asigna a XML.</span><span class="sxs-lookup"><span data-stu-id="43913-236">The following JSON fragment maps to XML.</span></span><br /><br /> `{"__type":"Person","name":"John"}`<br /><br /> <span data-ttu-id="43913-237">El XML es el código siguiente.</span><span class="sxs-lookup"><span data-stu-id="43913-237">The XML is the following code.</span></span><br /><br /> `<root type="object" __type="Person">   <name type="string">John</name> </root>`<br /><br /> <span data-ttu-id="43913-238">Tenga en cuenta que la \_e_scriba AII está presente, pero no hay ningún \_e_scriba EII.</span><span class="sxs-lookup"><span data-stu-id="43913-238">Notice that the \__type AII is present, but there is no \__type EII.</span></span><br /><br /> <span data-ttu-id="43913-239">Sin embargo, si se invierte el orden en JSON como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="43913-239">However, if the order in the JSON is reversed as shown in the following example.</span></span><br /><br /> <span data-ttu-id="43913-240">{"name": "John","\_e_scriba": "Persona"}</span><span class="sxs-lookup"><span data-stu-id="43913-240">{"name":"John","\__type":"Person"}</span></span><br /><br /> <span data-ttu-id="43913-241">Se muestra el XML correspondiente.</span><span class="sxs-lookup"><span data-stu-id="43913-241">The corresponding XML is shown.</span></span><br /><br /> `<root type="object">   <name type="string">John</name>   <__type type="string">Person</__type> </root>`<br /><br /> <span data-ttu-id="43913-242">Es decir, \_e_scriba deja de tener un significado especial y se asigna a un EII como es habitual, no AII.</span><span class="sxs-lookup"><span data-stu-id="43913-242">That is, \__type ceases to have special meaning and maps to an EII as usual, not AII.</span></span><br /><br /> <span data-ttu-id="43913-243">Las reglas de escapado/no escapado para el [normalized value] del AII cuando se asigna a un valor JSON son las mismas que para las cadenas de JSON, especificadas en la fila "string" de esta tabla.</span><span class="sxs-lookup"><span data-stu-id="43913-243">Escaping/unescaping rules for the AII’s [normalized value] when mapped to a JSON value are the same as for JSON strings, specified in the "string" row of this table.</span></span><br /><br /> <span data-ttu-id="43913-244">Ejemplo:</span><span class="sxs-lookup"><span data-stu-id="43913-244">Example:</span></span><br /><br /> `<root type="object" __type="\abc" />`<br /><br /> <span data-ttu-id="43913-245">en el ejemplo anterior puede asignarse al siguiente JSON.</span><span class="sxs-lookup"><span data-stu-id="43913-245">to the previous example can be mapped to the following JSON.</span></span><br /><br /> `{"__type":"\\abc"}`<br /><br /> <span data-ttu-id="43913-246">En una asignación de XML a JSON, no debe ser del primer EII [local name] "\_e_scriba".</span><span class="sxs-lookup"><span data-stu-id="43913-246">On an XML to JSON mapping, the first EII’s [local name] must not be "\__type".</span></span><br /><br /> <span data-ttu-id="43913-247">El espacio en blanco (`ws`) nunca se genera en la asignación de XML a JSON para objetos y se omite en la asignación de JSON a XML.</span><span class="sxs-lookup"><span data-stu-id="43913-247">Whitespace (`ws`) is never generated on XML to JSON mapping for objects and is ignored on JSON to XML mapping.</span></span><br /><br /> <span data-ttu-id="43913-248">Ejemplo: el siguiente fragmento de JSON se asigna a un elemento XML.</span><span class="sxs-lookup"><span data-stu-id="43913-248">Example: The following JSON fragment maps to an XML element.</span></span><br /><br /> <span data-ttu-id="43913-249">{   "ccc"   :  "aaa",   "ddd"    :"bbb"}</span><span class="sxs-lookup"><span data-stu-id="43913-249">{   "ccc"   :  "aaa",   "ddd"    :"bbb"}</span></span><br /><br /> <span data-ttu-id="43913-250">El elemento XML se muestra en el siguiente código.</span><span class="sxs-lookup"><span data-stu-id="43913-250">The XML element is shown in the following code.</span></span><br /><br /> `<root type="object">    <ccc type="string">aaa</ccc>    <ddd type="string">bbb</bar> </root >`|  
<span data-ttu-id="43913-251">Ray'</span><span class="sxs-lookup"><span data-stu-id="43913-251">ray\`</span></span>|<span data-ttu-id="43913-252">0 o más EII</span><span class="sxs-lookup"><span data-stu-id="43913-252">0 or more EIIs</span></span>|<span data-ttu-id="43913-253">Una matriz de comienzo (corchete de apertura) como en la sección 2.3 de la JSON RFC, seguida por un registro de matriz para cada EII, tal y como se describe más adelante.</span><span class="sxs-lookup"><span data-stu-id="43913-253">A begin-array (left square bracket) as in section 2.3 of the JSON RFC, followed by an array record for each EII as described further.</span></span> <span data-ttu-id="43913-254">Si hay más de un EII, hay separadores de valores (comas) entre los registros de matrices.</span><span class="sxs-lookup"><span data-stu-id="43913-254">If there is more than one EII, there are value-separators (commas) between the array records.</span></span> <span data-ttu-id="43913-255">Una matriz es seguida por una matriz de final.</span><span class="sxs-lookup"><span data-stu-id="43913-255">All this is followed by an end-array.</span></span><br /><br /> <span data-ttu-id="43913-256">Ejemplo: el elemento XML siguiente se asigna a un fragmento de JSON.</span><span class="sxs-lookup"><span data-stu-id="43913-256">Example: The following XML element maps to a JSON fragment.</span></span><br /><br /> `<root type="array"/>    <item type="string">aaa</item>    <item type="string">bbb</item> </root >`<br /><br /> <span data-ttu-id="43913-257">El fragmento de JSON es ["aaa", "bbb"]</span><span class="sxs-lookup"><span data-stu-id="43913-257">The JSON fragment is ["aaa","bbb"]</span></span><br /><br /> <span data-ttu-id="43913-258">El espacio en blanco (`ws`) nunca se genera en la asignación de XML a JSON para matrices y se omite en la asignación de JSON a XML.</span><span class="sxs-lookup"><span data-stu-id="43913-258">Whitespace (`ws`) is never generated on XML to JSON mapping for arrays and is ignored on JSON to XML mapping.</span></span><br /><br /> <span data-ttu-id="43913-259">Ejemplo: fragmento de AJSON.</span><span class="sxs-lookup"><span data-stu-id="43913-259">Example: AJSON fragment.</span></span><br /><br /> <span data-ttu-id="43913-260">[     "aaa",     "bbb"]</span><span class="sxs-lookup"><span data-stu-id="43913-260">[     "aaa",     "bbb"]</span></span><br /><br /> <span data-ttu-id="43913-261">El elemento XML al que se asigna.</span><span class="sxs-lookup"><span data-stu-id="43913-261">The XML element that it maps to.</span></span><br /><br /> `<root type="array"/>    <item type="string">aaa</item>    <item type="string">bbb</item> </root >`|  
  
 <span data-ttu-id="43913-262">Los registros de miembros funcionan de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="43913-262">Member Records work as follows:</span></span>  
  
-   <span data-ttu-id="43913-263">El [local name] del elemento interno se asigna a la parte de `string` del `member`, tal y como se define en la sección 2.2 de la JSON RFC.</span><span class="sxs-lookup"><span data-stu-id="43913-263">Inner element’s [local name] maps to the `string` part of the `member` as defined in section 2.2 of the JSON RFC.</span></span>  
  
 <span data-ttu-id="43913-264">Ejemplo: el elemento siguiente se asigna a un fragmento de JSON.</span><span class="sxs-lookup"><span data-stu-id="43913-264">Example: The following element maps to a JSON fragment.</span></span>  
  
 `<root type="object"/>`  
  
 `<myLocalName type="string">aaa</myLocalName>`  
  
 `</root >`  
  
 <span data-ttu-id="43913-265">Se muestra el siguiente fragmento de JSON.</span><span class="sxs-lookup"><span data-stu-id="43913-265">The following JSON fragment is displayed.</span></span>  
  
 `{"myLocalName":"aaa"}`  
  
-   <span data-ttu-id="43913-266">En la asignación de XML a JSON, los caracteres que deben tener escape en JSON tienen escape, y el resto no tiene escape.</span><span class="sxs-lookup"><span data-stu-id="43913-266">On the XML to JSON mapping, the characters that must be escaped in JSON are escaped, and the others are not escaped.</span></span> <span data-ttu-id="43913-267">El carácter "/", aunque no es ningún carácter que deba tener escape, lo tiene (no es necesario que tenga escape en la asignación de JSON a XML).</span><span class="sxs-lookup"><span data-stu-id="43913-267">The "/" character, even though it is not a character that must be escaped, is escaped nevertheless (it does not have to be escaped on JSON to XML mapping).</span></span> <span data-ttu-id="43913-268">Esto es necesario para admitir el formato AJAX de ASP.NET para los datos `DateTime` en JSON.</span><span class="sxs-lookup"><span data-stu-id="43913-268">This is required to support the ASP.NET AJAX format for `DateTime` data in JSON.</span></span>  
  
-   <span data-ttu-id="43913-269">En la asignación de JSON a XML, todos los caracteres (incluidos los que no tienen escape, si fuese necesario) se toman para formar una `string` que genera un [local name].</span><span class="sxs-lookup"><span data-stu-id="43913-269">On the JSON to XML mapping, all characters (including the not escaped characters, if necessary) are taken to form a `string` that produces a [local name].</span></span>  
  
-   <span data-ttu-id="43913-270">Los elementos internos [children] se asignan al valor en la sección 2.2, de acuerdo con el `JSON Type Attribute` de la misma manera que para el `Root JSON Element`.</span><span class="sxs-lookup"><span data-stu-id="43913-270">Inner elements [children] map to the value in section 2.2, according to the `JSON Type Attribute` just like for the `Root JSON Element`.</span></span> <span data-ttu-id="43913-271">Se permiten varios niveles de anidación de EII (incluida la anidación dentro de matrices).</span><span class="sxs-lookup"><span data-stu-id="43913-271">Multiple levels of nesting of EIIs (including nesting within arrays) are allowed.</span></span>  
  
 <span data-ttu-id="43913-272">Ejemplo: el elemento siguiente se asigna a un fragmento de JSON.</span><span class="sxs-lookup"><span data-stu-id="43913-272">Example: The following element maps to a JSON fragment.</span></span>  
  
 `<root type="object">`  
  
 `<myLocalName1 type="string">myValue1</myLocalName1>`  
  
 `<myLocalName2 type="number">2</myLocalName2>`  
  
 `<myLocalName3 type="object">`  
  
 `<myNestedName1 type="boolean">true</myNestedName1>`  
  
 `<myNestedName2 type="null"/>`  
  
 `</myLocalName3>`  
  
 `</root >`  
  
 <span data-ttu-id="43913-273">El fragmento de JSON siguiente es a lo que se asigna.</span><span class="sxs-lookup"><span data-stu-id="43913-273">The following JSON fragment is what it maps to.</span></span>  
  
 `{"myLocalName1":"myValue1","myLocalName2":2,"myLocalName3":{"myNestedName1":true,"myNestedName2":null}}`  
  
> [!NOTE]
>  <span data-ttu-id="43913-274">No hay ningún paso de codificación XML en la asignación anterior.</span><span class="sxs-lookup"><span data-stu-id="43913-274">There is no XML encoding step in the preceding mapping.</span></span> <span data-ttu-id="43913-275">Por consiguiente, [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] solo admite documentos JSON donde todos los caracteres en nombres de claves sean caracteres válidos en nombres de elementos XML.</span><span class="sxs-lookup"><span data-stu-id="43913-275">Therefore, [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] only supports JSON documents where all characters in key names are valid characters in XML element names.</span></span> <span data-ttu-id="43913-276">Por ejemplo, el documento JSON {"<":"a"} no se admite, porque < no es un nombre válido para un elemento XML.</span><span class="sxs-lookup"><span data-stu-id="43913-276">For example, the JSON document {"<":"a"} is not supported because < is not a valid name for an XML element.</span></span>  
  
 <span data-ttu-id="43913-277">La situación inversa (caracteres válidos en XML, pero no en JSON) no produce ningún problema, puesto que la asignación anterior incluye pasos de escape/sin escape de JSON.</span><span class="sxs-lookup"><span data-stu-id="43913-277">The reverse situation (characters valid in XML but not in JSON) does not cause any problems because the preceding mapping includes JSON escaping/unescaping steps.</span></span>  
  
 <span data-ttu-id="43913-278">Los registros de matrices funcionan de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="43913-278">Array Records work as follows:</span></span>  
  
-   <span data-ttu-id="43913-279">El [local name] del elemento interno es "item".</span><span class="sxs-lookup"><span data-stu-id="43913-279">Inner element’s [local name] is "item".</span></span>  
  
-   <span data-ttu-id="43913-280">Los [children] (elementos secundarios) del elemento interno se asignan al valor en la sección 2.3, según el atributo de tipo JSON, como se hace para el elemento JSON raíz.</span><span class="sxs-lookup"><span data-stu-id="43913-280">Inner element’s [children] map to the value in section 2.3, according to the JSON Type Attribute as is does for the Root JSON Element.</span></span> <span data-ttu-id="43913-281">Se permiten varios niveles de anidación de EII (incluida la anidación dentro de objetos).</span><span class="sxs-lookup"><span data-stu-id="43913-281">Multiple levels of nesting of EIIs (including nesting within objects) are allowed.</span></span>  
  
 <span data-ttu-id="43913-282">Ejemplo: el elemento siguiente se asigna a un fragmento de JSON.</span><span class="sxs-lookup"><span data-stu-id="43913-282">Example: The following element maps to a JSON fragment.</span></span>  
  
 `<root type="array"/>`  
  
 `<item type="string">myValue1</item>`  
  
 `<item type="number">2</item>`  
  
 `<item type="array">`  
  
 `<item type="boolean">true</item>`  
  
 `<item type="null"/>`  
  
 `</item>`  
  
 `</root >`  
  
 <span data-ttu-id="43913-283">A continuación, se muestra el fragmento JSON.</span><span class="sxs-lookup"><span data-stu-id="43913-283">The following is the JSON fragment.</span></span>  
  
 `["myValue1",2,[true,null]]`  
  
## <a name="see-also"></a><span data-ttu-id="43913-284">Vea también</span><span class="sxs-lookup"><span data-stu-id="43913-284">See Also</span></span>  
 <xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory>  
 <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>  
 [<span data-ttu-id="43913-285">Serialización de JSON independiente</span><span class="sxs-lookup"><span data-stu-id="43913-285">Stand-Alone JSON Serialization</span></span>](../../../../docs/framework/wcf/feature-details/stand-alone-json-serialization.md)
