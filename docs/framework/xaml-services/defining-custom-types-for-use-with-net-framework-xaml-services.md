---
title: Definir tipos personalizados para usarlos con los servicios XAML de .NET Framework
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords: defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
caps.latest.revision: "11"
author: wadepickett
ms.author: wpickett
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: c7cce479c7c7a5f6c7112f08f1e15f3bc7e4d366
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 12/22/2017
---
# <a name="defining-custom-types-for-use-with-net-framework-xaml-services"></a><span data-ttu-id="f8e8a-102">Definir tipos personalizados para usarlos con los servicios XAML de .NET Framework</span><span class="sxs-lookup"><span data-stu-id="f8e8a-102">Defining Custom Types for Use with .NET Framework XAML Services</span></span>
<span data-ttu-id="f8e8a-103">Al definir tipos personalizados que son objetos de negocios o son tipos que no tienen una dependencia en marcos concretos, hay algunas prácticas recomendadas para XAML que puede seguir.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="f8e8a-104">Si sigue estas prácticas, los servicios XAML de .NET Framework y sus lectores XAML y escritores de XAML pueden detectar las características XAML de su tipo y darle la representación apropiada en un flujo de nodo XAML con el sistema de tipos XAML.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-104">If you follow these practices, .NET Framework XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="f8e8a-105">En este tema se describe procedimientos recomendados para las definiciones de tipo, definiciones de miembros y CLR atribución de tipos o miembros.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>  
  
## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="f8e8a-106">Patrones de constructor y definiciones de tipos para XAML</span><span class="sxs-lookup"><span data-stu-id="f8e8a-106">Constructor Patterns and Type Definitions for XAML</span></span>  
 <span data-ttu-id="f8e8a-107">Para crear una instancia como un elemento de objeto en XAML, una clase personalizada debe cumplir los siguientes requisitos:</span><span class="sxs-lookup"><span data-stu-id="f8e8a-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>  
  
-   <span data-ttu-id="f8e8a-108">La clase personalizada debe ser pública y debe exponer un constructor público (sin parámetros) de forma predeterminada.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-108">The custom class must be public and must expose a default (parameterless) public constructor.</span></span> <span data-ttu-id="f8e8a-109">(Vea en la siguiente sección las notas relativas a las estructuras).</span><span class="sxs-lookup"><span data-stu-id="f8e8a-109">(See following section for notes regarding structures.)</span></span>  
  
-   <span data-ttu-id="f8e8a-110">La clase personalizada no debe ser una clase anidada.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="f8e8a-111">El archivo extra "punto" en la ruta de acceso del nombre completo realiza la división de espacio de nombres de clase ambiguo e interfiere con otras características XAML como propiedades adjuntas.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="f8e8a-112">Si un objeto se puede crear instancias como un elemento de objeto, el objeto creado puede rellenar el formulario de elemento de propiedad de las propiedades que toman el objeto como su tipo subyacente.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>  
  
 <span data-ttu-id="f8e8a-113">Todavía puede proporcionar valores de objeto para los tipos que no cumplen estos criterios, si habilita un convertidor de valores.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="f8e8a-114">Para obtener más información, consulte [convertidores de tipos y extensiones de marcado para XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="f8e8a-114">For more information, see [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
### <a name="structures"></a><span data-ttu-id="f8e8a-115">Estructuras</span><span class="sxs-lookup"><span data-stu-id="f8e8a-115">Structures</span></span>  
 <span data-ttu-id="f8e8a-116">Las estructuras siempre pueden crearse en XAML, por definición de CLR.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="f8e8a-117">Esto es porque un compilador CLR crea implícitamente un constructor predeterminado para una estructura.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-117">This is because a CLR compiler implicitly creates a default constructor for a structure.</span></span> <span data-ttu-id="f8e8a-118">Este constructor inicializa todos los valores de propiedad en sus valores predeterminados.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-118">This constructor initializes all property values to their defaults.</span></span>  
  
 <span data-ttu-id="f8e8a-119">En algunos casos, el comportamiento predeterminado de la construcción de una estructura no es deseable.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="f8e8a-120">Esto podría deberse a que la estructura está pensada para rellenar los valores y la función conceptualmente como una unión.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="f8e8a-121">Como una unión, los valores contenidos podrían tener interpretaciones mutuamente excluyentes y, por lo tanto, ninguna de sus propiedades son configurable.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="f8e8a-122">Un ejemplo de este tipo de estructura en el vocabulario de WPF es <xref:System.Windows.GridLength>.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="f8e8a-123">Estas estructuras deben implementar un convertidor de tipos para que los valores se pueden expresar en forma de atributo usando las convenciones de cadena que crean las diferentes interpretaciones o modos de los valores de la estructura.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="f8e8a-124">La estructura también debería exponer un comportamiento similar por la construcción del código a través de un constructor no predeterminado.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-124">The structure should also expose similar behavior for code construction through a non-default constructor.</span></span>  
  
### <a name="interfaces"></a><span data-ttu-id="f8e8a-125">Interfaces</span><span class="sxs-lookup"><span data-stu-id="f8e8a-125">Interfaces</span></span>  
 <span data-ttu-id="f8e8a-126">Interfaces pueden usarse como tipos subyacentes de miembros.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="f8e8a-127">El sistema de tipos XAML comprueba la lista asignable y espera que el objeto que se proporciona como el valor puede asignarse a la interfaz.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="f8e8a-128">No hay ningún concepto de cómo la interfaz debe presentarse como un tipo XAML como un tipo asignable pertinente admita los requisitos de construcción de XAML.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>  
  
### <a name="factory-methods"></a><span data-ttu-id="f8e8a-129">Métodos de generador</span><span class="sxs-lookup"><span data-stu-id="f8e8a-129">Factory Methods</span></span>  
 <span data-ttu-id="f8e8a-130">Métodos de generador son una característica de XAML 2009.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="f8e8a-131">Modifican el principio XAML que los objetos deben tener constructores predeterminados.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-131">They modify the XAML principle that objects must have default constructors.</span></span> <span data-ttu-id="f8e8a-132">Métodos de generador no se documentan en este tema.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-132">Factory methods are not documented in this topic.</span></span> <span data-ttu-id="f8e8a-133">Vea [x: FactoryMethod (directiva)](../../../docs/framework/xaml-services/x-factorymethod-directive.md).</span><span class="sxs-lookup"><span data-stu-id="f8e8a-133">See [x:FactoryMethod Directive](../../../docs/framework/xaml-services/x-factorymethod-directive.md).</span></span>  
  
## <a name="enumerations"></a><span data-ttu-id="f8e8a-134">Enumeraciones</span><span class="sxs-lookup"><span data-stu-id="f8e8a-134">Enumerations</span></span>  
 <span data-ttu-id="f8e8a-135">Las enumeraciones tienen el comportamiento de conversión de tipo nativo de XAML.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="f8e8a-136">Nombres de constantes de enumeración especificados en XAML se resuelven en el tipo de enumeración subyacente y devuelven el valor de enumeración a un escritor de objetos XAML.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>  
  
 <span data-ttu-id="f8e8a-137">XAML admite el uso de estilo de marcas para las enumeraciones con <xref:System.FlagsAttribute> aplicado.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="f8e8a-138">Para obtener más información, consulte [XAML Syntax In Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span><span class="sxs-lookup"><span data-stu-id="f8e8a-138">For more information, see [XAML Syntax In Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="f8e8a-139">([XAML Syntax In Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md) se ha diseñado para la audiencia WPF, pero la mayor parte de la información de ese tema es pertinente para XAML que no es específico de un marco de trabajo de implementación concreto.)</span><span class="sxs-lookup"><span data-stu-id="f8e8a-139">([XAML Syntax In Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>  
  
## <a name="member-definitions"></a><span data-ttu-id="f8e8a-140">Definiciones de miembros</span><span class="sxs-lookup"><span data-stu-id="f8e8a-140">Member Definitions</span></span>  
 <span data-ttu-id="f8e8a-141">Los tipos pueden definir a miembros para el uso XAML.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="f8e8a-142">Es posible para los tipos que definen a los miembros que se pueden utilizar XAML aunque ese tipo específico no esté XAML utilizable.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-142">It is possible for types that define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="f8e8a-143">Esto es posible debido a la herencia de CLR.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="f8e8a-144">Siempre y cuando algún tipo que hereda al miembro es compatible con el uso XAML como un tipo y el miembro admite el uso XAML para su tipo subyacente o tiene una sintaxis XAML nativo disponible, ese miembro es XAML utilizable.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>  
  
### <a name="properties"></a><span data-ttu-id="f8e8a-145">Propiedades</span><span class="sxs-lookup"><span data-stu-id="f8e8a-145">Properties</span></span>  
 <span data-ttu-id="f8e8a-146">Si define propiedades como una propiedad pública de CLR mediante CLR típico `get` y `set` correspondiente al lenguaje, las palabras clave y los patrones de descriptor de acceso, el sistema de tipos XAML puede notificar la propiedad como un miembro con la información correspondiente se proporciona para <xref:System.Xaml.XamlMember> propiedades, como <xref:System.Xaml.XamlMember.IsReadPublic%2A> y <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>  
  
 <span data-ttu-id="f8e8a-147">Propiedades concretas pueden habilitar una sintaxis de texto aplicando <xref:System.ComponentModel.TypeConverterAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="f8e8a-148">Para obtener más información, consulte [convertidores de tipos y extensiones de marcado para XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="f8e8a-148">For more information, see [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
 <span data-ttu-id="f8e8a-149">En ausencia de una sintaxis de texto o la conversión de XAML nativa y en ausencia de más direccionamiento indirecto, como el uso de una extensión de marcado, el tipo de una propiedad (<xref:System.Xaml.XamlMember.TargetType%2A> sistema de tipos en el código XAML) debe ser capaz de devolver una instancia a un escritor de objetos XAML tratando el t tipo de arget como un tipo CLR.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>  
  
 <span data-ttu-id="f8e8a-150">Si utiliza XAML 2009, [extensión de marcado x: Reference](../../../docs/framework/xaml-services/x-reference-markup-extension.md) puede usarse para proporcionar valores si no se cumplen las consideraciones anteriores; sin embargo, que es más de un problema de uso de un problema de definición de tipo.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-150">If using XAML 2009, [x:Reference Markup Extension](../../../docs/framework/xaml-services/x-reference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>  
  
### <a name="events"></a><span data-ttu-id="f8e8a-151">Eventos</span><span class="sxs-lookup"><span data-stu-id="f8e8a-151">Events</span></span>  
 <span data-ttu-id="f8e8a-152">Si define los eventos como un evento CLR público, el sistema de tipos XAML puede notificar el evento como un miembro con <xref:System.Xaml.XamlMember.IsEvent%2A> como `true`.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="f8e8a-153">Cableado de los controladores de eventos no está dentro del ámbito de las capacidades de servicios XAML de .NET Framework; Esto se deja para las implementaciones y marcos de trabajo específicos.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-153">Wiring the event handlers is not within the scope of .NET Framework XAML Services capabilities; this is left to specific frameworks and implementations.</span></span>  
  
### <a name="methods"></a><span data-ttu-id="f8e8a-154">Métodos</span><span class="sxs-lookup"><span data-stu-id="f8e8a-154">Methods</span></span>  
 <span data-ttu-id="f8e8a-155">Código en línea para los métodos no es una capacidad XAML de forma predeterminada.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="f8e8a-156">En la mayoría de los casos no haga referencia directamente los miembros de método desde XAML y el rol de métodos en XAML es solo proporcionar compatibilidad con modelos de XAML concretos.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-156">In most cases you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="f8e8a-157">[x: FactoryMethod (directiva)](../../../docs/framework/xaml-services/x-factorymethod-directive.md) es una excepción.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-157">[x:FactoryMethod Directive](../../../docs/framework/xaml-services/x-factorymethod-directive.md) is an exception.</span></span>  
  
### <a name="fields"></a><span data-ttu-id="f8e8a-158">Campos</span><span class="sxs-lookup"><span data-stu-id="f8e8a-158">Fields</span></span>  
 <span data-ttu-id="f8e8a-159">Instrucciones de diseño CLR desaconsejar campos no estáticos.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="f8e8a-160">Para los campos estáticos, puede tener acceso a valores de campo estático solo mediante [extensión de marcado x: Static](../../../docs/framework/xaml-services/x-static-markup-extension.md); en este caso, no realiza ninguna acción especial en la definición de CLR para exponer un campo para [x: Static](../../../docs/framework/xaml-services/x-static-markup-extension.md) usos.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-160">For static fields, you can access static field values only through [x:Static Markup Extension](../../../docs/framework/xaml-services/x-static-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](../../../docs/framework/xaml-services/x-static-markup-extension.md) usages.</span></span>  
  
## <a name="attachable-members"></a><span data-ttu-id="f8e8a-161">Miembros adjuntables</span><span class="sxs-lookup"><span data-stu-id="f8e8a-161">Attachable Members</span></span>  
 <span data-ttu-id="f8e8a-162">Los miembros adjuntables se exponen a XAML a través de un patrón de método de descriptor de acceso en un tipo de definición.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="f8e8a-163">El propio tipo de definición no es necesario que se pueda usar XAML como un objeto.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="f8e8a-164">De hecho, un patrón común es declarar una clase de servicio cuya función es el propietario del miembro adjuntable e implementar comportamientos relacionados, pero no sirven ninguna otra función como una representación de la interfaz de usuario.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="f8e8a-165">Para las siguientes secciones, el marcador de posición *PropertyName* representa el nombre del miembro adjuntable.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="f8e8a-166">Este nombre debe ser válido en el [XamlName (gramática)](../../../docs/framework/xaml-services/xamlname-grammar.md).</span><span class="sxs-lookup"><span data-stu-id="f8e8a-166">That name must be valid in the [XamlName Grammar](../../../docs/framework/xaml-services/xamlname-grammar.md).</span></span>  
  
 <span data-ttu-id="f8e8a-167">Tenga cuidado de conflictos de nombres entre estos modelos y otros métodos de un tipo.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="f8e8a-168">Si existe un miembro que coincide con uno de los modelos, se puede interpretar como una ruta de uso del miembro adjuntable con un procesador XAML aunque no era su intención.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>  
  
#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="f8e8a-169">El descriptor de acceso GetPropertyName</span><span class="sxs-lookup"><span data-stu-id="f8e8a-169">The GetPropertyName Accessor</span></span>  
 <span data-ttu-id="f8e8a-170">La signatura del descriptor de acceso `Get`*NombreDePropiedad* debe ser:</span><span class="sxs-lookup"><span data-stu-id="f8e8a-170">The signature for the `Get`*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="f8e8a-171">`public static object Get` *NombreDePropiedad* `(object`  `target` `)`</span><span class="sxs-lookup"><span data-stu-id="f8e8a-171">`public static object Get` *PropertyName* `(object`  `target` `)`</span></span>  
  
-   <span data-ttu-id="f8e8a-172">El objeto `target` puede especificarse como un tipo más específico en la implementación.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-172">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="f8e8a-173">Ya puede utilizarla para definir el ámbito del uso del miembro adjuntable; usos fuera del ámbito deseado producirán excepciones de conversión no válida que se exponen a través de un error de análisis XAML.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-173">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="f8e8a-174">El nombre del parámetro `target` no es un requisito, pero se denomina `target` por convención en la mayoría de las implementaciones.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-174">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>  
  
-   <span data-ttu-id="f8e8a-175">El valor devuelto puede especificarse como un tipo más específico en la implementación.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-175">The return value can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="f8e8a-176">Para admitir un <xref:System.ComponentModel.TypeConverter> sintaxis de texto habilitada para el uso de atributos del miembro adjuntable, aplicar <xref:System.ComponentModel.TypeConverterAttribute> a la `Get` *PropertyName* descriptor de acceso.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-176">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get`*PropertyName* accessor.</span></span> <span data-ttu-id="f8e8a-177">Aplicar a la `get` en lugar de la `set` puede parecer intuitivo; sin embargo, esta convención puede admitir el concepto de solo lectura que se puede asociar los miembros que son serializables, lo que resulta útil en escenarios del diseñador.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-177">Applying to the `get` instead of the `set` may seem nonintuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>  
  
#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="f8e8a-178">El descriptor de acceso SetPropertyName</span><span class="sxs-lookup"><span data-stu-id="f8e8a-178">The SetPropertyName Accessor</span></span>  
 <span data-ttu-id="f8e8a-179">La firma para el conjunto de*PropertyName* descriptor de acceso debe ser:</span><span class="sxs-lookup"><span data-stu-id="f8e8a-179">The signature for the Set*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="f8e8a-180">`public static void Set` *NombreDePropiedad* `(object`  `target` `, object`  `value` `)`</span><span class="sxs-lookup"><span data-stu-id="f8e8a-180">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span></span>  
  
-   <span data-ttu-id="f8e8a-181">La `target` objeto puede especificarse como un tipo más específico en la implementación, con la misma lógica y consecuencias tal y como se describe en la sección anterior.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-181">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>  
  
-   <span data-ttu-id="f8e8a-182">El objeto `value` puede especificarse como un tipo más específico en la implementación.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-182">The `value` object can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="f8e8a-183">Recuerde que el valor de este método es la entrada procedente del uso de XAML, normalmente en forma de atributo.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-183">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="f8e8a-184">De forma de atributo debe ser compatibles con la conversión de valor para una sintaxis de texto y atributo en la `Get` *PropertyName* descriptor de acceso.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-184">From attribute form there must be value converter support for a text syntax, and you attribute on the `Get`*PropertyName* accessor.</span></span>  
  
### <a name="attachable-member-stores"></a><span data-ttu-id="f8e8a-185">Almacenes de miembro adjuntable</span><span class="sxs-lookup"><span data-stu-id="f8e8a-185">Attachable Member Stores</span></span>  
 <span data-ttu-id="f8e8a-186">Los métodos de descriptor de acceso normalmente no son suficientes para proporcionar un medio para situar los valores de miembro adjuntable en un gráfico de objetos, o para recuperar los valores del gráfico de objetos y serializarlos correctamente.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-186">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="f8e8a-187">Para proporcionar esta funcionalidad, la `target` objetos en las firmas de descriptor de acceso anterior deben ser capaces de almacenar valores.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-187">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="f8e8a-188">El mecanismo de almacenamiento debe ser coherente con el principio del miembro adjuntable que el miembro es que se puede asociar a los destinos donde el miembro adjuntable no está en la lista de miembros.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-188">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="f8e8a-189">Servicios XAML de .NET framework proporciona una técnica de implementación para el miembro adjuntable almacena a través de la API <xref:System.Xaml.IAttachedPropertyStore> y <xref:System.Xaml.AttachablePropertyServices>.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-189">.NET Framework XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="f8e8a-190"><xref:System.Xaml.IAttachedPropertyStore>se usa por los escritores XAML para detectar la implementación del almacén y deben implementarse en el tipo que es el `target` de los descriptores de acceso.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-190"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="f8e8a-191">El método estático <xref:System.Xaml.AttachablePropertyServices> API se utilizan dentro del cuerpo de los descriptores de acceso y hacer referencia al miembro adjuntable por su <xref:System.Xaml.AttachableMemberIdentifier>.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-191">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>  
  
## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="f8e8a-192">Atributos CLR relacionados con XAML</span><span class="sxs-lookup"><span data-stu-id="f8e8a-192">XAML-Related CLR Attributes</span></span>  
 <span data-ttu-id="f8e8a-193">Atribución correctamente sus tipos, miembros y ensamblados es importante para notificar información del sistema de tipo XAML a los servicios XAML de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-193">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET Framework XAML Services.</span></span> <span data-ttu-id="f8e8a-194">Esto es importante si piensa que los tipos para su uso con los sistemas de XAML directamente se basan en lectores de servicios XAML de .NET Framework y escritores XAML, o si define o usar un marco de uso de XAML que se basa en los lectores XAML y escritores de XAML.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-194">This is relevant if you intend your types for use with XAML systems that are directly based on .NET Framework XAML Services XAML readers and XAML writers, or if you define or use a XAML-utilizing framework that is based on those XAML readers and XAML writers.</span></span>  
  
 <span data-ttu-id="f8e8a-195">Para obtener una lista de cada atributo relacionados con XAML que es relevante para la compatibilidad XAML de sus tipos personalizados, vea [Related CLR atributos para tipos y bibliotecas personalizados](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span><span class="sxs-lookup"><span data-stu-id="f8e8a-195">For a listing of each XAML-related attribute that is relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span></span>  
  
## <a name="usage"></a><span data-ttu-id="f8e8a-196">Uso</span><span class="sxs-lookup"><span data-stu-id="f8e8a-196">Usage</span></span>  
 <span data-ttu-id="f8e8a-197">Uso de tipos personalizados requiere que el autor de marcado debe asignar un prefijo para el ensamblado y el espacio de nombres CLR que contienen el tipo personalizado.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="f8e8a-198">Este procedimiento no está documentado en este tema.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-198">This procedure is not documented in this topic.</span></span>  
  
## <a name="access-level"></a><span data-ttu-id="f8e8a-199">Nivel de acceso</span><span class="sxs-lookup"><span data-stu-id="f8e8a-199">Access Level</span></span>  
 <span data-ttu-id="f8e8a-200">XAML proporciona un medio para cargar y crear instancias de tipos que tienen un `internal` nivel de acceso.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="f8e8a-201">Esta funcionalidad se proporciona para que el código de usuario puede definir sus propios tipos y, a continuación, crear instancias de esas clases desde el marcado que también forma parte del mismo ámbito de código de usuario.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>  
  
 <span data-ttu-id="f8e8a-202">Un ejemplo de WPF es cada vez que el código de usuario define un <xref:System.Windows.Controls.UserControl> que sirve como una manera de refactorizar un comportamiento de la interfaz de usuario, pero no como parte de cualquier mecanismo de extensión posibles que se puede deducir mediante la declaración de la clase de compatibilidad con `public` nivel de acceso.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="f8e8a-203">Este tipo una <xref:System.Windows.Controls.UserControl> se pueden declarar con `internal` acceso si se compila el código auxiliar en el mismo ensamblado desde el que se hace referencia como un tipo XAML.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>  
  
 <span data-ttu-id="f8e8a-204">Para una aplicación que carga el XAML con plena confianza y usa <xref:System.Xaml.XamlObjectWriter>, cargar clases con `internal` siempre está habilitado el nivel de acceso.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>  
  
 <span data-ttu-id="f8e8a-205">Para una aplicación que carga el XAML con confianza parcial, puede controlar las características de nivel de acceso mediante el <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="f8e8a-206">Además, debe tener propagar los permisos de nivel de acceso y los conserva para las evaluaciones de tiempo de ejecución eventual; mecanismos de aplazamiento (por ejemplo, el sistema de plantilla WPF) Esto se controla internamente pasando el <xref:System.Xaml.Permissions.XamlAccessLevel> información.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>  
  
### <a name="wpf-implementation"></a><span data-ttu-id="f8e8a-207">Implementación de WPF</span><span class="sxs-lookup"><span data-stu-id="f8e8a-207">WPF Implementation</span></span>  
 <span data-ttu-id="f8e8a-208">XAML de WPF usa un modelo de acceso de confianza parcial donde si BAML se carga bajo confianza parcial, el acceso está restringido a <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> para el ensamblado que es el origen BAML.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="f8e8a-209">Para el aplazamiento, WPF utiliza <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> como un mecanismo para pasar la información de nivel de acceso.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>  
  
 <span data-ttu-id="f8e8a-210">En la terminología de XAML de WPF, un *tipo interno* es un tipo definido por el mismo ensamblado que también incluye el archivo XAML de referencia.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="f8e8a-211">Estos tipos pueden asignarse a través de un espacio de nombres XAML que omite deliberadamente el ensamblado = parte de una asignación, por ejemplo, `xmlns:local="clr-namespace:WPFApplication1"`.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span>  <span data-ttu-id="f8e8a-212">Si BAML hace referencia a un tipo interno y que tiene el tipo `internal` tener acceso a nivel de esta forma se genera un `GeneratedInternalTypeHelper` clase del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="f8e8a-213">Si desea evitar `GeneratedInternalTypeHelper`, ya sea debe usar `public` acceso a nivel de, o debe separe la clase relevante en un ensamblado independiente y hacer que ese ensamblado dependiente.</span><span class="sxs-lookup"><span data-stu-id="f8e8a-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f8e8a-214">Vea también</span><span class="sxs-lookup"><span data-stu-id="f8e8a-214">See Also</span></span>  
 [<span data-ttu-id="f8e8a-215">Atributos de CLR relacionados con XAML para los tipos y bibliotecas personalizados</span><span class="sxs-lookup"><span data-stu-id="f8e8a-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md)  
 [<span data-ttu-id="f8e8a-216">Servicios XAML</span><span class="sxs-lookup"><span data-stu-id="f8e8a-216">XAML Services</span></span>](../../../docs/framework/xaml-services/index.md)
