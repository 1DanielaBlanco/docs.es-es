---
title: Novedades de Visual Basic
ms.date: 2017-04-27
ms.prod: .net
ms.technology:
- devlang-visual-basic
ms.topic: article
f1_keywords:
- VB.StartPage.WhatsNew
dev_langs:
- VB
helpviewer_keywords:
- new features, Visual Basic
- what's new [Visual Basic]
- Visual Basic, what's new
ms.assetid: d7e97396-7f42-4873-a81c-4ebcc4b6ca02
caps.latest.revision: 145
author: rpetrusha
ms.author: ronpet
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
ms.translationtype: HT
ms.sourcegitcommit: 306c608dc7f97594ef6f72ae0f5aaba596c936e1
ms.openlocfilehash: 0a9379d5dd2d1c6b3ed6820e350c19fb346ac84c
ms.contentlocale: es-es
ms.lasthandoff: 07/28/2017

---
# <a name="whats-new-for-visual-basic"></a><span data-ttu-id="dd645-102">Novedades de Visual Basic</span><span class="sxs-lookup"><span data-stu-id="dd645-102">What's new for Visual Basic</span></span>

<span data-ttu-id="dd645-103">En este tema se enumeran los nombres de las características clave de cada versión de Visual Basic con descripciones detalladas de las características nuevas y mejoradas de la versión más reciente del lenguaje.</span><span class="sxs-lookup"><span data-stu-id="dd645-103">This topic lists key feature names for each version of Visual Basic, with detailed descriptions of the new and enhanced features in the lastest version of the language.</span></span>
  
## <a name="current-version"></a><span data-ttu-id="dd645-104">Versión actual</span><span class="sxs-lookup"><span data-stu-id="dd645-104">Current Version</span></span>

<span data-ttu-id="dd645-105">Visual Basic / Visual Studio .NET 2017</span><span class="sxs-lookup"><span data-stu-id="dd645-105">Visual Basic / Visual Studio .NET 2017</span></span>   
<span data-ttu-id="dd645-106">Para obtener características nuevas, vea [Visual Basic 2017](#visual-basic-2017).</span><span class="sxs-lookup"><span data-stu-id="dd645-106">For new features, see [Visual Basic 2017](#visual-basic-2017)</span></span>

## <a name="previous-versions"></a><span data-ttu-id="dd645-107">Versiones anteriores</span><span class="sxs-lookup"><span data-stu-id="dd645-107">Previous versions</span></span>

<span data-ttu-id="dd645-108">Visual Basic / Visual Studio .NET 2015</span><span class="sxs-lookup"><span data-stu-id="dd645-108">Visual Basic / Visual Studio .NET 2015</span></span>   
<span data-ttu-id="dd645-109">Para obtener características nuevas, vea [Visual Basic 14](#visual-basic-14).</span><span class="sxs-lookup"><span data-stu-id="dd645-109">For new features, see [Visual Basic 14](#visual-basic-14)</span></span>

<span data-ttu-id="dd645-110">Visual Basic / Visual Studio .NET 2013</span><span class="sxs-lookup"><span data-stu-id="dd645-110">Visual Basic / Visual Studio .NET 2013</span></span>  
<span data-ttu-id="dd645-111">Vistas previas de tecnología de .NET Compiler Platform ("Roslyn")</span><span class="sxs-lookup"><span data-stu-id="dd645-111">Technology previews of the .NET Compiler Platform (“Roslyn”)</span></span>

<span data-ttu-id="dd645-112">Visual Basic / Visual Studio .NET 2012</span><span class="sxs-lookup"><span data-stu-id="dd645-112">Visual Basic / Visual Studio .NET 2012</span></span>   
<span data-ttu-id="dd645-113">palabras clave `Async` y `await`, iteradores, atributos de información de autor de llamada</span><span class="sxs-lookup"><span data-stu-id="dd645-113">`Async` and `await` keywords, iterators, caller info attributes</span></span>

<span data-ttu-id="dd645-114">Visual Basic / Visual Studio .NET 2010</span><span class="sxs-lookup"><span data-stu-id="dd645-114">Visual Basic, Visual Studio .NET 2010</span></span>   
<span data-ttu-id="dd645-115">Propiedades autoimplementadas, inicializadores de colección, continuación de línea implícita, dinámica, covarianza/contravarianza genérica, acceso de espacio de nombres global</span><span class="sxs-lookup"><span data-stu-id="dd645-115">Auto-implemented properties, collection initializers, implicit line continuation, dynamic, generic co/contra variance, global namespace access</span></span>

<span data-ttu-id="dd645-116">Visual Basic / Visual Studio .NET 2008</span><span class="sxs-lookup"><span data-stu-id="dd645-116">Visual Basic / Visual Studio .NET 2008</span></span>   
<span data-ttu-id="dd645-117">Language Integrated Query (LINQ), literales XML, inferencia de tipo de variable local, inicializadores de objeto, tipos anónimos, métodos de extensión, inferencia de tipo de variable local `var`, expresiones lambda, operador `if`, métodos parciales, tipos de valor que aceptan valores null</span><span class="sxs-lookup"><span data-stu-id="dd645-117">Language Integrated Query (LINQ), XML literals, local type inference, object initializers, anonymous types, extension methods, local `var` type inference, lambda expressions, `if` operator, partial methods, nullable value types</span></span>  

<span data-ttu-id="dd645-118">Visual Basic / Visual Studio .NET 2005</span><span class="sxs-lookup"><span data-stu-id="dd645-118">Visual Basic / Visual Studio .NET 2005</span></span>   
<span data-ttu-id="dd645-119">El tipo `My` y tipos auxiliares (acceso a la aplicación, equipo, sistema de archivos, red)</span><span class="sxs-lookup"><span data-stu-id="dd645-119">The `My` type and helper types (access to app, computer, files system, network)</span></span>

<span data-ttu-id="dd645-120">Visual Basic / Visual Studio .NET 2003</span><span class="sxs-lookup"><span data-stu-id="dd645-120">Visual Basic / Visual Studio .NET 2003</span></span>   
<span data-ttu-id="dd645-121">Operadores de desplazamiento de bits, declaración de variable de bucle</span><span class="sxs-lookup"><span data-stu-id="dd645-121">Bit-shift operators, loop variable declaration</span></span>

<span data-ttu-id="dd645-122">Visual Basic / Visual Studio .NET 2002</span><span class="sxs-lookup"><span data-stu-id="dd645-122">Visual Basic / Visual Studio .NET 2002</span></span>   
<span data-ttu-id="dd645-123">La primera versión de Visual Basic .NET</span><span class="sxs-lookup"><span data-stu-id="dd645-123">The first release of Visual Basic .NET</span></span>

## <a name="visual-basic-2017"></a><span data-ttu-id="dd645-124">Visual Basic 2017</span><span class="sxs-lookup"><span data-stu-id="dd645-124">Visual Basic 2017</span></span>

[<span data-ttu-id="dd645-125">Tuplas</span><span class="sxs-lookup"><span data-stu-id="dd645-125">Tuples</span></span>](../programming-guide/language-features/data-types/tuples.md)

<span data-ttu-id="dd645-126">Las tuplas son una estructura de datos ligera que se usan normalmente para devolver varios valores de una sola llamada al método.</span><span class="sxs-lookup"><span data-stu-id="dd645-126">Tuples are a lightweight data structure that most commonly is used to return multiple values from a single method call.</span></span> <span data-ttu-id="dd645-127">Normalmente, para devolver varios valores de un método, tiene que realizar una de las siguientes acciones:</span><span class="sxs-lookup"><span data-stu-id="dd645-127">Ordinarily, to return multiple values from a method, you have to do one of the following:</span></span>

- <span data-ttu-id="dd645-128">Definir un tipo personalizado (`Class` o `Structure`).</span><span class="sxs-lookup"><span data-stu-id="dd645-128">Define a custom type (a `Class` or a `Structure`).</span></span> <span data-ttu-id="dd645-129">Esta es una solución pesada.</span><span class="sxs-lookup"><span data-stu-id="dd645-129">This is a heavyweight solution.</span></span>

- <span data-ttu-id="dd645-130">Definir uno o más parámetros `ByRef`, además de devolver un valor del método.</span><span class="sxs-lookup"><span data-stu-id="dd645-130">Define one or more `ByRef` parameters, in addition to returning a value from the method.</span></span>
 
<span data-ttu-id="dd645-131">La compatibilidad de Visual Basic con las tuplas le permite definir rápidamente una tupla, asignar opcionalmente nombres semánticos a sus valores y recuperar sus valores rápidamente.</span><span class="sxs-lookup"><span data-stu-id="dd645-131">Visual Basic's support for tuples lets you quickly define a tuple, optionally assign semantic names to its values, and quickly retrieve its values.</span></span> <span data-ttu-id="dd645-132">En el ejemplo siguiente se ajusta una llamada al método <xref:System.Int32.TryParse%2A> y se devuelve una tupla.</span><span class="sxs-lookup"><span data-stu-id="dd645-132">The following example wraps a call to the <xref:System.Int32.TryParse%2A> method and returns a tuple.</span></span>

<span data-ttu-id="dd645-133">[!code-vb[Tuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]</span><span class="sxs-lookup"><span data-stu-id="dd645-133">[!code-vb[Tuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]</span></span>

<span data-ttu-id="dd645-134">Después, puede llamar al método y controlar la tupla devuelta con código como el siguiente.</span><span class="sxs-lookup"><span data-stu-id="dd645-134">You can then call the method and handle the returned tuple with code like the following.</span></span>

<span data-ttu-id="dd645-135">[!code-vb[ReturnTuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)]</span><span class="sxs-lookup"><span data-stu-id="dd645-135">[!code-vb[ReturnTuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)]</span></span> 

<span data-ttu-id="dd645-136">**Literales binarios y separadores de dígitos**</span><span class="sxs-lookup"><span data-stu-id="dd645-136">**Binary literals and digit separators**</span></span>

<span data-ttu-id="dd645-137">Puede definir un literal binario con el prefijo `&B` o `&b`.</span><span class="sxs-lookup"><span data-stu-id="dd645-137">You can define a binary literal by using the prefix `&B` or `&b`.</span></span> <span data-ttu-id="dd645-138">Además, puede usar el carácter de subrayado, `_`, como un separador de dígitos para mejorar la legibilidad.</span><span class="sxs-lookup"><span data-stu-id="dd645-138">In addition, you can use the underscore character, `_`, as a digit separator to enhance readability.</span></span> <span data-ttu-id="dd645-139">En el ejemplo siguiente se usan ambas características para asignar un valor `Byte` y para mostrarlo como un número binario, hexadecimal y decimal.</span><span class="sxs-lookup"><span data-stu-id="dd645-139">The following example uses both features to assign a `Byte` value and to display it as a decimal, hexadecimal, and binary number.</span></span>

<span data-ttu-id="dd645-140">[!code-vb[Binary](../../../samples/snippets/visualbasic/getting-started/bin-example.vb#1)]</span><span class="sxs-lookup"><span data-stu-id="dd645-140">[!code-vb[Binary](../../../samples/snippets/visualbasic/getting-started/bin-example.vb#1)]</span></span>

<span data-ttu-id="dd645-141">Para obtener más información, vea la sección "Asignaciones literales" de los tipos de datos [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments) y [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments).</span><span class="sxs-lookup"><span data-stu-id="dd645-141">For more information, see the "Literal assignments" section of the [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments), and [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) data types.</span></span>

<span data-ttu-id="dd645-142">**Compatibilidad con los valores devueltos de referencia de C#**</span><span class="sxs-lookup"><span data-stu-id="dd645-142">**Support for C# reference return values**</span></span>

<span data-ttu-id="dd645-143">A partir de C# 7, C# admite los valores devueltos de referencia.</span><span class="sxs-lookup"><span data-stu-id="dd645-143">Starting with C# 7, C# supports reference return values.</span></span> <span data-ttu-id="dd645-144">Es decir, cuando el método de llamada recibe un valor devuelto mediante referencia, puede cambiar el valor de esta.</span><span class="sxs-lookup"><span data-stu-id="dd645-144">That is, when the calling method receives a value returned by reference, it can change the value of the reference.</span></span> <span data-ttu-id="dd645-145">Visual Basic no le permite crear métodos con valores devueltos de referencia, pero le permite consumirlos y modificarlos.</span><span class="sxs-lookup"><span data-stu-id="dd645-145">Visual Basic does not allow you to author methods with reference return values, but it does allow you to consume and modify the reference return values.</span></span>

<span data-ttu-id="dd645-146">Por ejemplo, la siguiente clase `Sentence` escrita en C# incluye un método `FindNext` que busca la siguiente palabra de una frase que comienza por una subcadena especificada.</span><span class="sxs-lookup"><span data-stu-id="dd645-146">For example, the following `Sentence` class written in C# includes a `FindNext` method that finds the next word in a sentence that begins with a specified substring.</span></span> <span data-ttu-id="dd645-147">La cadena se devuelve como un valor devuelto de referencia, y una variable `Boolean` que se ha pasado mediante referencia al método indica si la búsqueda se ha realizado correctamente.</span><span class="sxs-lookup"><span data-stu-id="dd645-147">The string is returned as a reference return value, and a `Boolean` variable passed by reference to the method indicates whether the search was successful.</span></span> <span data-ttu-id="dd645-148">Esto significa que el autor de la llamada no solo puede leer el valor devuelto; él o ella también puede modificarlo, y esa modificación se refleja en la clase `Sentence`.</span><span class="sxs-lookup"><span data-stu-id="dd645-148">This means that the caller can not only read the returned value; he or she can also modify it, and that modification is reflected in the `Sentence` class.</span></span>

<span data-ttu-id="dd645-149">[!code-csharp[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-returns.cs)]</span><span class="sxs-lookup"><span data-stu-id="dd645-149">[!code-csharp[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-returns.cs)]</span></span>

<span data-ttu-id="dd645-150">En su forma más sencilla, puede modificar la palabra que se ha encontrado en la frase con código como el que se muestra a continuación.</span><span class="sxs-lookup"><span data-stu-id="dd645-150">In its simplest form, you can modify the word found in the sentence by using code like the following.</span></span> <span data-ttu-id="dd645-151">Tenga en cuenta que no está asignando un valor al método, sino a la expresión que devuelve el método, que es el valor devuelto de referencia.</span><span class="sxs-lookup"><span data-stu-id="dd645-151">Note that you are not assigning a value to the method, but rather to the expression that the method returns, which is the reference return value.</span></span>

<span data-ttu-id="dd645-152">[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#1)]</span><span class="sxs-lookup"><span data-stu-id="dd645-152">[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#1)]</span></span>

<span data-ttu-id="dd645-153">En cambio, un problema con este código es que si no se detecta una coincidencia, el método devuelve la primera palabra.</span><span class="sxs-lookup"><span data-stu-id="dd645-153">A problem with this code, though, is that if a match is not found, the method returns the first word.</span></span> <span data-ttu-id="dd645-154">Como el ejemplo no examina el valor del argumento `Boolean` para determinar si se detecta una coincidencia, modifica la primera palabra si no hay ninguna.</span><span class="sxs-lookup"><span data-stu-id="dd645-154">Since the example does not examine the value of the `Boolean` argument to determine whether a match is found, it modifies the first word if there is no match.</span></span> <span data-ttu-id="dd645-155">En el ejemplo siguiente se corrige esto reemplazando la primera palabra por ella misma si no existe ninguna coincidencia.</span><span class="sxs-lookup"><span data-stu-id="dd645-155">The following example corrects this by replacing the first word with itself if there is no match.</span></span>

<span data-ttu-id="dd645-156">[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#2)]</span><span class="sxs-lookup"><span data-stu-id="dd645-156">[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#2)]</span></span>

<span data-ttu-id="dd645-157">Una solución mejor es usar un método auxiliar en el que el valor devuelto de referencia se pase mediante una referencia.</span><span class="sxs-lookup"><span data-stu-id="dd645-157">A better solution is to use a helper method to which the reference return value is passed by reference.</span></span> <span data-ttu-id="dd645-158">El método auxiliar puede después modificar el argumento que se ha pasado por referencia.</span><span class="sxs-lookup"><span data-stu-id="dd645-158">The helper method can then modify the argument passed to it by reference.</span></span> <span data-ttu-id="dd645-159">En el siguiente ejemplo se realiza esto.</span><span class="sxs-lookup"><span data-stu-id="dd645-159">The following example does that.</span></span>

<span data-ttu-id="dd645-160">[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return-helper.vb#1)]</span><span class="sxs-lookup"><span data-stu-id="dd645-160">[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return-helper.vb#1)]</span></span>

<span data-ttu-id="dd645-161">Para obtener más información, vea [Valores devueltos de referencia](../programming-guide/language-features/procedures/ref-return-values.md).</span><span class="sxs-lookup"><span data-stu-id="dd645-161">For more information, see [Reference Return Values](../programming-guide/language-features/procedures/ref-return-values.md).</span></span>

## <a name="visual-basic-14"></a><span data-ttu-id="dd645-162">Visual Basic 14</span><span class="sxs-lookup"><span data-stu-id="dd645-162">Visual Basic 14</span></span>

[<span data-ttu-id="dd645-163">Nameof</span><span class="sxs-lookup"><span data-stu-id="dd645-163">Nameof</span></span>](../../csharp/language-reference/keywords/nameof.md)  
 <span data-ttu-id="dd645-164">Puede obtener el nombre de cadena no calificado de un tipo o miembro para usarlo en un mensaje de error sin codificar de forma rígida una cadena.</span><span class="sxs-lookup"><span data-stu-id="dd645-164">You can get the unqualified string name of a type or member for use in an error message without hard coding a string.</span></span>  <span data-ttu-id="dd645-165">Esto permite que el código siga siendo correcto al refactorizarlo.</span><span class="sxs-lookup"><span data-stu-id="dd645-165">This allows your code to remain correct when refactoring.</span></span>  <span data-ttu-id="dd645-166">Esta característica también es útil para enlazar los vínculos MVC del controlador de vista de modelos y desencadenar eventos de propiedad cambiada.</span><span class="sxs-lookup"><span data-stu-id="dd645-166">This feature is also useful for hooking up model-view-controller MVC links and firing property changed events.</span></span>  
  
[<span data-ttu-id="dd645-167">Interpolación de cadenas</span><span class="sxs-lookup"><span data-stu-id="dd645-167">String Interpolation</span></span>](../../csharp/language-reference/keywords/interpolated-strings.md)  
 <span data-ttu-id="dd645-168">Puede usar expresiones de interpolación de cadenas para construir cadenas.</span><span class="sxs-lookup"><span data-stu-id="dd645-168">You can use string interpolation expressions to construct strings.</span></span>  <span data-ttu-id="dd645-169">Una expresión de cadena interpolada es similar a una cadena de plantilla que contiene expresiones.</span><span class="sxs-lookup"><span data-stu-id="dd645-169">An interpolated string expression looks like a template string that contains expressions.</span></span>  <span data-ttu-id="dd645-170">Una cadena interpolada es más fácil de entender con respecto a los argumentos que el [formato compuesto](../../standard/base-types/composite-format.md).</span><span class="sxs-lookup"><span data-stu-id="dd645-170">An interpolated string is easier to understand with respect to arguments than [Composite Formatting](../../standard/base-types/composite-format.md).</span></span>  
  
[<span data-ttu-id="dd645-171">Acceso a miembros e indización condicional null</span><span class="sxs-lookup"><span data-stu-id="dd645-171">Null-conditional Member Access and Indexing</span></span>](../../csharp/language-reference/operators/null-conditional-operators.md)  
<span data-ttu-id="dd645-172">Puede probar si hay valores null de forma sintáctica ligera antes de realizar una operación de acceso a miembros (`?.`) o índice (`?[]`).</span><span class="sxs-lookup"><span data-stu-id="dd645-172">You can test for null in a very light syntactic way before performing a member access (`?.`) or index (`?[]`) operation.</span></span>  <span data-ttu-id="dd645-173">Estos operadores ayudan a escribir menos código para controlar las comprobaciones de null, especialmente para descender en estructuras de datos.</span><span class="sxs-lookup"><span data-stu-id="dd645-173">These operators help you write less code to handle null checks, especially for descending into data structures.</span></span>  <span data-ttu-id="dd645-174">Si la referencia de objeto u operando izquierdo es null, la operación devuelve null.</span><span class="sxs-lookup"><span data-stu-id="dd645-174">If the left operand or object reference is null, the operations returns null.</span></span>  
  
[<span data-ttu-id="dd645-175">Literales de cadena multilínea</span><span class="sxs-lookup"><span data-stu-id="dd645-175">Multi-line String Literals</span></span>](../../visual-basic/programming-guide/language-features/strings/string-basics.md)  
 <span data-ttu-id="dd645-176">Los literales de cadena pueden contener secuencias de nueva línea.</span><span class="sxs-lookup"><span data-stu-id="dd645-176">String literals can contain newline sequences.</span></span>  <span data-ttu-id="dd645-177">Ya no necesita la antigua solución alternativa que consistía en usar `<xml><![CDATA[...text with newlines...]]></xml>.Value`</span><span class="sxs-lookup"><span data-stu-id="dd645-177">You no longer need the old work around of using `<xml><![CDATA[...text with newlines...]]></xml>.Value`</span></span>  
  
<span data-ttu-id="dd645-178">Comentarios</span><span class="sxs-lookup"><span data-stu-id="dd645-178">Comments</span></span>  
<span data-ttu-id="dd645-179">Puede colocar comentarios después de las continuaciones de línea implícita, dentro de expresiones de inicializador y entre los términos de la expresión LINQ.</span><span class="sxs-lookup"><span data-stu-id="dd645-179">You can put comments after implicit line continuations, inside initializer expressions, and amongst LINQ expression terms.</span></span>  
  
 <span data-ttu-id="dd645-180">Resolución de nombres completos más inteligente</span><span class="sxs-lookup"><span data-stu-id="dd645-180">Smarter Fully-qualified Name Resolution</span></span>  
 <span data-ttu-id="dd645-181">Dado código como `Threading.Thread.Sleep(1000)`, Visual Basic solía buscar el espacio de nombres "Threading", detectaba ambigüedad entre System.Threading y System.Windows.Threading y, a continuación, notificaba un error.</span><span class="sxs-lookup"><span data-stu-id="dd645-181">Given code such as `Threading.Thread.Sleep(1000)`, Visual Basic used to look up the namespace "Threading", discover it was ambiguous between System.Threading and System.Windows.Threading, and then report an error.</span></span>  <span data-ttu-id="dd645-182">Ahora, Visual Basic considera juntos ambos espacios de nombres posibles.</span><span class="sxs-lookup"><span data-stu-id="dd645-182">Visual Basic now considers both possible namespaces together.</span></span>  <span data-ttu-id="dd645-183">Si aparece la lista de finalización, el editor de Visual Studio muestra los miembros de ambos tipos en la lista de finalización.</span><span class="sxs-lookup"><span data-stu-id="dd645-183">If you show the completion list, the Visual Studio editor lists members from both types in the completion list.</span></span>  
  
 <span data-ttu-id="dd645-184">Literales de fecha con el año en primer lugar</span><span class="sxs-lookup"><span data-stu-id="dd645-184">Year-first Date Literals</span></span>  
 <span data-ttu-id="dd645-185">Puede tener literales de fecha en el formato aaaa-mm-dd, `#2015-03-17 16:10 PM#`.</span><span class="sxs-lookup"><span data-stu-id="dd645-185">You can have date literals in yyyy-mm-dd format, `#2015-03-17 16:10 PM#`.</span></span>  
  
 <span data-ttu-id="dd645-186">Propiedades de interfaz de solo lectura</span><span class="sxs-lookup"><span data-stu-id="dd645-186">Readonly Interface Properties</span></span>  
 <span data-ttu-id="dd645-187">Puede implementar propiedades de interfaz de solo lectura mediante una propiedad de lectura y escritura.</span><span class="sxs-lookup"><span data-stu-id="dd645-187">You can implement readonly interface properties using a readwrite property.</span></span>  <span data-ttu-id="dd645-188">La interfaz garantiza una funcionalidad mínima y no impide que una clase de implementación pueda establecer la propiedad.</span><span class="sxs-lookup"><span data-stu-id="dd645-188">The interface guarantees minimum functionality, and it does not stop an implementing class from allowing the property to be set.</span></span>  
  
 [<span data-ttu-id="dd645-189">TypeOf \<expr> IsNot \<type></span><span class="sxs-lookup"><span data-stu-id="dd645-189">TypeOf \<expr> IsNot \<type></span></span>](../../visual-basic/language-reference/operators/typeof-operator.md)  
 <span data-ttu-id="dd645-190">Para mejorar la legibilidad del código, ahora puede usar `TypeOf` con `IsNot`.</span><span class="sxs-lookup"><span data-stu-id="dd645-190">For more readability of your code, you can now use `TypeOf` with `IsNot`.</span></span>  
  
 [<span data-ttu-id="dd645-191">#Disable Warning \<ID> y #Enable Warning \<ID></span><span class="sxs-lookup"><span data-stu-id="dd645-191">#Disable Warning \<ID> and #Enable Warning \<ID></span></span>](../../visual-basic/language-reference/directives/directives.md)  
 <span data-ttu-id="dd645-192">Puede deshabilitar y habilitar advertencias específicas para las regiones dentro de un archivo de origen.</span><span class="sxs-lookup"><span data-stu-id="dd645-192">You can disable and enable specific warnings for regions within a source file.</span></span>  
  
 <span data-ttu-id="dd645-193">Mejoras de comentarios de documento XML</span><span class="sxs-lookup"><span data-stu-id="dd645-193">XML Doc-comment Improvements</span></span>  
 <span data-ttu-id="dd645-194">Al escribir comentarios de documento, obtiene compatibilidad inteligente de editor y compilación para validar nombres de parámetro, controlar adecuadamente `crefs` (genéricos, operadores, etc.), colorear y refactorizar.</span><span class="sxs-lookup"><span data-stu-id="dd645-194">When writing doc comments, you get smart editor and build support for validating parameter names, proper handling of `crefs` (generics, operators, etc.), colorizing, and refactoring.</span></span>  
  
 [<span data-ttu-id="dd645-195">Definiciones de módulo parcial e interfaz</span><span class="sxs-lookup"><span data-stu-id="dd645-195">Partial Module and Interface Definitions</span></span>](../../visual-basic/language-reference/modifiers/partial.md)  
 <span data-ttu-id="dd645-196">Además de clases y structs, puede declarar módulos parciales e interfaces.</span><span class="sxs-lookup"><span data-stu-id="dd645-196">In addition to classes and structs, you can declare partial modules and interfaces.</span></span>  
  
 [<span data-ttu-id="dd645-197">Directivas #Region dentro de cuerpos de método</span><span class="sxs-lookup"><span data-stu-id="dd645-197">#Region Directives inside Method Bodies</span></span>](../../visual-basic/language-reference/directives/region-directive.md)  
 <span data-ttu-id="dd645-198">Puede colocar delimitadores #Region... #End Region en cualquier parte de un archivo, dentro de funciones e incluso abarcando los cuerpos de función.</span><span class="sxs-lookup"><span data-stu-id="dd645-198">You can put #Region…#End Region delimiters anywhere in a file, inside functions, and even spanning across function bodies.</span></span>  
  
 [<span data-ttu-id="dd645-199">Las definiciones de invalidaciones son implícitamente sobrecargas</span><span class="sxs-lookup"><span data-stu-id="dd645-199">Overrides Definitions are Implicitly Overloads</span></span>](../../visual-basic/language-reference/modifiers/overrides.md)  
 <span data-ttu-id="dd645-200">Si agrega el modificador `Overrides` a una definición, el compilador agrega implícitamente `Overloads`, de modo que pueda escribir menos código en los casos comunes.</span><span class="sxs-lookup"><span data-stu-id="dd645-200">If you add the `Overrides` modifier to a definition, the compiler implicitly adds `Overloads` so that you can type less code in common cases.</span></span>  
  
 <span data-ttu-id="dd645-201">CObj permitido en argumentos de atributos</span><span class="sxs-lookup"><span data-stu-id="dd645-201">CObj Allowed in Attributes Arguments</span></span>  
 <span data-ttu-id="dd645-202">El compilador solía producir un error advirtiendo de que CObj(...) no era una constante cuando se usaba en construcciones de atributo.</span><span class="sxs-lookup"><span data-stu-id="dd645-202">The compiler used to give an error that CObj(…) was not a constant when used in attribute constructions.</span></span>  
  
 <span data-ttu-id="dd645-203">Declarar y consumir métodos ambiguos de distintas interfaces</span><span class="sxs-lookup"><span data-stu-id="dd645-203">Declaring and Consuming Ambiguous Methods from Different Interfaces</span></span>  
 <span data-ttu-id="dd645-204">Anteriormente, en el código siguiente producía errores que impedían declarar `IMock` o llamar a `GetDetails` (si estos se habían declarado en C#):</span><span class="sxs-lookup"><span data-stu-id="dd645-204">Previously the following code yielded errors that prevented you from declaring `IMock` or from calling `GetDetails` (if these had been declared in C#):</span></span>  
  
```vb  
Interface ICustomer  
  Sub GetDetails(x As Integer)  
End Interface  
  
Interface ITime  
  Sub GetDetails(x As String)  
End Interface  
  
Interface IMock : Inherits ICustomer, ITime  
  Overloads Sub GetDetails(x As Char)  
End Interface  
  
Interface IMock2 : Inherits ICustomer, ITime  
End Interface  
```  
  
 <span data-ttu-id="dd645-205">Ahora el compilador usa las reglas de resolución de sobrecarga normales para elegir el `GetDetails` más apropiado que se va a llamar, y se pueden declarar relaciones de interfaz en Visual Basic como las que se muestran en el ejemplo.</span><span class="sxs-lookup"><span data-stu-id="dd645-205">Now the compiler will use normal overload resolution rules to choose the most appropriate `GetDetails` to call, and you can declare interface relationships in Visual Basic like those shown in the sample.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="dd645-206">Vea también</span><span class="sxs-lookup"><span data-stu-id="dd645-206">See also</span></span>  
 [<span data-ttu-id="dd645-207">Novedades de Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="dd645-207">What's New in Visual Studio 2017</span></span>](/visualstudio/ide/whats-new-in-visual-studio)

