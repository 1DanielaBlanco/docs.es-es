---
title: 'Paseo de F #.'
description: "Examinar algunas de las características clave de la programación de idioma en este paseo le con ejemplos de código de F #."
keywords: "Visual f #, f #, funcional programación,. NET, paseo"
author: cartermp
ms.author: phcart
ms.date: 02/28/2018
ms.topic: article
ms.prod: .net
ms.technology: devlang-fsharp
ms.devlang: fsharp
ms.assetid: 49775139-082e-442f-b5a2-dd402399b5d2
ms.openlocfilehash: 7327573a25aa62af28570b4a8662235f3e41a972
ms.sourcegitcommit: 83dd5ec003e788ccb3e33f3412a7af39ae347646
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 03/15/2018
---
# <a name="tour-of-f"></a><span data-ttu-id="e1b0b-104">Paseo de F #.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-104">Tour of F#</span></span> #

<span data-ttu-id="e1b0b-105">Es la mejor manera de obtener información sobre F # leer y escribir código de F #.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-105">The best way to learn about F# is to read and write F# code.</span></span>  <span data-ttu-id="e1b0b-106">En este artículo se actúe como un recorrido por algunas de las características claves del lenguaje F # y se ofrecen algunos fragmentos de código que se pueden ejecutar en su equipo.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-106">This article will act as a tour through some of the key features of the F# language and give you some code snippets that you can execute on your machine.</span></span>  <span data-ttu-id="e1b0b-107">Para obtener información acerca de cómo configurar un entorno de desarrollo, visite [Introducción](tutorials/getting-started/index.md).</span><span class="sxs-lookup"><span data-stu-id="e1b0b-107">To learn about setting up a development environment, check out [Getting Started](tutorials/getting-started/index.md).</span></span>

<span data-ttu-id="e1b0b-108">Hay dos conceptos principales en F #: tipos y funciones.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-108">There are two primary concepts in F#: functions and types.</span></span>  <span data-ttu-id="e1b0b-109">Este paseo le resaltan las características del lenguaje que se dividen en estos dos conceptos.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-109">This tour will emphasize features of the language which fall into these two concepts.</span></span>

## <a name="functions-and-modules"></a><span data-ttu-id="e1b0b-110">Las funciones y módulos</span><span class="sxs-lookup"><span data-stu-id="e1b0b-110">Functions and Modules</span></span>

<span data-ttu-id="e1b0b-111">Los elementos más fundamentales de cualquier programa de F # son ***funciones*** organizan en ***módulos***.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-111">The most fundamental pieces of any F# program are ***functions*** organized into ***modules***.</span></span>  <span data-ttu-id="e1b0b-112">[Funciones](language-reference/functions/index.md) realizar el trabajo en entradas para generar salidas, y que estén organizadas en [módulos](language-reference/modules.md), que son la manera principal agrupar cosas en F #.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-112">[Functions](language-reference/functions/index.md) perform work on inputs to produce outputs, and they are organized under [Modules](language-reference/modules.md), which are the primary way you group things in F#.</span></span>  <span data-ttu-id="e1b0b-113">Se definen mediante la [ `let` enlace](language-reference/functions/let-bindings.md), que asigne un nombre a la función y definir sus argumentos.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-113">They are defined using the [`let` binding](language-reference/functions/let-bindings.md), which give the function a name and define its arguments.</span></span>

[!code-fsharp[BasicFunctions](../../samples/snippets/fsharp/tour.fs#L101-L133)]

<span data-ttu-id="e1b0b-114">`let` los enlaces son también cómo enlazar un valor a un nombre, de forma similar a una variable en otros lenguajes.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-114">`let` bindings are also how you bind a value to a name, similar to a variable in other languages.</span></span>  <span data-ttu-id="e1b0b-115">`let` los enlaces son ***inmutable*** de forma predeterminada, lo que significa que una vez que una función o el valor se enlaza a un nombre, no puede modificarse en contexto.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-115">`let` bindings are ***immutable*** by default, which means that once a value or function is bound to a name, it cannot be changed in-place.</span></span>  <span data-ttu-id="e1b0b-116">Esto difiere de las variables en otros idiomas, que son ***mutable***, lo que significa que sus valores se puede cambiar en cualquier punto en el tiempo.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-116">This is in contrast to variables in other languages, which are ***mutable***, meaning their values can be changed at any point in time.</span></span>  <span data-ttu-id="e1b0b-117">Si necesita un enlace mutable, puede usar `let mutable ...` sintaxis.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-117">If you require a mutable binding, you can use `let mutable ...` syntax.</span></span>

[!code-fsharp[Immutability](../../samples/snippets/fsharp/tour.fs#L75-L94)]

## <a name="numbers-booleans-and-strings"></a><span data-ttu-id="e1b0b-118">Números, valores booleanos y cadenas</span><span class="sxs-lookup"><span data-stu-id="e1b0b-118">Numbers, Booleans, and Strings</span></span>

<span data-ttu-id="e1b0b-119">Como un lenguaje de .NET Framework, F # admite el mismo subyacente [tipos primitivos](language-reference/primitive-types.md) que existen en. NET.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-119">As a .NET language, F# supports the same underlying [primitive types](language-reference/primitive-types.md) that exist in .NET.</span></span>

<span data-ttu-id="e1b0b-120">Le mostramos cómo varios tipos numéricos se representan en F #:</span><span class="sxs-lookup"><span data-stu-id="e1b0b-120">Here is how various numeric types are represented in F#:</span></span>

[!code-fsharp[Numbers](../../samples/snippets/fsharp/tour.fs#L49-L68)]

<span data-ttu-id="e1b0b-121">Este es qué valores booleanos y lógica condicional básica de realizar el siguiente aspecto:</span><span class="sxs-lookup"><span data-stu-id="e1b0b-121">Here's what Boolean values and performing basic conditional logic looks like:</span></span>

[!code-fsharp[Bools](../../samples/snippets/fsharp/tour.fs#L142-L152)]

<span data-ttu-id="e1b0b-122">Y aquí es qué basic [cadena](language-reference/strings.md) manipulación el siguiente aspecto:</span><span class="sxs-lookup"><span data-stu-id="e1b0b-122">And here's what basic [string](language-reference/strings.md) manipulation looks like:</span></span>

[!code-fsharp[Strings](../../samples/snippets/fsharp/tour.fs#L158-L180)]

## <a name="tuples"></a><span data-ttu-id="e1b0b-123">Tuplas</span><span class="sxs-lookup"><span data-stu-id="e1b0b-123">Tuples</span></span>

<span data-ttu-id="e1b0b-124">[Tuplas](language-reference/tuples.md) son un importante en F #.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-124">[Tuples](language-reference/tuples.md) are a big deal in F#.</span></span>  <span data-ttu-id="e1b0b-125">Son una agrupación de valores sin nombre pero ordenados, que se pueden tratar como valores propiamente dichos.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-125">They are a grouping of unnamed, but ordered values, that can be treated as values themselves.</span></span>  <span data-ttu-id="e1b0b-126">Pensar en ellos como valores que se agregan a partir de otros valores.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-126">Think of them as values which are aggregated from other values.</span></span>  <span data-ttu-id="e1b0b-127">Tienen muchos usos, como forma cómoda devolver varios valores de una función o valores para algunos comodidad ad-hoc de agrupación.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-127">They have many uses, such as conveniently returning multiple values from a function, or grouping values for some ad-hoc convenience.</span></span>

[!code-fsharp[Tuples](../../samples/snippets/fsharp/tour.fs#L186-L203)]

<span data-ttu-id="e1b0b-128">A partir de F # 4.1, también puede crear `struct` tuplas.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-128">As of F# 4.1, you can also create `struct` tuples.</span></span>  <span data-ttu-id="e1b0b-129">Estos también interactúan completamente con C# 7/Visual Basic 15 tuplas, que también son `struct` tuplas:</span><span class="sxs-lookup"><span data-stu-id="e1b0b-129">These also interoperate fully with C#7/Visual Basic 15 tuples, which are also `struct` tuples:</span></span>

[!code-fsharp[Tuples](../../samples/snippets/fsharp/tour.fs#L205-L218)]

<span data-ttu-id="e1b0b-130">Es importante tener en cuenta que, dado que `struct` tuplas son tipos de valor, no se puede convertir implícitamente para hacer referencia a tuplas, o viceversa.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-130">It's important to note that because `struct` tuples are value types, they cannot be implicitly converted to reference tuples, or vice versa.</span></span>  <span data-ttu-id="e1b0b-131">Debe convertir explícitamente entre una tupla de referencia y struct.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-131">You must explicitly convert between a reference and struct tuple.</span></span>

## <a name="pipelines-and-composition"></a><span data-ttu-id="e1b0b-132">Las canalizaciones y composición</span><span class="sxs-lookup"><span data-stu-id="e1b0b-132">Pipelines and Composition</span></span>

<span data-ttu-id="e1b0b-133">Canalizar operadores (`|>`, `<|`, `||>`, `<||`, `|||>`, `<|||`) y operadores de composición (`>>` y `<<`) se utilizan ampliamente al procesar datos en F #.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-133">Pipe operators (`|>`, `<|`, `||>`, `<||`, `|||>`, `<|||`) and composition operators (`>>` and `<<`) are used extensively when processing data in F#.</span></span>  <span data-ttu-id="e1b0b-134">Estos operadores son funciones que le permiten establecer "canalizaciones" de las funciones de una forma flexible.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-134">These operators are functions which allow you to establish "pipelines" of functions in a flexible manner.</span></span>  <span data-ttu-id="e1b0b-135">En el ejemplo siguiente se describen cómo puede aprovechar las ventajas de estos operadores para crear una canalización funcional simple.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-135">The following example walks through how you could take advantage of these operators to build a simple functional pipeline.</span></span>

[!code-fsharp[Pipelines](../../samples/snippets/fsharp/tour.fs#L227-L300)]

<span data-ttu-id="e1b0b-136">El ejemplo anterior realiza uso de muchas características de F #, incluidas las funciones de procesamiento de lista, funciones de primera clase, y [aplicación parcial](language-reference/functions/index.md#partial-application-of-arguments).</span><span class="sxs-lookup"><span data-stu-id="e1b0b-136">The above sample made use of many features of F#, including list processing functions, first-class functions, and [partial application](language-reference/functions/index.md#partial-application-of-arguments).</span></span>  <span data-ttu-id="e1b0b-137">Aunque una comprensión profunda de cada uno de esos conceptos puede convertirse en algo avanzada, debe quedar claro cómo fácilmente las funciones pueden utilizarse para procesar los datos al generar las canalizaciones.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-137">Although a deep understanding of each of those concepts can become somewhat advanced, it should be clear how easily functions can be used to process data when building pipelines.</span></span>

## <a name="lists-arrays-and-sequences"></a><span data-ttu-id="e1b0b-138">Listas, matrices y secuencias</span><span class="sxs-lookup"><span data-stu-id="e1b0b-138">Lists, Arrays, and Sequences</span></span>

<span data-ttu-id="e1b0b-139">Listas, matrices y las secuencias son tres tipos de colección principal en la biblioteca básica de F #.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-139">Lists, Arrays, and Sequences are three primary collection types in the F# core library.</span></span>

<span data-ttu-id="e1b0b-140">[Enumera](language-reference/lists.md) son colecciones ordenadas e inmutables de elementos del mismo tipo.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-140">[Lists](language-reference/lists.md) are ordered, immutable collections of elements of the same type.</span></span>  <span data-ttu-id="e1b0b-141">Son listas vinculadas individualmente, lo que significa que están concebidos para la enumeración, pero una opción deficiente para el acceso aleatorio y concatenación si son de gran tamaño.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-141">They are singly-linked lists, which means they are meant for enumeration, but a poor choice for random access and concatenation if they're large.</span></span>  <span data-ttu-id="e1b0b-142">Esto contrasta con las listas en otros lenguajes populares, que normalmente no se usan una lista vinculada individualmente para representar listas.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-142">This in contrast to Lists in other popular languages, which typically do not use a singly-linked list to represent Lists.</span></span>

[!code-fsharp[Lists](../../samples/snippets/fsharp/tour.fs#L309-L359)]

<span data-ttu-id="e1b0b-143">[Matrices](language-reference/arrays.md) son de tamaño fijo, *mutable* colecciones de elementos del mismo tipo.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-143">[Arrays](language-reference/arrays.md) are fixed-size, *mutable* collections of elements of the same type.</span></span>  <span data-ttu-id="e1b0b-144">Admiten el acceso aleatorio rápido de elementos y son más rápidas que F # listas porque son simplemente contiguos bloques de memoria.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-144">They support fast random access of elements, and are faster than F# lists because they are just contiguous blocks of memory.</span></span>

[!code-fsharp[Arrays](../../samples/snippets/fsharp/tour.fs#L368-L407)]

<span data-ttu-id="e1b0b-145">[Las secuencias de](language-reference/sequences.md) son una serie lógica de elementos, todas del mismo tipo.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-145">[Sequences](language-reference/sequences.md) are a logical series of elements, all of the same type.</span></span>  <span data-ttu-id="e1b0b-146">Se trata de un tipo más general de listas y matrices, con la posibilidad de la "vista" en cualquier serie lógica de elementos.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-146">These are a more general type than Lists and Arrays, capable of being your "view" into any logical series of elements.</span></span>  <span data-ttu-id="e1b0b-147">También se resaltan porque pueden estar ***diferida***, lo que significa que se pueden calcular elementos solo cuando sean necesarias.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-147">They also stand out because they can be ***lazy***, which means that elements can be computed only when they are needed.</span></span>

[!code-fsharp[Sequences](../../samples/snippets/fsharp/tour.fs#L418-L452)]

## <a name="recursive-functions"></a><span data-ttu-id="e1b0b-148">Funciones recursivas</span><span class="sxs-lookup"><span data-stu-id="e1b0b-148">Recursive Functions</span></span>

<span data-ttu-id="e1b0b-149">Procesamiento de colecciones o secuencias de elementos se suele realizar con [recursividad](language-reference/functions/index.md#recursive-functions) en F #.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-149">Processing collections or sequences of elements is typically done with [recursion](language-reference/functions/index.md#recursive-functions) in F#.</span></span>  <span data-ttu-id="e1b0b-150">Aunque F # admite la programación imperativa y bucles, recursividad es preferible porque es más fácil de garantizar la corrección.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-150">Although F# has support for loops and imperative programming, recursion is preferred because it is easier to guarantee correctness.</span></span>

>[!NOTE]
<span data-ttu-id="e1b0b-151">En el ejemplo siguiente se utiliza la coincidencia de patrones a través de la `match` expresión.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-151">The following example makes use of the pattern matching via the `match` expression.</span></span>  <span data-ttu-id="e1b0b-152">Esta construcción fundamental se trata más adelante en este artículo.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-152">This fundamental construct is covered later in this article.</span></span>

[!code-fsharp[RecursiveFunctions](../../samples/snippets/fsharp/tour.fs#L461-L500)]

<span data-ttu-id="e1b0b-153">F # también es totalmente compatible con optimización de llamadas de cola, que es una manera para optimizar las llamadas recursivas para que sean tan rápidos como una construcción de bucle.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-153">F# also has full support for Tail Call Optimization, which is a way to optimize recursive calls so that they are just as fast as a loop construct.</span></span>

## <a name="record-and-discriminated-union-types"></a><span data-ttu-id="e1b0b-154">Registro y tipos de unión discriminada</span><span class="sxs-lookup"><span data-stu-id="e1b0b-154">Record and Discriminated Union Types</span></span>

<span data-ttu-id="e1b0b-155">Registro y tipos de unión son dos tipos de datos fundamentales que se utiliza en código de F # y suelen ser la mejor manera de representar datos en un programa en F #.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-155">Record and Union types are two fundamental data types used in F# code, and are generally the best way to represent data in an F# program.</span></span>  <span data-ttu-id="e1b0b-156">Aunque esto hace que sean similares a las clases en otros lenguajes, uno de sus principales diferencias es que tienen semántica de igualdad estructural.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-156">Although this makes them similar to classes in other languages, one of their primary differences is that they have structural equality semantics.</span></span>  <span data-ttu-id="e1b0b-157">Esto significa que son "de forma nativa" comparables e igualdad es sencilla: basta con comprobar si una es igual que la otra.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-157">This means that they are "natively" comparable and equality is straightforward - just check if one is equal to the other.</span></span>

<span data-ttu-id="e1b0b-158">[Registros](language-reference/records.md) son un agregado de valores con nombre, con miembros opcionales (por ejemplo, los métodos).</span><span class="sxs-lookup"><span data-stu-id="e1b0b-158">[Records](language-reference/records.md) are an aggregate of named values, with optional members (such as methods).</span></span>  <span data-ttu-id="e1b0b-159">Si está familiarizado con C# o Java, a continuación, estos se sentirá similares a POCOs o POJOs - solo con igualdad estructural y menos ceremonia.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-159">If you're familiar with C# or Java, then these should feel similar to POCOs or POJOs - just with structural equality and less ceremony.</span></span>

[!code-fsharp[Records](../../samples/snippets/fsharp/tour.fs#L507-L559)]

<span data-ttu-id="e1b0b-160">A partir de F # 4.1, también puede representar como `struct`s.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-160">As of F# 4.1, you can also represent Records as `struct`s.</span></span>  <span data-ttu-id="e1b0b-161">Esto se realiza con el `[<Struct>]` atributo:</span><span class="sxs-lookup"><span data-stu-id="e1b0b-161">This is done with the `[<Struct>]` attribute:</span></span>

[!code-fsharp[Records](../../samples/snippets/fsharp/tour.fs#L561-L568)]

<span data-ttu-id="e1b0b-162">[(Adeudados) uniones discriminadas](language-reference/discriminated-unions.md) son valores que pudieron ser un número de casos o de formularios con nombre.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-162">[Discriminated Unions (DUs)](language-reference/discriminated-unions.md) are values which could be a number of named forms or cases.</span></span>  <span data-ttu-id="e1b0b-163">Datos almacenados en el tipo pueden ser uno de varios valores distintos.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-163">Data stored in the type can be one of several distinct values.</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L575-L631)]

<span data-ttu-id="e1b0b-164">También puede usar adeudados como *uniones discriminadas de caso único*, para ayudar a los tipos primitivos de modelado de dominios.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-164">You can also use DUs as *Single-Case Discriminated Unions*, to help with domain modeling over primitive types.</span></span>  <span data-ttu-id="e1b0b-165">A menudo, las cadenas y otros tipos primitivos se usan para representar algo y, por tanto, tienen un significado determinado.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-165">Often times, strings and other primitive types are used to represent something, and are thus given a particular meaning.</span></span>  <span data-ttu-id="e1b0b-166">Sin embargo, utilizando solo la representación primitiva de los datos puede dar lugar a erróneamente asignar un valor incorrecto.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-166">However, using only the primitive representation of the data can result in mistakenly assigning an incorrect value!</span></span>  <span data-ttu-id="e1b0b-167">Que representa cada tipo de información que una unión de caso único distinta puede aplicar la corrección en este escenario.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-167">Representing each type of information as a distinct single-case union can enforce correctness in this scenario.</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L633-L654)]

<span data-ttu-id="e1b0b-168">Como se muestra en el ejemplo anterior, para obtener el valor subyacente en un único caso discriminada Union, debe liberar explícitamente.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-168">As the above sample demonstrates, to get the underlying value in a single-case Discriminated Union, you must explicitly unwrap it.</span></span>

<span data-ttu-id="e1b0b-169">Además, adeudados también admiten las definiciones recursivas, lo que permite representar fácilmente árboles e inherentemente datos recursivos.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-169">Additionally, DUs also support recursive definitions, allowing you to easily represent trees and inherently recursive data.</span></span>  <span data-ttu-id="e1b0b-170">Por ejemplo, mostramos cómo puede representar un árbol de búsqueda binario con `exists` y `insert` funciones.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-170">For example, here's how you can represent a Binary Search Tree with `exists` and `insert` functions.</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L656-L683)]

<span data-ttu-id="e1b0b-171">Porque adeudados permiten representar la estructura recursiva del árbol en el tipo de datos, en funcionamiento en esta estructura recursiva es sencillo y garantiza la corrección.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-171">Because DUs allow you to represent the recursive structure of the tree in the data type, operating on this recursive structure is straightforward and guarantees correctness.</span></span>  <span data-ttu-id="e1b0b-172">También se admite en la coincidencia de patrones, tal y como se muestra a continuación.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-172">It is also supported in pattern matching, as shown below.</span></span>

<span data-ttu-id="e1b0b-173">Además, puede representar adeudados como `struct`s con el `[<Struct>]` atributo:</span><span class="sxs-lookup"><span data-stu-id="e1b0b-173">Additionally, you can represent DUs as `struct`s with the `[<Struct>]` attribute:</span></span>

[!code-fsharp[Unions](../../samples/snippets/fsharp/tour.fs#L685-L696)]

<span data-ttu-id="e1b0b-174">Sin embargo, hay dos conceptos clave que hay que tener en cuenta al hacerlo:</span><span class="sxs-lookup"><span data-stu-id="e1b0b-174">However, there are two key things to keep in mind when doing so:</span></span>

1. <span data-ttu-id="e1b0b-175">No puede ser un struct DU definidos de forma recursiva.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-175">A struct DU cannot be recursively-defined.</span></span>
2. <span data-ttu-id="e1b0b-176">Un struct DU debe tener nombres únicos para cada uno de sus casos.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-176">A struct DU must have unique names for each of its cases.</span></span>

<span data-ttu-id="e1b0b-177">Si debe seguir los pasos anteriores, provocará un error de compilación.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-177">Failure to follow the above will result in a compilation error.</span></span>

## <a name="pattern-matching"></a><span data-ttu-id="e1b0b-178">Coincidencia de modelos</span><span class="sxs-lookup"><span data-stu-id="e1b0b-178">Pattern Matching</span></span>

<span data-ttu-id="e1b0b-179">[Coincidencia de patrón](language-reference/pattern-matching.md) es la característica de lenguaje F # que permite la corrección para el funcionamiento de los tipos de F #.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-179">[Pattern Matching](language-reference/pattern-matching.md) is the F# language feature which enables correctness for operating on F# types.</span></span>  <span data-ttu-id="e1b0b-180">En los ejemplos anteriores, probablemente ha observado un poco de `match x with ...` sintaxis.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-180">In the above samples, you probably noticed quite a bit of `match x with ...` syntax.</span></span>  <span data-ttu-id="e1b0b-181">Esta construcción permite que el compilador, que puede entender la "forma" de los tipos de datos, para exigir el uso para tener en cuenta todos los casos posibles cuando se usa un tipo de datos a través de lo que se conoce como coincidencia de patrones exhaustiva.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-181">This construct allows the compiler, which can understand the "shape" of data types, to force you to account for all possible cases when using a data type through what is known as Exhaustive Pattern Matching.</span></span>  <span data-ttu-id="e1b0b-182">Esto es extremadamente eficaz para la exactitud e inteligentemente sirve para "aumentar" lo que normalmente sería un problema de tiempo de ejecución en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-182">This is incredibly powerful for correctness, and can be cleverly used to "lift" what would normally be a runtime concern into compile-time.</span></span>

[!code-fsharp[PatternMatching](../../samples/snippets/fsharp/tour.fs#L705-L739)]

<span data-ttu-id="e1b0b-183">También puede utilizar la forma abreviada `function` construcción de coincidencia de patrones, lo que resulta útil al escribir funciones que hacen usan de [aplicación parcial](language-reference/functions/index.md#partial-application-of-arguments):</span><span class="sxs-lookup"><span data-stu-id="e1b0b-183">You can also use the shorthand `function` construct for pattern matching, which is useful when you're writing functions which make use of [Partial Application](language-reference/functions/index.md#partial-application-of-arguments):</span></span>

[!code-fsharp[PatternMatching](../../samples/snippets/fsharp/tour.fs#L741-L759)]

<span data-ttu-id="e1b0b-184">Algo que quizás haya observado es el uso de la `_` patrón.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-184">Something you may have noticed is the use of the `_` pattern.</span></span>  <span data-ttu-id="e1b0b-185">Esto se conoce como el [patrón de carácter comodín](language-reference/pattern-matching.md#wildcard-pattern), que es una manera de decir "no les importa qué algo".</span><span class="sxs-lookup"><span data-stu-id="e1b0b-185">This is known as the [Wildcard Pattern](language-reference/pattern-matching.md#wildcard-pattern), which is a way of saying "I don't care what something is".</span></span>  <span data-ttu-id="e1b0b-186">Aunque es útil, puede omitir accidentalmente la coincidencia de patrones exhaustiva y ya no se beneficiarán de exigencias de tiempo de compilación si no tiene cuidado en uso `_`.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-186">Although convenient, you can accidentally bypass Exhaustive Pattern Matching and no longer benefit from compile-time enforcements if you aren't careful in using `_`.</span></span>  <span data-ttu-id="e1b0b-187">Mejor se usa cuando no le interesa determinadas partes de un tipo descompuesto coincidencia o la última cláusula cuando ha enumerado todos los casos significativos en una expresión de coincidencia de patrón cuando.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-187">It is best used when you don't care about certain pieces of a decomposed type when pattern matching, or the final clause when you have enumerated all meaningful cases in a pattern matching expression.</span></span>

<span data-ttu-id="e1b0b-188">[Modelos activos](language-reference/active-patterns.md) son otra construcción eficaz para usar con la coincidencia de patrones.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-188">[Active Patterns](language-reference/active-patterns.md) are another powerful construct to use with pattern matching.</span></span>  <span data-ttu-id="e1b0b-189">Le permiten dividir los datos de entrada en formularios personalizados, descomposición de ellos en el sitio de llamada de coincidencia de patrón.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-189">They allow you to partition input data into custom forms, decomposing them at the pattern match call site.</span></span>  <span data-ttu-id="e1b0b-190">Puede también se pueden parametrizar, lo que permite definir la partición como una función.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-190">They can also be parameterized, thus allowing to define the partition as a function.</span></span>  <span data-ttu-id="e1b0b-191">Al expandir el ejemplo anterior para admitir modelos activos es algo parecido a esto:</span><span class="sxs-lookup"><span data-stu-id="e1b0b-191">Expanding the previous example to support Active Patterns looks something like this:</span></span>

[!code-fsharp[ActivePatterns](../../samples/snippets/fsharp/tour.fs#L761-L783)]

## <a name="optional-types"></a><span data-ttu-id="e1b0b-192">Tipos opcionales</span><span class="sxs-lookup"><span data-stu-id="e1b0b-192">Optional Types</span></span>

<span data-ttu-id="e1b0b-193">Un caso especial de tipos de unión discriminada es el tipo de opción, lo cual resulta útil que forma parte de la biblioteca básica de F #.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-193">One special case of Discriminated Union types is the Option Type, which is so useful that it's a part of the F# core library.</span></span>

<span data-ttu-id="e1b0b-194">[El tipo de opción](language-reference/options.md) es un tipo que representa uno de estos dos casos: un valor, o nada en absoluto.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-194">[The Option Type](language-reference/options.md) is a type which represents one of two cases: a value, or nothing at all.</span></span>  <span data-ttu-id="e1b0b-195">Se utiliza en cualquier escenario donde un valor posible o no puede deberse a una operación determinada.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-195">It is used in any scenario where a value may or may not result from a particular operation.</span></span>  <span data-ttu-id="e1b0b-196">A continuación, esto obliga a la cuenta en ambos casos, lo que constituye un problema de tiempo de compilación en lugar de un problema de tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-196">This then forces you to account for both cases, making it a compile-time concern rather than a runtime concern.</span></span>  <span data-ttu-id="e1b0b-197">A menudo se utilizan en las API donde `null` se utiliza para representar "nothing" en su lugar, lo que elimina la necesidad de preocuparse `NullReferenceException` en muchas circunstancias.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-197">These are often used in APIs where `null` is used to represent "nothing" instead, thus eliminating the need to worry about `NullReferenceException` in many circumstances.</span></span>

[!code-fsharp[Options](../../samples/snippets/fsharp/tour.fs#L791-L811)]

## <a name="units-of-measure"></a><span data-ttu-id="e1b0b-198">Unidades de medida</span><span class="sxs-lookup"><span data-stu-id="e1b0b-198">Units of Measure</span></span>

<span data-ttu-id="e1b0b-199">Una característica única del sistema de tipos de F # es la capacidad para proporcionar contexto para literales numéricos a través de unidades de medida.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-199">One unique feature of F#'s type system is the ability to provide context for numeric literals through Units of Measure.</span></span>

<span data-ttu-id="e1b0b-200">[Unidades de medida](language-reference/units-of-measure.md) le permiten asociar un tipo numérico a una unidad, por ejemplo, metros, y haber funciones realizan el trabajo en unidades en lugar de literales numéricos.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-200">[Units of Measure](language-reference/units-of-measure.md) allow you to associate a numeric type to a unit, such as Meters, and have functions perform work on units rather than numeric literals.</span></span>  <span data-ttu-id="e1b0b-201">Esto permite al compilador comprobar que los tipos de literales numéricos que se pasan en sentido en un contexto determinado, lo que elimina los errores en tiempo de ejecución asociada a ese tipo de trabajo.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-201">This enables the compiler to verify that the types of numeric literals passed in make sense under a certain context, thus eliminating runtime errors associated with that kind of work.</span></span>

[!code-fsharp[UnitsOfMeasure](../../samples/snippets/fsharp/tour.fs#L818-L839)]

<span data-ttu-id="e1b0b-202">La biblioteca básica de F # define muchos tipos de unidades SI y conversiones de unidades.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-202">The F# Core library defines many SI unit types and unit conversions.</span></span>  <span data-ttu-id="e1b0b-203">Para obtener más información, consulte el [Microsoft.FSharp.Data.UnitSystems.SI Namespace](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.data.unitsystems.si-namespace-%5bfsharp%5d).</span><span class="sxs-lookup"><span data-stu-id="e1b0b-203">To learn more, check out the [Microsoft.FSharp.Data.UnitSystems.SI Namespace](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.data.unitsystems.si-namespace-%5bfsharp%5d).</span></span>

## <a name="classes-and-interfaces"></a><span data-ttu-id="e1b0b-204">Las clases e Interfaces</span><span class="sxs-lookup"><span data-stu-id="e1b0b-204">Classes and Interfaces</span></span>

<span data-ttu-id="e1b0b-205">F # también es totalmente compatible con las clases. NET, [Interfaces](language-reference/interfaces.md), [clases abstractas](language-reference/abstract-classes.md), [herencia](language-reference/inheritance.md), y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-205">F# also has full support for .NET classes, [Interfaces](language-reference/interfaces.md), [Abstract Classes](language-reference/abstract-classes.md), [Inheritance](language-reference/inheritance.md), and so on.</span></span>

<span data-ttu-id="e1b0b-206">[Clases de](language-reference/classes.md) son tipos que representan objetos. NET, que puede tener propiedades, métodos y eventos como su [miembros](language-reference/members/index.md).</span><span class="sxs-lookup"><span data-stu-id="e1b0b-206">[Classes](language-reference/classes.md) are types that represent .NET objects, which can have properties, methods, and events as its [Members](language-reference/members/index.md).</span></span>

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L848-L877)]

<span data-ttu-id="e1b0b-207">También es muy sencillo definir clases genéricas.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-207">Defining generic classes is also very straightforward.</span></span>

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L884-L905)]

<span data-ttu-id="e1b0b-208">Para implementar una interfaz, puede usar `interface ... with` sintaxis o un [expresión de objeto](language-reference/object-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="e1b0b-208">To implement an Interface, you can use either `interface ... with` syntax or an [Object Expression](language-reference/object-expressions.md).</span></span>

[!code-fsharp[Classes](../../samples/snippets/fsharp/tour.fs#L912-L931)]

## <a name="which-types-to-use"></a><span data-ttu-id="e1b0b-209">Los tipos que se utilizan</span><span class="sxs-lookup"><span data-stu-id="e1b0b-209">Which Types to Use</span></span>

<span data-ttu-id="e1b0b-210">La presencia de tuplas, registros, uniones discriminadas y clases conduce a una pregunta importante: ¿cuál debería utilizar?</span><span class="sxs-lookup"><span data-stu-id="e1b0b-210">The presence of Classes, Records, Discriminated Unions, and Tuples leads to an important question: which should you use?</span></span>  <span data-ttu-id="e1b0b-211">Al igual que casi todos los elementos en la vida, la respuesta depende de sus circunstancias.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-211">Like most everything in life, the answer depends on your circumstances.</span></span>

<span data-ttu-id="e1b0b-212">Tuplas son excelentes para devolver varios valores desde una función y el uso de un agregado ad-hoc de valores como un valor en Sí.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-212">Tuples are great for returning multiple values from a function, and using an ad-hoc aggregate of values as a value itself.</span></span>

<span data-ttu-id="e1b0b-213">Los registros son "nivel superior" tuplas, tener denominado etiquetas y la compatibilidad con miembros opcionales.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-213">Records are a "step up" from Tuples, having named labels and support for optional members.</span></span>  <span data-ttu-id="e1b0b-214">Únicamente son excelentes para obtener una representación de la ceremonia de baja de datos en tránsito a través de su programa.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-214">They are great for a low-ceremony representation of data in-transit through your program.</span></span>  <span data-ttu-id="e1b0b-215">Dado que tienen igualdad estructural, es fácil de usar con la comparación.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-215">Because they have structural equality, they are easy to use with comparison.</span></span>

<span data-ttu-id="e1b0b-216">Uniones discriminadas tienen muchos usos, pero la ventaja principal es poder utilizarlas junto con la coincidencia de patrones para tener en cuenta todas las posibles "formas" que pueden tener datos.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-216">Discriminated Unions have many uses, but the core benefit is to be able to utilize them in conjunction with Pattern Matching to account for all possible "shapes" that a data can have.</span></span>  

<span data-ttu-id="e1b0b-217">Las clases son excelentes para un gran número de razones, como cuando se necesita representar la información y también asociar esa información a la funcionalidad.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-217">Classes are great for a huge number of reasons, such as when you need to represent information and also tie that information to functionality.</span></span>  <span data-ttu-id="e1b0b-218">Como regla general, si tiene la funcionalidad que está vinculada conceptualmente a algunos datos, utilizando las clases y los principios de programación orientada a objetos es una gran ventaja.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-218">As a rule of thumb, when you have functionality which is conceptually tied to some data, using Classes and the principles of Object-Oriented Programming is a big benefit.</span></span>  <span data-ttu-id="e1b0b-219">Las clases son también el tipo de datos preferido cuando se interopera con C# y Visual Basic, como estos idiomas utilizan clases para casi todo.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-219">Classes are also the preferred data type when interoperating with C# and Visual Basic, as these languages use classes for nearly everything.</span></span>

## <a name="next-steps"></a><span data-ttu-id="e1b0b-220">Pasos siguientes</span><span class="sxs-lookup"><span data-stu-id="e1b0b-220">Next Steps</span></span>

<span data-ttu-id="e1b0b-221">Ahora que ha visto algunas de las características principales del lenguaje, estará preparado para escribir sus primera programas de F #.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-221">Now that you've seen some of the primary features of the language, you should be ready to write your first F# programs!</span></span>  <span data-ttu-id="e1b0b-222">Extraer del repositorio [Introducción](tutorials/getting-started/index.md) para obtener información sobre cómo configurar el entorno de desarrollo y escribir código.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-222">Check out [Getting Started](tutorials/getting-started/index.md) to learn how to set up your development environment and write some code.</span></span>

<span data-ttu-id="e1b0b-223">Los pasos siguientes para obtener más pueden ser el que desee, pero se recomienda [funciona como valores de primera clase](introduction-to-functional-programming/functions-as-first-class-values.md) <!--[Introduction to Functional Programming in F#](introduction-to-functional-programming/index.md)--> obtener familiarizado con conceptos de programación funcionales principales.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-223">The next steps for learning more can be whatever you like, but we recommend [Functions as First-Class Values](introduction-to-functional-programming/functions-as-first-class-values.md)<!--[Introduction to Functional Programming in F#](introduction-to-functional-programming/index.md)--> to get comfortable with core Functional Programming concepts.</span></span>  <span data-ttu-id="e1b0b-224">Estos serán esenciales en la compilación de programas sólidos en F #.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-224">These will be essential in building robust programs in F#.</span></span>

<span data-ttu-id="e1b0b-225">Asimismo, consulte la [referencia del lenguaje F #](language-reference/index.md) para ver una completa colección de contenido conceptual en F #.</span><span class="sxs-lookup"><span data-stu-id="e1b0b-225">Also, check out the [F# Language Reference](language-reference/index.md) to see a comprehensive collection of conceptual content on F#.</span></span>
