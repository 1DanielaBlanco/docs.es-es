---
title: "Expresiones de código delimitadas (F#)"
description: "Obtenga información sobre F # expresiones de código delimitadas, una característica del lenguaje que permite generar y trabajar con expresiones de código de F # mediante programación."
keywords: "visual f#, f#, programación funcional"
author: cartermp
ms.author: phcart
ms.date: 05/16/2016
ms.topic: language-reference
ms.prod: .net
ms.technology: devlang-fsharp
ms.devlang: fsharp
ms.assetid: 4559e659-2b04-48bd-8a0b-8527920eec95
ms.openlocfilehash: f7a08013bc6487b570a62576bb01ca2dd65ce8b1
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 10/18/2017
---
# <a name="code-quotations"></a><span data-ttu-id="85eba-104">Expresiones de código delimitadas</span><span class="sxs-lookup"><span data-stu-id="85eba-104">Code Quotations</span></span>

> [!NOTE]
<span data-ttu-id="85eba-105">El vínculo de la referencia de API le llevará a MSDN.</span><span class="sxs-lookup"><span data-stu-id="85eba-105">The API reference link will take you to MSDN.</span></span>  <span data-ttu-id="85eba-106">La referencia de API de docs.microsoft.com no está completa.</span><span class="sxs-lookup"><span data-stu-id="85eba-106">The docs.microsoft.com API reference is not complete.</span></span>

<span data-ttu-id="85eba-107">Este tema se describe *expresiones de código delimitadas*, una característica del lenguaje que permite generar y trabajar con expresiones de código de F # mediante programación.</span><span class="sxs-lookup"><span data-stu-id="85eba-107">This topic describes *code quotations*, a language feature that enables you to generate and work with F# code expressions programmatically.</span></span> <span data-ttu-id="85eba-108">Esta característica le permite generar un árbol de sintaxis abstracta que representa el código de F #.</span><span class="sxs-lookup"><span data-stu-id="85eba-108">This feature lets you generate an abstract syntax tree that represents F# code.</span></span> <span data-ttu-id="85eba-109">Puede recorrer el árbol de sintaxis abstracta y procesan según las necesidades de su aplicación.</span><span class="sxs-lookup"><span data-stu-id="85eba-109">The abstract syntax tree can then be traversed and processed according to the needs of your application.</span></span> <span data-ttu-id="85eba-110">Por ejemplo, puede usar el árbol para generar código de F # o generar código en algún otro lenguaje.</span><span class="sxs-lookup"><span data-stu-id="85eba-110">For example, you can use the tree to generate F# code or generate code in some other language.</span></span>


## <a name="quoted-expressions"></a><span data-ttu-id="85eba-111">Expresiones delimitadas</span><span class="sxs-lookup"><span data-stu-id="85eba-111">Quoted Expressions</span></span>
<span data-ttu-id="85eba-112">A *expresión delimitada* es una expresión de F # en el código que está delimitada de tal manera que no se compila como parte del programa, pero en su lugar se compila en un objeto que representa una expresión de F #.</span><span class="sxs-lookup"><span data-stu-id="85eba-112">A *quoted expression* is an F# expression in your code that is delimited in such a way that it is not compiled as part of your program, but instead is compiled into an object that represents an F# expression.</span></span> <span data-ttu-id="85eba-113">Puede marcar una expresión entre comillas en una de dos maneras: con información de tipo o sin información de tipo.</span><span class="sxs-lookup"><span data-stu-id="85eba-113">You can mark a quoted expression in one of two ways: either with type information or without type information.</span></span> <span data-ttu-id="85eba-114">Si van a incluir información de tipo, use los símbolos `<@` y `@>` para delimitar la expresión entre comillas.</span><span class="sxs-lookup"><span data-stu-id="85eba-114">If you want to include type information, you use the symbols `<@` and `@>` to delimit the quoted expression.</span></span> <span data-ttu-id="85eba-115">Si no necesita información de tipo, se utilizan los símbolos `<@@` y `@@>`.</span><span class="sxs-lookup"><span data-stu-id="85eba-115">If you do not need type information, you use the symbols `<@@` and `@@>`.</span></span> <span data-ttu-id="85eba-116">El código siguiente muestra expresiones de código delimitadas con y sin tipo.</span><span class="sxs-lookup"><span data-stu-id="85eba-116">The following code shows typed and untyped quotations.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-3/snippet501.fs)]

<span data-ttu-id="85eba-117">Recorrer un árbol de expresión grande es más rápido si no incluye la información de tipo.</span><span class="sxs-lookup"><span data-stu-id="85eba-117">Traversing a large expression tree is faster if you do not include type information.</span></span> <span data-ttu-id="85eba-118">El tipo resultante de una expresión delimitada con los símbolos de tipo es `Expr<'T>`, donde el parámetro de tipo tiene el tipo de la expresión, según lo determinado por el algoritmo de inferencia de tipo de F # del compilador.</span><span class="sxs-lookup"><span data-stu-id="85eba-118">The resulting type of an expression quoted with the typed symbols is `Expr<'T>`, where the type parameter has the type of the expression as determined by the F# compiler's type inference algorithm.</span></span> <span data-ttu-id="85eba-119">Cuando utilice expresiones de código delimitadas sin información de tipo, el tipo de la expresión entre comillas es el tipo no genérico [Expr](https://msdn.microsoft.com/library/ed6a2caf-69d4-45c2-ab97-e9b3be9bce65).</span><span class="sxs-lookup"><span data-stu-id="85eba-119">When you use code quotations without type information, the type of the quoted expression is the non-generic type [Expr](https://msdn.microsoft.com/library/ed6a2caf-69d4-45c2-ab97-e9b3be9bce65).</span></span> <span data-ttu-id="85eba-120">Puede llamar a la [Raw](https://msdn.microsoft.com/library/47fb94f1-e77f-4c68-aabc-2b0ba40d59c2) propiedad de tipo `Expr` clase para obtener el sin tipo `Expr` objeto.</span><span class="sxs-lookup"><span data-stu-id="85eba-120">You can call the [Raw](https://msdn.microsoft.com/library/47fb94f1-e77f-4c68-aabc-2b0ba40d59c2) property on the typed `Expr` class to obtain the untyped `Expr` object.</span></span>

<span data-ttu-id="85eba-121">Hay una variedad de métodos estáticos que le permiten generar expresión objetos de F # mediante programación en el `Expr` clase sin usar entre comillas expresiones.</span><span class="sxs-lookup"><span data-stu-id="85eba-121">There are a variety of static methods that allow you to generate F# expression objects programmatically in the `Expr` class without using quoted expressions.</span></span>

<span data-ttu-id="85eba-122">Tenga en cuenta que una expresión de código debe incluir una expresión completa.</span><span class="sxs-lookup"><span data-stu-id="85eba-122">Note that a code quotation must include a complete expression.</span></span> <span data-ttu-id="85eba-123">Para una `let` de enlace, por ejemplo, se necesita la definición del nombre enlazado y una expresión adicional que utilice el enlace.</span><span class="sxs-lookup"><span data-stu-id="85eba-123">For a `let` binding, for example, you need both the definition of the bound name and an additional expression that uses the binding.</span></span> <span data-ttu-id="85eba-124">En la sintaxis detallada, ésta es una expresión que sigue a la `in` (palabra clave).</span><span class="sxs-lookup"><span data-stu-id="85eba-124">In verbose syntax, this is an expression that follows the `in` keyword.</span></span> <span data-ttu-id="85eba-125">En el nivel superior de un módulo, se trata únicamente la expresión siguiente en el módulo, pero en un presupuesto, se requiere de forma explícita.</span><span class="sxs-lookup"><span data-stu-id="85eba-125">At the top-level in a module, this is just the next expression in the module, but in a quotation, it is explicitly required.</span></span>

<span data-ttu-id="85eba-126">Por lo tanto, la siguiente expresión no es válida.</span><span class="sxs-lookup"><span data-stu-id="85eba-126">Therefore, the following expression is not valid.</span></span>

```fsharp
// Not valid:
// <@ let f x = x + 1 @>
```

<span data-ttu-id="85eba-127">Pero las expresiones siguientes son válidas.</span><span class="sxs-lookup"><span data-stu-id="85eba-127">But the following expressions are valid.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-3/snippet502.fs)]

<span data-ttu-id="85eba-128">Para usar expresiones de código delimitadas, primero debe agregar una declaración de importación (mediante el uso de la `open` palabra clave) que se abre la [Microsoft.FSharp.Quotations](https://msdn.microsoft.com/library/e9ce8a3a-e00c-4190-bad5-cce52ee089b2) espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="85eba-128">To use code quotations, you must add an import declaration (by using the `open` keyword) that opens the [Microsoft.FSharp.Quotations](https://msdn.microsoft.com/library/e9ce8a3a-e00c-4190-bad5-cce52ee089b2) namespace.</span></span>

<span data-ttu-id="85eba-129">F # PowerPack proporciona compatibilidad para la evaluación y la ejecución de los objetos de expresiones de F #.</span><span class="sxs-lookup"><span data-stu-id="85eba-129">The F# PowerPack provides support for evaluating and executing F# expression objects.</span></span>


## <a name="expr-type"></a><span data-ttu-id="85eba-130">Tipo de expresión</span><span class="sxs-lookup"><span data-stu-id="85eba-130">Expr Type</span></span>
<span data-ttu-id="85eba-131">Una instancia de la `Expr` tipo representa una expresión de F #.</span><span class="sxs-lookup"><span data-stu-id="85eba-131">An instance of the `Expr` type represents an F# expression.</span></span> <span data-ttu-id="85eba-132">La interfaz genérica y no genérica `Expr` tipos se documentan en la documentación de biblioteca de F #.</span><span class="sxs-lookup"><span data-stu-id="85eba-132">Both the generic and the non-generic `Expr` types are documented in the F# library documentation.</span></span> <span data-ttu-id="85eba-133">Para obtener más información, consulte [Microsoft.FSharp.Quotations Namespace](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.quotations-namespace-%5bfsharp%5d) y [Quotations.Expr clase](https://msdn.microsoft.com/visualfsharpdocs/conceptual/quotations.expr-class-%5bfsharp%5d).</span><span class="sxs-lookup"><span data-stu-id="85eba-133">For more information, see [Microsoft.FSharp.Quotations Namespace](https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.quotations-namespace-%5bfsharp%5d) and [Quotations.Expr Class](https://msdn.microsoft.com/visualfsharpdocs/conceptual/quotations.expr-class-%5bfsharp%5d).</span></span>


## <a name="splicing-operators"></a><span data-ttu-id="85eba-134">Ensamblar operadores</span><span class="sxs-lookup"><span data-stu-id="85eba-134">Splicing Operators</span></span>
<span data-ttu-id="85eba-135">Insertar permite agrupar expresiones de código literal delimitadas con expresiones que ha creado mediante programación o desde otra expresión de código.</span><span class="sxs-lookup"><span data-stu-id="85eba-135">Splicing enables you to combine literal code quotations with expressions that you have created programmatically or from another code quotation.</span></span> <span data-ttu-id="85eba-136">El `%` y `%%` operadores permiten agregar un objeto de expresión de F # en una expresión de código.</span><span class="sxs-lookup"><span data-stu-id="85eba-136">The `%` and `%%` operators enable you to add an F# expression object into a code quotation.</span></span> <span data-ttu-id="85eba-137">Usa el `%` operador que se va a insertar un objeto de expresión con tipo en una expresión de código delimitada con tipo; debe utilizar el `%%` operador que se va a insertar un objeto de expresión sin tipo en una expresión de código delimitada sin tipo.</span><span class="sxs-lookup"><span data-stu-id="85eba-137">You use the `%` operator to insert a typed expression object into a typed quotation; you use the `%%` operator to insert an untyped expression object into an untyped quotation.</span></span> <span data-ttu-id="85eba-138">Ambos operadores son operadores de prefijo unario.</span><span class="sxs-lookup"><span data-stu-id="85eba-138">Both operators are unary prefix operators.</span></span> <span data-ttu-id="85eba-139">Por lo tanto si `expr` es una expresión sin tipo del tipo `Expr`, el código siguiente es válido.</span><span class="sxs-lookup"><span data-stu-id="85eba-139">Thus if `expr` is an untyped expression of type `Expr`, the following code is valid.</span></span>

```fsharp
<@@ 1 + %%expr @@>
```

<span data-ttu-id="85eba-140">Y si `expr` es una expresión de código delimitada con tipo de tipo `Expr<int>`, el código siguiente es válido.</span><span class="sxs-lookup"><span data-stu-id="85eba-140">And if `expr` is a typed quotation of type `Expr<int>`, the following code is valid.</span></span>

```fsharp
<@ 1 + %expr @>
```

## <a name="example"></a><span data-ttu-id="85eba-141">Ejemplo</span><span class="sxs-lookup"><span data-stu-id="85eba-141">Example</span></span>

### <a name="description"></a><span data-ttu-id="85eba-142">Descripción</span><span class="sxs-lookup"><span data-stu-id="85eba-142">Description</span></span>
<span data-ttu-id="85eba-143">En el ejemplo siguiente se muestra el uso de expresiones de código delimitadas para colocar el código de F # en un objeto de expresión y, a continuación, imprimir el código de F # que representa la expresión.</span><span class="sxs-lookup"><span data-stu-id="85eba-143">The following example illustrates the use of code quotations to put F# code into an expression object and then print the F# code that represents the expression.</span></span> <span data-ttu-id="85eba-144">Una función `println` se define que contiene una función recursiva `print` que muestra un objeto de expresión de F # (de tipo `Expr`) en un formato descriptivo.</span><span class="sxs-lookup"><span data-stu-id="85eba-144">A function `println` is defined that contains a recursive function `print` that displays an F# expression object (of type `Expr`) in a friendly format.</span></span> <span data-ttu-id="85eba-145">Hay varios modelos activos en el [Microsoft.FSharp.Quotations.Patterns](https://msdn.microsoft.com/library/093944a9-c752-403a-8983-5fcd5dbf92a4) y [Microsoft.FSharp.Quotations.DerivedPatterns](https://msdn.microsoft.com/library/d2434a6e-ae7b-4f3d-b567-c162938bc9cd) módulos que pueden usarse para analizar objetos de expresión.</span><span class="sxs-lookup"><span data-stu-id="85eba-145">There are several active patterns in the [Microsoft.FSharp.Quotations.Patterns](https://msdn.microsoft.com/library/093944a9-c752-403a-8983-5fcd5dbf92a4) and [Microsoft.FSharp.Quotations.DerivedPatterns](https://msdn.microsoft.com/library/d2434a6e-ae7b-4f3d-b567-c162938bc9cd) modules that can be used to analyze expression objects.</span></span> <span data-ttu-id="85eba-146">En este ejemplo no incluye todos los posibles modelos que pueden aparecer en una expresión de F #.</span><span class="sxs-lookup"><span data-stu-id="85eba-146">This example does not include all the possible patterns that might appear in an F# expression.</span></span> <span data-ttu-id="85eba-147">Ninguno no se reconoce el patrón desencadena una coincidencia con el patrón de carácter comodín (`_`) y se representa mediante el uso de la `ToString` método, que, en el `Expr` escribe, permite saber el patrón activo para agregar a la expresión de coincidencia.</span><span class="sxs-lookup"><span data-stu-id="85eba-147">Any unrecognized pattern triggers a match to the wildcard pattern (`_`) and is rendered by using the `ToString` method, which, on the `Expr` type, lets you know the active pattern to add to your match expression.</span></span>


### <a name="code"></a><span data-ttu-id="85eba-148">Código</span><span class="sxs-lookup"><span data-stu-id="85eba-148">Code</span></span>
[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-3/snippet601.fs)]
    
### <a name="output"></a><span data-ttu-id="85eba-149">Resultado</span><span class="sxs-lookup"><span data-stu-id="85eba-149">Output</span></span>

```fsharp
fun (x:System.Int32) -> x + 1
a + 1
let f = fun (x:System.Int32) -> x + 10 in f 10
```

## <a name="example"></a><span data-ttu-id="85eba-150">Ejemplo</span><span class="sxs-lookup"><span data-stu-id="85eba-150">Example</span></span>

### <a name="description"></a><span data-ttu-id="85eba-151">Descripción</span><span class="sxs-lookup"><span data-stu-id="85eba-151">Description</span></span>
<span data-ttu-id="85eba-152">También puede utilizar los tres modelos activos en el [ExprShape (módulo)](https://msdn.microsoft.com/library/7685150e-2432-4d39-9338-57292eff18de) para recorrer los árboles de expresión con menos modelos activos.</span><span class="sxs-lookup"><span data-stu-id="85eba-152">You can also use the three active patterns in the [ExprShape module](https://msdn.microsoft.com/library/7685150e-2432-4d39-9338-57292eff18de) to traverse expression trees with fewer active patterns.</span></span> <span data-ttu-id="85eba-153">Estos modelos activos pueden ser útiles cuando desea recorrer un árbol pero no es necesario toda la información en la mayoría de los nodos.</span><span class="sxs-lookup"><span data-stu-id="85eba-153">These active patterns can be useful when you want to traverse a tree but you do not need all the information in most of the nodes.</span></span> <span data-ttu-id="85eba-154">Al usar estos patrones, cualquier expresión de F # coincide con uno de los siguientes tres modelos: `ShapeVar` si la expresión es una variable, `ShapeLambda` si la expresión es una expresión lambda, o `ShapeCombination` si la expresión es algo más.</span><span class="sxs-lookup"><span data-stu-id="85eba-154">When you use these patterns, any F# expression matches one of the following three patterns: `ShapeVar` if the expression is a variable, `ShapeLambda` if the expression is a lambda expression, or `ShapeCombination` if the expression is anything else.</span></span> <span data-ttu-id="85eba-155">Si recorrer un árbol de expresión mediante el uso de los patrones activos como en el ejemplo de código anterior, tendrá que utilizar muchos más modelos para administrar todos los tipos de expresión de F # posibles, y el código será más complejo.</span><span class="sxs-lookup"><span data-stu-id="85eba-155">If you traverse an expression tree by using the active patterns as in the previous code example, you have to use many more patterns to handle all possible F# expression types, and your code will be more complex.</span></span> <span data-ttu-id="85eba-156">Para obtener más información, consulte [ExprShape.ShapeVar &#124; ShapeLambda &#124; Modelo activo de ShapeCombination](https://msdn.microsoft.com/visualfsharpdocs/conceptual/exprshape.shapevarhshapelambdahshapecombination-active-pattern-%5bfsharp%5d).</span><span class="sxs-lookup"><span data-stu-id="85eba-156">For more information, see [ExprShape.ShapeVar&#124;ShapeLambda&#124;ShapeCombination Active Pattern](https://msdn.microsoft.com/visualfsharpdocs/conceptual/exprshape.shapevarhshapelambdahshapecombination-active-pattern-%5bfsharp%5d).</span></span>

<span data-ttu-id="85eba-157">El ejemplo de código siguiente puede utilizarse como base para recorridos más complejos.</span><span class="sxs-lookup"><span data-stu-id="85eba-157">The following code example can be used as a basis for more complex traversals.</span></span> <span data-ttu-id="85eba-158">En este código, se crea un árbol de expresión para una expresión que implica una llamada de función, `add`.</span><span class="sxs-lookup"><span data-stu-id="85eba-158">In this code, an expression tree is created for an expression that involves a function call, `add`.</span></span> <span data-ttu-id="85eba-159">El [SpecificCall](https://msdn.microsoft.com/library/05a77b21-20fe-4b9a-8e07-aa999538198d) (modelo activo) se utiliza para detectar cualquier llamada a `add` en el árbol de expresión.</span><span class="sxs-lookup"><span data-stu-id="85eba-159">The [SpecificCall](https://msdn.microsoft.com/library/05a77b21-20fe-4b9a-8e07-aa999538198d) active pattern is used to detect any call to `add` in the expression tree.</span></span> <span data-ttu-id="85eba-160">Este modelo activo asigna los argumentos de la llamada a la `exprList` valor.</span><span class="sxs-lookup"><span data-stu-id="85eba-160">This active pattern assigns the arguments of the call to the `exprList` value.</span></span> <span data-ttu-id="85eba-161">En este caso, hay solo dos, por lo que se extraen estos y la función se llama de forma recursiva en los argumentos.</span><span class="sxs-lookup"><span data-stu-id="85eba-161">In this case, there are only two, so these are pulled out and the function is called recursively on the arguments.</span></span> <span data-ttu-id="85eba-162">Los resultados se insertan en una expresión de código que representa una llamada a `mul` mediante el operador de intervalo (`%%`).</span><span class="sxs-lookup"><span data-stu-id="85eba-162">The results are inserted into a code quotation that represents a call to `mul` by using the splice operator (`%%`).</span></span> <span data-ttu-id="85eba-163">El `println` función del ejemplo anterior se utiliza para mostrar los resultados.</span><span class="sxs-lookup"><span data-stu-id="85eba-163">The `println` function from the previous example is used to display the results.</span></span>

<span data-ttu-id="85eba-164">El código en las otras bifurcaciones del modelo activo simplemente regenera el mismo árbol de expresión, por lo que el único cambio en la expresión resultante es el cambio de `add` a `mul`.</span><span class="sxs-lookup"><span data-stu-id="85eba-164">The code in the other active pattern branches just regenerates the same expression tree, so the only change in the resulting expression is the change from `add` to `mul`.</span></span>


### <a name="code"></a><span data-ttu-id="85eba-165">Código</span><span class="sxs-lookup"><span data-stu-id="85eba-165">Code</span></span>
[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-3/snippet701.fs)]
    
### <a name="output"></a><span data-ttu-id="85eba-166">Resultado</span><span class="sxs-lookup"><span data-stu-id="85eba-166">Output</span></span>

```fsharp
1 + Module1.add(2,Module1.add(3,4))
1 + Module1.mul(2,Module1.mul(3,4))
```

## <a name="see-also"></a><span data-ttu-id="85eba-167">Vea también</span><span class="sxs-lookup"><span data-stu-id="85eba-167">See Also</span></span>
[<span data-ttu-id="85eba-168">Referencia del lenguaje F#</span><span class="sxs-lookup"><span data-stu-id="85eba-168">F# Language Reference</span></span>](index.md)

