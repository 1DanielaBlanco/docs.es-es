---
title: Semántica de referencia con tipos de valor
description: Conozca las características del lenguaje que reducen al mínimo la copia de las estructuras de manera segura.
author: billwagner
ms.author: wiwagn
ms.date: 11/10/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.custom: mvc
ms.openlocfilehash: 778897dc92f8a94178ebbbed7704c0dfe2397729
ms.sourcegitcommit: 935d5267c44f9bce801468ef95f44572f1417e8c
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 03/28/2018
---
# <a name="reference-semantics-with-value-types"></a><span data-ttu-id="cdfe8-103">Semántica de referencia con tipos de valor</span><span class="sxs-lookup"><span data-stu-id="cdfe8-103">Reference semantics with value types</span></span>

<span data-ttu-id="cdfe8-104">Una ventaja de utilizar tipos de valor es que a menudo evitan las asignaciones del montón.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-104">An advantage to using value types is that they often avoid heap allocations.</span></span>
<span data-ttu-id="cdfe8-105">La desventaja es que se copian por valor.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-105">The disadvantage is that they are copied by value.</span></span> <span data-ttu-id="cdfe8-106">Este último aspecto dificulta la optimización de los algoritmos que funcionan en grandes cantidades de datos.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-106">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="cdfe8-107">Las nuevas características del lenguaje en C# 7.2 proporcionan mecanismos que habilitan la semántica de paso por referencia con tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-107">New language features in C# 7.2 provide mechanisms that enable pass-by-reference semantics with value types.</span></span> <span data-ttu-id="cdfe8-108">Use estas características acertadamente para minimizar tanto las asignaciones como las operaciones de copia.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-108">Use these features wisely to minimize both allocations and copy operations.</span></span> <span data-ttu-id="cdfe8-109">En este artículo se exploran estas nuevas características.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-109">This article explores those new features.</span></span>

<span data-ttu-id="cdfe8-110">Gran parte del código de ejemplo de este artículo muestra características agregadas en C# 7.2.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-110">Much of the sample code in this article demonstrates features added in C# 7.2.</span></span> <span data-ttu-id="cdfe8-111">Para poder usar esas características, tendrá que configurar el proyecto para que use C# 7.2 o una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-111">In order to use those features, you must configure your project to use C# 7.2 or later.</span></span> <span data-ttu-id="cdfe8-112">Puede usar Visual Studio para seleccionarlo.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-112">You can use Visual Studio to select it.</span></span> <span data-ttu-id="cdfe8-113">Para cada proyecto, seleccione **Proyecto** en el menú y, a continuación, **Propiedades**.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-113">For each project, select **Project** from the menu, then **Properties**.</span></span> <span data-ttu-id="cdfe8-114">Seleccione la pestaña **Compilar** y haga clic en **Opciones avanzadas**.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-114">Select the **Build** tab and click **Advanced**.</span></span> <span data-ttu-id="cdfe8-115">Desde ahí, configure la versión del lenguaje.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-115">From there, configure the language version.</span></span> <span data-ttu-id="cdfe8-116">Elija "7.2", o "más reciente".</span><span class="sxs-lookup"><span data-stu-id="cdfe8-116">Choose either "7.2", or "latest".</span></span>  <span data-ttu-id="cdfe8-117">O puede editar el proyecto *csproj* y agregar el nodo siguiente:</span><span class="sxs-lookup"><span data-stu-id="cdfe8-117">Or you can edit the *csproj* file and add the following node:</span></span>

```XML
  <PropertyGroup>
    <LangVersion>7.2</LangVersion>
  </PropertyGroup>
```

<span data-ttu-id="cdfe8-118">Puede usar "7.2" o "más reciente" como valor.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-118">You can use either "7.2" or "latest" for the value.</span></span>

## <a name="passing-arguments-by-readonly-reference"></a><span data-ttu-id="cdfe8-119">Pasar argumentos por referencia de solo lectura</span><span class="sxs-lookup"><span data-stu-id="cdfe8-119">Passing arguments by readonly reference</span></span>

<span data-ttu-id="cdfe8-120">C# 7.2 agrega la palabra clave `in` para complementar las palabras clave `ref` y `out` existentes para pasar argumentos por referencia.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-120">C# 7.2 adds the `in` keyword to complement the existing `ref` and `out` keywords to pass arguments by reference.</span></span> <span data-ttu-id="cdfe8-121">La palabra clave `in` especifica que se pasa el argumento por referencia, pero el método llamado no modifica el valor.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-121">The `in` keyword specifies passing the argument by reference, but the called method does not modify the value.</span></span> 

<span data-ttu-id="cdfe8-122">Esta novedad proporciona un vocabulario completo para expresar la intención del diseño.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-122">This addition provides a full vocabulary to express your design intent.</span></span> <span data-ttu-id="cdfe8-123">Los tipos de valor se copian al pasarlos a un método llamado cuando no se especifica ninguno de los siguientes modificadores en la firma de método.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-123">Value types are copied when passed to a called method when you don't specify any of the following modifiers in the method signature.</span></span> <span data-ttu-id="cdfe8-124">Cada uno de estos modificadores especifica que un tipo de valor se pasa por referencia, evitando la copia.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-124">Each of these modifiers specifies that a value type is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="cdfe8-125">Cada modificador expresa un propósito diferente:</span><span class="sxs-lookup"><span data-stu-id="cdfe8-125">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="cdfe8-126">`out`: este método establece el valor del argumento utilizado como este parámetro.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-126">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="cdfe8-127">`ref`: este método puede establecer el valor del argumento utilizado como este parámetro.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-127">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="cdfe8-128">`in`: este método no modifica el valor del argumento utilizado como este parámetro.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-128">`in`: This method does not modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="cdfe8-129">Agregue el modificador `in` para pasar un argumento por referencia y declare la intención del diseño de pasar argumentos por referencia para evitar la copia innecesaria.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-129">Add the `in` modifier to pass an argument by reference and declare your design intent to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="cdfe8-130">No pretende modificar el objeto usado como ese argumento.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-130">You do not intend to modify the object used as that argument.</span></span> <span data-ttu-id="cdfe8-131">El código siguiente muestra un ejemplo de un método que calcula la distancia entre dos puntos en un espacio 3D.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-131">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span> 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

<span data-ttu-id="cdfe8-132">Los argumentos son dos estructuras que contienen cada una de ellas tres valores dobles.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-132">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="cdfe8-133">Un valor doble tiene 8 bytes, por lo que cada argumento es de 24 bytes.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-133">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="cdfe8-134">Al especificar el modificador `in`, se pasa una referencia de 4 bytes u 8 bytes a esos argumentos, en función de la arquitectura de la máquina.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-134">By specifying the `in` modifier, you pass a 4-byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="cdfe8-135">La diferencia de tamaño es pequeña; sin embargo, puede crecer rápidamente cuando la aplicación llama a este método en un bucle ajustado con muchos valores diferentes.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-135">The difference in size is small, but it can quickly add up when your application calls this method in a tight loop using many different values.</span></span>
 
<span data-ttu-id="cdfe8-136">El modificador `in` complementa también a `out` y `ref` de otras maneras.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-136">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="cdfe8-137">No puede crear sobrecargas de un método que difiere solo en cuanto a la presencia de `in`, `out` o `ref`.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-137">You cannot create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="cdfe8-138">Estas nuevas reglas extienden el mismo comportamiento que siempre se ha definido para los parámetros `out` y `ref`.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-138">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span>

<span data-ttu-id="cdfe8-139">El modificador `in` se puede aplicar a cualquier miembro que toma parámetros: métodos, delegados, expresiones lambda, funciones locales, indexadores u operadores.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-139">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="cdfe8-140">A diferencia de los argumentos `ref` y `out`, puede usar los valores literales o constantes para el argumento en un parámetro `in`.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-140">Unlike `ref` and `out` arguments, you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="cdfe8-141">Además, a diferencia de un parámetro `ref` o `out`, no es necesario aplicar el modificador `in` en el sitio de llamada.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-141">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="cdfe8-142">El código siguiente muestra dos ejemplos de llamada al método `CalculateDistance`.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-142">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="cdfe8-143">El primero usa dos variables locales pasadas por referencia.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-143">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="cdfe8-144">El segundo incluye una variable temporal creada como parte de la llamada al método.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-144">The second includes a temporary variable created as part of the method call.</span></span> 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="cdfe8-145">El compilador tiene varias maneras de asegurarse de que se aplica la naturaleza de solo lectura de un argumento `in`.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-145">There are several ways in which the compiler ensures that the read-only nature of an `in` argument is enforced.</span></span>  <span data-ttu-id="cdfe8-146">En primer lugar, el método llamado no se puede asignar directamente a un parámetro `in`.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-146">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="cdfe8-147">No se puede asignar directamente a ningún campo de un parámetro `in` cuando el valor es un tipo `struct`.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-147">It can't directly assign to any field of an `in` parameter when that value is a `struct` type.</span></span> <span data-ttu-id="cdfe8-148">Además, no puede pasar un parámetro `in` a ningún método que exija el modificador `ref` o `out`.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-148">In addition, you cannot pass an `in` parameter to any method using the `ref` or `out` modifier.</span></span>
<span data-ttu-id="cdfe8-149">Estas reglas se aplican a cualquier campo de un parámetro `in`, siempre que el campo sea un tipo `struct` y el parámetro también sea un tipo `struct`.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-149">These rules apply to any field of an `in` parameter, provided the field is a `struct` type and the parameter is also a `struct` type.</span></span> <span data-ttu-id="cdfe8-150">De hecho, estas reglas se aplican para varios niveles de acceso a miembros, siempre que los tipos en todos los niveles de acceso a miembros sean `structs`.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-150">In fact, these rules apply for multiple layers of member access provided the types at all levels of member access are `structs`.</span></span> <span data-ttu-id="cdfe8-151">El compilador exige que los tipos `struct` que se pasan como argumentos `in` y sus miembros `struct` sean variables de solo lectura cuando se usan como argumentos para otros métodos.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-151">The compiler enforces that `struct` types passed as  `in` arguments and their `struct` members are read-only variables when used as arguments to other methods.</span></span>

<span data-ttu-id="cdfe8-152">El uso de parámetros `in` evita los costos de rendimiento potenciales de realizar copias.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-152">The use of `in` parameters avoids the potential performance costs of making copies.</span></span> <span data-ttu-id="cdfe8-153">No cambia la semántica de ninguna llamada al método.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-153">It does not change the semantics of any method call.</span></span> <span data-ttu-id="cdfe8-154">Por lo tanto, no es necesario especificar el modificador `in` en el sitio de llamada.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-154">Therefore, you do not need to specify the `in` modifier at the call site.</span></span> <span data-ttu-id="cdfe8-155">Sin embargo, si se omite el modificador `in` en el sitio de llamada, se indica al compilador que está permitido realizar una copia del argumento por los motivos siguientes:</span><span class="sxs-lookup"><span data-stu-id="cdfe8-155">However, omitting the `in` modifier at the call site informs the compiler that it is allowed to make a copy of the argument for the following reasons:</span></span>

- <span data-ttu-id="cdfe8-156">Hay una conversión implícita, pero no una conversión de identidad desde el tipo de argumento hacia el tipo de parámetro.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-156">There is an implicit conversion but not an identity conversion from the argument type to the parameter type.</span></span>
- <span data-ttu-id="cdfe8-157">El argumento es una expresión, pero no tiene una variable de almacenamiento conocida.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-157">The argument is an expression but does not have a known storage variable.</span></span>
- <span data-ttu-id="cdfe8-158">Existe una sobrecarga que se diferencia por la presencia o la ausencia de `in`.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-158">An overload exists that differs by the presence or absence of `in`.</span></span> <span data-ttu-id="cdfe8-159">En ese caso, la sobrecarga por valor es una coincidencia mejor.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-159">In that case, the by value overload is a better match.</span></span>

<span data-ttu-id="cdfe8-160">Estas reglas son útiles cuando se actualiza código existente para usar argumentos de referencia de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-160">These rules are useful as you update existing code to use read-only reference arguments.</span></span> <span data-ttu-id="cdfe8-161">En el método llamado, puede llamar a cualquier método de instancia que use parámetros por valor.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-161">Inside the called method, you can call any instance method that uses by value parameters.</span></span> <span data-ttu-id="cdfe8-162">En esos casos, se crea una copia del parámetro `in`.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-162">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="cdfe8-163">Dado que el compilador puede crear una variable temporal para cualquier parámetro `in`, también puede especificar valores predeterminados para cualquier parámetro `in`.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-163">Because the compiler can create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="cdfe8-164">En este código se especifica el origen (punto 0,0) como valor predeterminado para el segundo punto:</span><span class="sxs-lookup"><span data-stu-id="cdfe8-164">The following code specifies the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="cdfe8-165">Para forzar al compilador que pase argumentos de solo lectura por referencia, especifique el modificador `in` en los argumentos en el sitio de llamada, como se muestra en el este código:</span><span class="sxs-lookup"><span data-stu-id="cdfe8-165">To force the compiler to pass read only arguments by reference, specify the `in` modifer on the arguments at the call site, as shown in the following code:</span></span>

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#ExplicitInArgument "Specifying an In argument")]

<span data-ttu-id="cdfe8-166">Con este comportamiento es más fácil adoptar parámetros `in` con el tiempo en grandes bases de código donde es posible mejorar el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-166">This behavior makes it easier to adopt `in` parameters over time in large codebases where performance gains are possible.</span></span> <span data-ttu-id="cdfe8-167">Primero, puede agregar el modificador `in` para las firmas de método.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-167">You add the `in` modifier to method signatures first.</span></span> <span data-ttu-id="cdfe8-168">Después, puede agregar el modificador `in` en sitios de llamada y crear tipos `readonly struct` para permitir al compilador que evite la creación de copias defensivas de parámetros `in` en más ubicaciones.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-168">Then, you can add the `in` modifier at callsites and create `readonly struct` types to enable the compiler to avoid creating defensive copies of `in` parameters in more locations.</span></span>

<span data-ttu-id="cdfe8-169">La designación del parámetro `in` también se puede usar con tipos de referencia o valores numéricos.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-169">The `in` parameter designation can also be used with reference types or numeric values.</span></span> <span data-ttu-id="cdfe8-170">Sin embargo, las ventajas de ambos casos son mínimas, si las hay.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-170">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="ref-readonly-returns"></a><span data-ttu-id="cdfe8-171">Devoluciones de `ref readonly`</span><span class="sxs-lookup"><span data-stu-id="cdfe8-171">`ref readonly` returns</span></span>

<span data-ttu-id="cdfe8-172">También puede querer devolver un tipo de valor por referencia, pero no permitir que el llamador modifique ese valor.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-172">You may also want to return a value type by reference, but disallow the caller from modifying that value.</span></span> <span data-ttu-id="cdfe8-173">Use el modificador `ref readonly` para expresar la intención del diseño.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-173">Use the `ref readonly` modifier to express that design intent.</span></span> <span data-ttu-id="cdfe8-174">Esto notifica a los lectores que devuelve una referencia a los datos existentes, pero no permite la modificación.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-174">It notifies readers that you are returning a reference to existing data, but not allowing modification.</span></span> 

<span data-ttu-id="cdfe8-175">El compilador exige que el llamador no pueda modificar la referencia.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-175">The compiler enforces that the caller cannot modify the reference.</span></span> <span data-ttu-id="cdfe8-176">Los intentos de asignar el valor directamente generan un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-176">Attempts to assign the value directly generate a compile-time error.</span></span> <span data-ttu-id="cdfe8-177">Sin embargo, el compilador no puede saber si algún método de miembro modifica el estado de la estructura.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-177">However, the compiler cannot know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="cdfe8-178">Para asegurarse de que el objeto no se modifica, el compilador crea una copia y llama a las referencias de miembro usando esa copia.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-178">To ensure that the object is not modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="cdfe8-179">Las modificaciones se realizan sobre esa copia defensiva.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-179">Any modifications are to that defensive copy.</span></span> 

<span data-ttu-id="cdfe8-180">Es probable que la biblioteca con `Point3D` utilice a menudo el origen en todo el código.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-180">It's likely that the library using `Point3D` would often use the origin throughout the code.</span></span> <span data-ttu-id="cdfe8-181">Cada instancia crea un nuevo objeto en la pila.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-181">Every instance creates a new object on the stack.</span></span> <span data-ttu-id="cdfe8-182">Puede ser conveniente crear una constante y devolverla por referencia.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-182">It may be advantageous to create a constant and return it by reference.</span></span> <span data-ttu-id="cdfe8-183">Sin embargo, si se devuelve una referencia al almacenamiento interno, es posible que desee exigir que el llamador no pueda modificar el almacenamiento al que se hace referencia.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-183">But, if you return a reference to internal storage, you may want to enforce that the caller cannot modify the referenced storage.</span></span> <span data-ttu-id="cdfe8-184">El código siguiente define una propiedad de solo lectura que devuelve `readonly ref` a `Point3D` que especifica el origen.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-184">The following code defines a read-only property that returns a `readonly ref` to a `Point3D` that specifies the origin.</span></span>

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

<span data-ttu-id="cdfe8-185">La creación de una copia de una devolución de solo lectura de referencia es fácil: basta con asignarla a una variable no declarada con el modificador `ref readonly`.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-185">Creating a copy of a ref readonly return is easy: Just assign it to a variable not declared with the `ref readonly` modifier.</span></span> <span data-ttu-id="cdfe8-186">El compilador genera código para copiar el objeto como parte de la asignación.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-186">The compiler generates code to copy the object as part of the assignment.</span></span> 

<span data-ttu-id="cdfe8-187">Al asignar una variable a `ref readonly return`, puede especificar una variable `ref readonly` o una copia por valor de la referencia de solo lectura:</span><span class="sxs-lookup"><span data-stu-id="cdfe8-187">When you assign a variable to a `ref readonly return`, you can specify either a `ref readonly` variable, or a by-value copy of the read-only reference:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="cdfe8-188">La primera asignación en el código anterior realiza una copia de la constante `Origin` y asigna esa copia.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-188">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="cdfe8-189">La segunda asigna una referencia.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-189">The second assigns a reference.</span></span> <span data-ttu-id="cdfe8-190">Tenga en cuenta que el modificador `readonly` debe formar parte de la declaración de la variable.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-190">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="cdfe8-191">No se puede modificar la referencia a la que alude.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-191">The reference to which it refers can't be modified.</span></span> <span data-ttu-id="cdfe8-192">Los intentos de hacerlo generarán un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-192">Attempts to do so result in a compile-time error.</span></span>

## <a name="readonly-struct-type"></a><span data-ttu-id="cdfe8-193">Tipo de `readonly struct`</span><span class="sxs-lookup"><span data-stu-id="cdfe8-193">`readonly struct` type</span></span>

<span data-ttu-id="cdfe8-194">La aplicación de `ref readonly` a usos de tráfico elevado de una estructura puede ser suficiente.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-194">Applying `ref readonly` to high-traffic uses of a struct may be sufficient.</span></span>
<span data-ttu-id="cdfe8-195">En otras ocasiones, quizá desee crear una estructura inmutable.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-195">Other times, you may want to create an immutable struct.</span></span> <span data-ttu-id="cdfe8-196">Así puede pasar siempre por referencia de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-196">Then you can always pass by read-only reference.</span></span> <span data-ttu-id="cdfe8-197">Esa práctica quita las copias defensivas que tienen lugar cuando se tiene acceso a métodos de una estructura que se utiliza como un parámetro `in`.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-197">That practice removes the defensive copies that take place when you access methods of a struct used as an `in` parameter.</span></span>

<span data-ttu-id="cdfe8-198">Puede hacerlo mediante la creación de un tipo `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-198">You can do that by creating a `readonly struct` type.</span></span> <span data-ttu-id="cdfe8-199">Puede agregar el modificador `readonly` en una declaración de estructura.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-199">You can add the `readonly` modifier to a struct declaration.</span></span> <span data-ttu-id="cdfe8-200">El compilador exige que todos los miembros de instancia de la estructura sean `readonly`; `struct` debe ser inmutable.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-200">The compiler enforces that all instance members of the struct are `readonly`; the `struct` must be immutable.</span></span>

<span data-ttu-id="cdfe8-201">Hay otras optimizaciones para `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-201">There are other optimizations for a `readonly struct`.</span></span> <span data-ttu-id="cdfe8-202">Puede usar el modificador `in` en todas las ubicaciones donde `readonly struct` es un argumento.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-202">You can use the `in` modifier at every location where a `readonly struct` is an argument.</span></span> <span data-ttu-id="cdfe8-203">Además, puede devolver `readonly struct` como `ref return` cuando devuelva un objeto cuya duración se extiende más allá del ámbito del método que devuelve del objeto.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-203">In addition, you can return a `readonly struct` as a `ref return` when you are returning an object whose lifetime extends beyond the scope of the method returning the object.</span></span>

<span data-ttu-id="cdfe8-204">Por último, el compilador genera código más eficaz cuando se llama a los miembros de `readonly struct`: la referencia `this`, en lugar de una copia del receptor, siempre es un parámetro `in` pasado por referencia al método de miembro.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-204">Finally, the compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="cdfe8-205">Esta optimización ahorra más procesos de copia cuando utiliza `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-205">This optimization saves more copying when you use a `readonly struct`.</span></span> <span data-ttu-id="cdfe8-206">Este valor `Point3D` es un excelente candidato para este cambio.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-206">The `Point3D` is a great candidate for this change.</span></span> <span data-ttu-id="cdfe8-207">El código siguiente muestra una estructura actualizada de `ReadonlyPoint3D`:</span><span class="sxs-lookup"><span data-stu-id="cdfe8-207">The following code shows an updated `ReadonlyPoint3D` structure:</span></span>

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a><span data-ttu-id="cdfe8-208">Tipo de `ref struct`</span><span class="sxs-lookup"><span data-stu-id="cdfe8-208">`ref struct` type</span></span>

<span data-ttu-id="cdfe8-209">Otra característica de lenguaje relacionada es la capacidad de declarar un tipo de valor que debe estar asignado a la pila.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-209">Another related language feature is the ability to declare a value type that must be stack allocated.</span></span> <span data-ttu-id="cdfe8-210">En otras palabras, estos tipos no se pueden crear nunca en el montón como miembro de otra clase.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-210">In other words, these types can never be created on the heap as a member of another class.</span></span> <span data-ttu-id="cdfe8-211">La principal motivación para esta característica era <xref:System.Span%601> y las estructuras relacionadas.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-211">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="cdfe8-212"><xref:System.Span%601> puede contener un puntero administrado como uno de sus miembros, siendo el otro la longitud del intervalo.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-212"><xref:System.Span%601> may contain a managed pointer as one of its members, the other being the length of the span.</span></span> <span data-ttu-id="cdfe8-213">Se implementa de manera un poco diferente porque C# no admite punteros a la memoria administrada fuera de un contexto no seguro.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-213">It's implemented a bit differently because C# doesn't support pointers to managed memory outside of an unsafe context.</span></span> <span data-ttu-id="cdfe8-214">Cualquier escritura que cambie el puntero y la longitud no es atómica.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-214">Any write that changes the pointer and the length is not atomic.</span></span> <span data-ttu-id="cdfe8-215">Es decir, un valor de <xref:System.Span%601> estaría sujeto a errores de fuera de intervalo o infracciones de seguridad de otro tipo cuando no se limita a un único marco de pila.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-215">That means a <xref:System.Span%601> would be subject to out of range errors or other type safety violations were it not constrained to a single stack frame.</span></span> <span data-ttu-id="cdfe8-216">Además, la colocación de un puntero administrado en el montón de GC normalmente se bloquea en tiempo JIT.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-216">In addition, putting a managed pointer on the GC heap typically crashes at JIT time.</span></span>

<span data-ttu-id="cdfe8-217">Puede tener requisitos similares al trabajar con memoria creada mediante [`stackalloc`](language-reference/keywords/stackalloc.md) o al usar memoria de las API de interoperabilidad.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-217">You may have similar requirements working with memory created using [`stackalloc`](language-reference/keywords/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="cdfe8-218">Puede definir sus propios tipos de `ref struct` para esas necesidades.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-218">You can define your own `ref struct` types for those needs.</span></span> <span data-ttu-id="cdfe8-219">En este artículo, verá ejemplos del uso de `Span<T>` por hacerlo más sencillo.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-219">In this article, you see examples using `Span<T>` for simplicity.</span></span>

<span data-ttu-id="cdfe8-220">La declaración `ref struct` declara que una estructura de este tipo debe estar en la pila.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-220">The `ref struct` declaration declares a struct of this type must be on the stack.</span></span> <span data-ttu-id="cdfe8-221">Las reglas de lenguaje garantizan el uso seguro de estos tipos.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-221">The language rules ensure the safe use of these types.</span></span> <span data-ttu-id="cdfe8-222">Entre otros tipos declarados como `ref struct` se encuentra <xref:System.ReadOnlySpan%601>.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-222">Other types declared as `ref struct` include <xref:System.ReadOnlySpan%601>.</span></span> 

<span data-ttu-id="cdfe8-223">El objetivo de mantener un tipo `ref struct` como una variable asignada a la pila presenta varias reglas que el compilador exige para todos los tipos `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-223">The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.</span></span>

- <span data-ttu-id="cdfe8-224">No puede encerrar un valor de `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-224">You can't box a `ref struct`.</span></span> <span data-ttu-id="cdfe8-225">No puede asignar un tipo `ref struct` a una variable de tipo `object`, `dynamic` o cualquier tipo de interfaz.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-225">You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.</span></span>
- <span data-ttu-id="cdfe8-226">No puede declarar un `ref struct` como miembro de una clase o una estructura normal.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-226">You can't declare a `ref struct` as a member of a class or a normal struct.</span></span>
- <span data-ttu-id="cdfe8-227">No puede declarar variables locales que sean tipos `ref struct` en métodos asincrónicos.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-227">You cannot declare local variables that are `ref struct` types in async methods.</span></span> <span data-ttu-id="cdfe8-228">Pueden declararlas en los métodos sincrónicos que devuelven `Task`, `Task<T>` o tipos similares a la tarea.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-228">You can declare them in synchronous methods that return `Task`, `Task<T>` or Task-like types.</span></span>
- <span data-ttu-id="cdfe8-229">No puede declarar las variables locales de `ref struct` en iteradores.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-229">You cannot declare `ref struct` local variables in iterators.</span></span>
- <span data-ttu-id="cdfe8-230">No puede capturar variables `ref struct` en expresiones lambda o funciones locales.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-230">You cannot capture `ref struct` variables in lambda expressions or local functions.</span></span>

<span data-ttu-id="cdfe8-231">Estas restricciones aseguran que no se usará por error un valor `ref struct` de manera que pueda promoverlo al montón administrado.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-231">These restrictions ensure you do not accidentally use a `ref struct` in a manner that could promote it to the managed heap.</span></span>

## <a name="readonly-ref-struct-type"></a><span data-ttu-id="cdfe8-232">Tipo de `readonly ref struct`</span><span class="sxs-lookup"><span data-stu-id="cdfe8-232">`readonly ref struct` type</span></span>

<span data-ttu-id="cdfe8-233">Si declara una estructura como `readonly ref` se combinan las ventajas y las restricciones de las declaraciones `ref struct` y `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-233">Declaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` delcarations.</span></span> 

<span data-ttu-id="cdfe8-234">En el siguiente ejemplo se muestra la declaración de `readonly ref struct`.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-234">The following example demonstrates the declaration of `readonly ref struct`.</span></span>

```csharp
readonly ref struct ReadOnlyRefPoint2D
{
    public int X { get; }
    public int Y { get; }
    
    public ReadOnlyRefPoint2D(int x, int y) => (X, Y) = (x, y);
}
```

## <a name="conclusions"></a><span data-ttu-id="cdfe8-235">Conclusiones</span><span class="sxs-lookup"><span data-stu-id="cdfe8-235">Conclusions</span></span>

<span data-ttu-id="cdfe8-236">Estas mejoras del lenguaje C# están diseñadas para algoritmos críticos de rendimiento donde las asignaciones de memoria pueden resultar fundamentales para lograr el rendimiento necesario.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-236">These enhancements to the C# language are designed for performance critical algorithms where memory allocations can be critical to achieving the necessary performance.</span></span> <span data-ttu-id="cdfe8-237">Es posible que no use a menudo estas características en el código que escribe.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-237">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="cdfe8-238">Sin embargo, estas mejoras se adoptaron en muchas ubicaciones en .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-238">However, these enhancements have been adopted in many locations in the .NET Framework.</span></span> <span data-ttu-id="cdfe8-239">Dado que cada vez son más las API que utilizan estas características, comprobará que mejora el rendimiento de sus propias aplicaciones.</span><span class="sxs-lookup"><span data-stu-id="cdfe8-239">As more and more APIs make use of these features, you'll see the performance of your own applications improve.</span></span>
