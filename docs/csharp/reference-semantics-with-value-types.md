---
title: Semántica de referencia con tipos de valor
description: Conozca las características del lenguaje que reducen al mínimo la copia de las estructuras de manera segura.
ms.date: 11/10/2017
ms.custom: mvc
ms.openlocfilehash: f241219994d7a03192a4aea69b912bf1ac5ed29c
ms.sourcegitcommit: e614e0f3b031293e4107f37f752be43652f3f253
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 08/26/2018
ms.locfileid: "42930654"
---
# <a name="reference-semantics-with-value-types"></a><span data-ttu-id="edb32-103">Semántica de referencia con tipos de valor</span><span class="sxs-lookup"><span data-stu-id="edb32-103">Reference semantics with value types</span></span>

<span data-ttu-id="edb32-104">Una ventaja de utilizar tipos de valor es que a menudo evitan las asignaciones del montón.</span><span class="sxs-lookup"><span data-stu-id="edb32-104">An advantage to using value types is that they often avoid heap allocations.</span></span>
<span data-ttu-id="edb32-105">La desventaja es que se copian por valor.</span><span class="sxs-lookup"><span data-stu-id="edb32-105">The disadvantage is that they are copied by value.</span></span> <span data-ttu-id="edb32-106">Este último aspecto dificulta la optimización de los algoritmos que funcionan en grandes cantidades de datos.</span><span class="sxs-lookup"><span data-stu-id="edb32-106">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="edb32-107">Las nuevas características del lenguaje en C# 7.2 proporcionan mecanismos que habilitan la semántica de paso por referencia con tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="edb32-107">New language features in C# 7.2 provide mechanisms that enable pass-by-reference semantics with value types.</span></span> <span data-ttu-id="edb32-108">Use estas características acertadamente para minimizar tanto las asignaciones como las operaciones de copia.</span><span class="sxs-lookup"><span data-stu-id="edb32-108">Use these features wisely to minimize both allocations and copy operations.</span></span> <span data-ttu-id="edb32-109">En este artículo se exploran estas nuevas características.</span><span class="sxs-lookup"><span data-stu-id="edb32-109">This article explores those new features.</span></span>

<span data-ttu-id="edb32-110">Gran parte del código de ejemplo de este artículo muestra características agregadas en C# 7.2.</span><span class="sxs-lookup"><span data-stu-id="edb32-110">Much of the sample code in this article demonstrates features added in C# 7.2.</span></span> <span data-ttu-id="edb32-111">Para poder usar esas características, tendrá que configurar el proyecto para que use C# 7.2 o una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="edb32-111">In order to use those features, you must configure your project to use C# 7.2 or later.</span></span> <span data-ttu-id="edb32-112">Para obtener más información sobre cómo establecer la versión del lenguaje, vea [Configurar la versión del lenguaje](language-reference/configure-language-version.md).</span><span class="sxs-lookup"><span data-stu-id="edb32-112">For more information on setting the language version see [configure the language version](language-reference/configure-language-version.md).</span></span>

## <a name="passing-arguments-by-readonly-reference"></a><span data-ttu-id="edb32-113">Pasar argumentos por referencia de solo lectura</span><span class="sxs-lookup"><span data-stu-id="edb32-113">Passing arguments by readonly reference</span></span>

<span data-ttu-id="edb32-114">C# 7.2 agrega la palabra clave `in` para complementar las palabras clave `ref` y `out` existentes para pasar argumentos por referencia.</span><span class="sxs-lookup"><span data-stu-id="edb32-114">C# 7.2 adds the `in` keyword to complement the existing `ref` and `out` keywords to pass arguments by reference.</span></span> <span data-ttu-id="edb32-115">La palabra clave `in` especifica que se pasa el argumento por referencia, pero el método llamado no modifica el valor.</span><span class="sxs-lookup"><span data-stu-id="edb32-115">The `in` keyword specifies passing the argument by reference, but the called method does not modify the value.</span></span> 

<span data-ttu-id="edb32-116">Esta novedad proporciona un vocabulario completo para expresar la intención del diseño.</span><span class="sxs-lookup"><span data-stu-id="edb32-116">This addition provides a full vocabulary to express your design intent.</span></span> <span data-ttu-id="edb32-117">Los tipos de valor se copian al pasarlos a un método llamado cuando no se especifica ninguno de los siguientes modificadores en la firma de método.</span><span class="sxs-lookup"><span data-stu-id="edb32-117">Value types are copied when passed to a called method when you don't specify any of the following modifiers in the method signature.</span></span> <span data-ttu-id="edb32-118">Cada uno de estos modificadores especifica que un tipo de valor se pasa por referencia, evitando la copia.</span><span class="sxs-lookup"><span data-stu-id="edb32-118">Each of these modifiers specifies that a value type is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="edb32-119">Cada modificador expresa un propósito diferente:</span><span class="sxs-lookup"><span data-stu-id="edb32-119">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="edb32-120">`out`: este método establece el valor del argumento utilizado como este parámetro.</span><span class="sxs-lookup"><span data-stu-id="edb32-120">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="edb32-121">`ref`: este método puede establecer el valor del argumento utilizado como este parámetro.</span><span class="sxs-lookup"><span data-stu-id="edb32-121">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="edb32-122">`in`: este método no modifica el valor del argumento utilizado como este parámetro.</span><span class="sxs-lookup"><span data-stu-id="edb32-122">`in`: This method does not modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="edb32-123">Agregue el modificador `in` para pasar un argumento por referencia y declare la intención del diseño de pasar argumentos por referencia para evitar la copia innecesaria.</span><span class="sxs-lookup"><span data-stu-id="edb32-123">Add the `in` modifier to pass an argument by reference and declare your design intent to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="edb32-124">No pretende modificar el objeto usado como ese argumento.</span><span class="sxs-lookup"><span data-stu-id="edb32-124">You do not intend to modify the object used as that argument.</span></span> <span data-ttu-id="edb32-125">El código siguiente muestra un ejemplo de un método que calcula la distancia entre dos puntos en un espacio 3D.</span><span class="sxs-lookup"><span data-stu-id="edb32-125">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span> 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

<span data-ttu-id="edb32-126">Los argumentos son dos estructuras que contienen cada una de ellas tres valores dobles.</span><span class="sxs-lookup"><span data-stu-id="edb32-126">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="edb32-127">Un valor doble tiene 8 bytes, por lo que cada argumento es de 24 bytes.</span><span class="sxs-lookup"><span data-stu-id="edb32-127">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="edb32-128">Al especificar el modificador `in`, se pasa una referencia de 4 bytes u 8 bytes a esos argumentos, en función de la arquitectura de la máquina.</span><span class="sxs-lookup"><span data-stu-id="edb32-128">By specifying the `in` modifier, you pass a 4-byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="edb32-129">La diferencia de tamaño es pequeña; sin embargo, puede crecer rápidamente cuando la aplicación llama a este método en un bucle ajustado con muchos valores diferentes.</span><span class="sxs-lookup"><span data-stu-id="edb32-129">The difference in size is small, but it can quickly add up when your application calls this method in a tight loop using many different values.</span></span>
 
<span data-ttu-id="edb32-130">El modificador `in` complementa también a `out` y `ref` de otras maneras.</span><span class="sxs-lookup"><span data-stu-id="edb32-130">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="edb32-131">No puede crear sobrecargas de un método que difiere solo en cuanto a la presencia de `in`, `out` o `ref`.</span><span class="sxs-lookup"><span data-stu-id="edb32-131">You cannot create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="edb32-132">Estas nuevas reglas extienden el mismo comportamiento que siempre se ha definido para los parámetros `out` y `ref`.</span><span class="sxs-lookup"><span data-stu-id="edb32-132">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span>

<span data-ttu-id="edb32-133">El modificador `in` se puede aplicar a cualquier miembro que toma parámetros: métodos, delegados, expresiones lambda, funciones locales, indexadores u operadores.</span><span class="sxs-lookup"><span data-stu-id="edb32-133">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="edb32-134">A diferencia de los argumentos `ref` y `out`, puede usar los valores literales o constantes para el argumento en un parámetro `in`.</span><span class="sxs-lookup"><span data-stu-id="edb32-134">Unlike `ref` and `out` arguments, you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="edb32-135">Además, a diferencia de un parámetro `ref` o `out`, no es necesario aplicar el modificador `in` en el sitio de llamada.</span><span class="sxs-lookup"><span data-stu-id="edb32-135">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="edb32-136">El código siguiente muestra dos ejemplos de llamada al método `CalculateDistance`.</span><span class="sxs-lookup"><span data-stu-id="edb32-136">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="edb32-137">El primero usa dos variables locales pasadas por referencia.</span><span class="sxs-lookup"><span data-stu-id="edb32-137">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="edb32-138">El segundo incluye una variable temporal creada como parte de la llamada al método.</span><span class="sxs-lookup"><span data-stu-id="edb32-138">The second includes a temporary variable created as part of the method call.</span></span> 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="edb32-139">El compilador tiene varias maneras de asegurarse de que se aplica la naturaleza de solo lectura de un argumento `in`.</span><span class="sxs-lookup"><span data-stu-id="edb32-139">There are several ways in which the compiler ensures that the read-only nature of an `in` argument is enforced.</span></span>  <span data-ttu-id="edb32-140">En primer lugar, el método llamado no se puede asignar directamente a un parámetro `in`.</span><span class="sxs-lookup"><span data-stu-id="edb32-140">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="edb32-141">No se puede asignar directamente a ningún campo de un parámetro `in` cuando el valor es un tipo `struct`.</span><span class="sxs-lookup"><span data-stu-id="edb32-141">It can't directly assign to any field of an `in` parameter when that value is a `struct` type.</span></span> <span data-ttu-id="edb32-142">Además, no puede pasar un parámetro `in` a ningún método que exija el modificador `ref` o `out`.</span><span class="sxs-lookup"><span data-stu-id="edb32-142">In addition, you cannot pass an `in` parameter to any method using the `ref` or `out` modifier.</span></span>
<span data-ttu-id="edb32-143">Estas reglas se aplican a cualquier campo de un parámetro `in`, siempre que el campo sea un tipo `struct` y el parámetro también sea un tipo `struct`.</span><span class="sxs-lookup"><span data-stu-id="edb32-143">These rules apply to any field of an `in` parameter, provided the field is a `struct` type and the parameter is also a `struct` type.</span></span> <span data-ttu-id="edb32-144">De hecho, estas reglas se aplican para varios niveles de acceso a miembros, siempre que los tipos en todos los niveles de acceso a miembros sean `structs`.</span><span class="sxs-lookup"><span data-stu-id="edb32-144">In fact, these rules apply for multiple layers of member access provided the types at all levels of member access are `structs`.</span></span> <span data-ttu-id="edb32-145">El compilador exige que los tipos `struct` que se pasan como argumentos `in` y sus miembros `struct` sean variables de solo lectura cuando se usan como argumentos para otros métodos.</span><span class="sxs-lookup"><span data-stu-id="edb32-145">The compiler enforces that `struct` types passed as  `in` arguments and their `struct` members are read-only variables when used as arguments to other methods.</span></span>

<span data-ttu-id="edb32-146">El uso de parámetros `in` evita los costos de rendimiento potenciales de realizar copias.</span><span class="sxs-lookup"><span data-stu-id="edb32-146">The use of `in` parameters avoids the potential performance costs of making copies.</span></span> <span data-ttu-id="edb32-147">No cambia la semántica de ninguna llamada al método.</span><span class="sxs-lookup"><span data-stu-id="edb32-147">It does not change the semantics of any method call.</span></span> <span data-ttu-id="edb32-148">Por lo tanto, no es necesario especificar el modificador `in` en el sitio de llamada.</span><span class="sxs-lookup"><span data-stu-id="edb32-148">Therefore, you do not need to specify the `in` modifier at the call site.</span></span> <span data-ttu-id="edb32-149">Sin embargo, si se omite el modificador `in` en el sitio de llamada, se indica al compilador que está permitido realizar una copia del argumento por los motivos siguientes:</span><span class="sxs-lookup"><span data-stu-id="edb32-149">However, omitting the `in` modifier at the call site informs the compiler that it is allowed to make a copy of the argument for the following reasons:</span></span>

- <span data-ttu-id="edb32-150">Hay una conversión implícita, pero no una conversión de identidad desde el tipo de argumento hacia el tipo de parámetro.</span><span class="sxs-lookup"><span data-stu-id="edb32-150">There is an implicit conversion but not an identity conversion from the argument type to the parameter type.</span></span>
- <span data-ttu-id="edb32-151">El argumento es una expresión, pero no tiene una variable de almacenamiento conocida.</span><span class="sxs-lookup"><span data-stu-id="edb32-151">The argument is an expression but does not have a known storage variable.</span></span>
- <span data-ttu-id="edb32-152">Existe una sobrecarga que se diferencia por la presencia o la ausencia de `in`.</span><span class="sxs-lookup"><span data-stu-id="edb32-152">An overload exists that differs by the presence or absence of `in`.</span></span> <span data-ttu-id="edb32-153">En ese caso, la sobrecarga por valor es una coincidencia mejor.</span><span class="sxs-lookup"><span data-stu-id="edb32-153">In that case, the by value overload is a better match.</span></span>

<span data-ttu-id="edb32-154">Estas reglas son útiles cuando se actualiza código existente para usar argumentos de referencia de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="edb32-154">These rules are useful as you update existing code to use read-only reference arguments.</span></span> <span data-ttu-id="edb32-155">En el método llamado, puede llamar a cualquier método de instancia que use parámetros por valor.</span><span class="sxs-lookup"><span data-stu-id="edb32-155">Inside the called method, you can call any instance method that uses by value parameters.</span></span> <span data-ttu-id="edb32-156">En esos casos, se crea una copia del parámetro `in`.</span><span class="sxs-lookup"><span data-stu-id="edb32-156">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="edb32-157">Dado que el compilador puede crear una variable temporal para cualquier parámetro `in`, también puede especificar valores predeterminados para cualquier parámetro `in`.</span><span class="sxs-lookup"><span data-stu-id="edb32-157">Because the compiler can create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="edb32-158">En este código se especifica el origen (punto 0,0) como valor predeterminado para el segundo punto:</span><span class="sxs-lookup"><span data-stu-id="edb32-158">The following code specifies the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="edb32-159">Para forzar al compilador que pase argumentos de solo lectura por referencia, especifique el modificador `in` en los argumentos en el sitio de llamada, como se muestra en el este código:</span><span class="sxs-lookup"><span data-stu-id="edb32-159">To force the compiler to pass read only arguments by reference, specify the `in` modifer on the arguments at the call site, as shown in the following code:</span></span>

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#ExplicitInArgument "Specifying an In argument")]

<span data-ttu-id="edb32-160">Con este comportamiento es más fácil adoptar parámetros `in` con el tiempo en grandes bases de código donde es posible mejorar el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="edb32-160">This behavior makes it easier to adopt `in` parameters over time in large codebases where performance gains are possible.</span></span> <span data-ttu-id="edb32-161">Primero, puede agregar el modificador `in` para las firmas de método.</span><span class="sxs-lookup"><span data-stu-id="edb32-161">You add the `in` modifier to method signatures first.</span></span> <span data-ttu-id="edb32-162">Después, puede agregar el modificador `in` en sitios de llamada y crear tipos `readonly struct` para permitir al compilador que evite la creación de copias defensivas de parámetros `in` en más ubicaciones.</span><span class="sxs-lookup"><span data-stu-id="edb32-162">Then, you can add the `in` modifier at callsites and create `readonly struct` types to enable the compiler to avoid creating defensive copies of `in` parameters in more locations.</span></span>

<span data-ttu-id="edb32-163">La designación del parámetro `in` también se puede usar con tipos de referencia o valores numéricos.</span><span class="sxs-lookup"><span data-stu-id="edb32-163">The `in` parameter designation can also be used with reference types or numeric values.</span></span> <span data-ttu-id="edb32-164">Sin embargo, las ventajas de ambos casos son mínimas, si las hay.</span><span class="sxs-lookup"><span data-stu-id="edb32-164">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="ref-readonly-returns"></a><span data-ttu-id="edb32-165">Devoluciones de `ref readonly`</span><span class="sxs-lookup"><span data-stu-id="edb32-165">`ref readonly` returns</span></span>

<span data-ttu-id="edb32-166">También puede querer devolver un tipo de valor por referencia, pero no permitir que el llamador modifique ese valor.</span><span class="sxs-lookup"><span data-stu-id="edb32-166">You may also want to return a value type by reference, but disallow the caller from modifying that value.</span></span> <span data-ttu-id="edb32-167">Use el modificador `ref readonly` para expresar la intención del diseño.</span><span class="sxs-lookup"><span data-stu-id="edb32-167">Use the `ref readonly` modifier to express that design intent.</span></span> <span data-ttu-id="edb32-168">Esto notifica a los lectores que devuelve una referencia a los datos existentes, pero no permite la modificación.</span><span class="sxs-lookup"><span data-stu-id="edb32-168">It notifies readers that you are returning a reference to existing data, but not allowing modification.</span></span> 

<span data-ttu-id="edb32-169">El compilador exige que el llamador no pueda modificar la referencia.</span><span class="sxs-lookup"><span data-stu-id="edb32-169">The compiler enforces that the caller cannot modify the reference.</span></span> <span data-ttu-id="edb32-170">Los intentos de asignar el valor directamente generan un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="edb32-170">Attempts to assign the value directly generate a compile-time error.</span></span> <span data-ttu-id="edb32-171">Sin embargo, el compilador no puede saber si algún método de miembro modifica el estado de la estructura.</span><span class="sxs-lookup"><span data-stu-id="edb32-171">However, the compiler cannot know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="edb32-172">Para asegurarse de que el objeto no se modifica, el compilador crea una copia y llama a las referencias de miembro usando esa copia.</span><span class="sxs-lookup"><span data-stu-id="edb32-172">To ensure that the object is not modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="edb32-173">Las modificaciones se realizan sobre esa copia defensiva.</span><span class="sxs-lookup"><span data-stu-id="edb32-173">Any modifications are to that defensive copy.</span></span> 

<span data-ttu-id="edb32-174">Es probable que la biblioteca con `Point3D` utilice a menudo el origen en todo el código.</span><span class="sxs-lookup"><span data-stu-id="edb32-174">It's likely that the library using `Point3D` would often use the origin throughout the code.</span></span> <span data-ttu-id="edb32-175">Cada instancia crea un nuevo objeto en la pila.</span><span class="sxs-lookup"><span data-stu-id="edb32-175">Every instance creates a new object on the stack.</span></span> <span data-ttu-id="edb32-176">Puede ser conveniente crear una constante y devolverla por referencia.</span><span class="sxs-lookup"><span data-stu-id="edb32-176">It may be advantageous to create a constant and return it by reference.</span></span> <span data-ttu-id="edb32-177">Sin embargo, si se devuelve una referencia al almacenamiento interno, es posible que desee exigir que el llamador no pueda modificar el almacenamiento al que se hace referencia.</span><span class="sxs-lookup"><span data-stu-id="edb32-177">But, if you return a reference to internal storage, you may want to enforce that the caller cannot modify the referenced storage.</span></span> <span data-ttu-id="edb32-178">El código siguiente define una propiedad de solo lectura que devuelve `readonly ref` a `Point3D` que especifica el origen.</span><span class="sxs-lookup"><span data-stu-id="edb32-178">The following code defines a read-only property that returns a `readonly ref` to a `Point3D` that specifies the origin.</span></span>

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

<span data-ttu-id="edb32-179">La creación de una copia de una devolución de solo lectura de referencia es fácil: basta con asignarla a una variable no declarada con el modificador `ref readonly`.</span><span class="sxs-lookup"><span data-stu-id="edb32-179">Creating a copy of a ref readonly return is easy: Just assign it to a variable not declared with the `ref readonly` modifier.</span></span> <span data-ttu-id="edb32-180">El compilador genera código para copiar el objeto como parte de la asignación.</span><span class="sxs-lookup"><span data-stu-id="edb32-180">The compiler generates code to copy the object as part of the assignment.</span></span> 

<span data-ttu-id="edb32-181">Al asignar una variable a `ref readonly return`, puede especificar una variable `ref readonly` o una copia por valor de la referencia de solo lectura:</span><span class="sxs-lookup"><span data-stu-id="edb32-181">When you assign a variable to a `ref readonly return`, you can specify either a `ref readonly` variable, or a by-value copy of the read-only reference:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="edb32-182">La primera asignación en el código anterior realiza una copia de la constante `Origin` y asigna esa copia.</span><span class="sxs-lookup"><span data-stu-id="edb32-182">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="edb32-183">La segunda asigna una referencia.</span><span class="sxs-lookup"><span data-stu-id="edb32-183">The second assigns a reference.</span></span> <span data-ttu-id="edb32-184">Tenga en cuenta que el modificador `readonly` debe formar parte de la declaración de la variable.</span><span class="sxs-lookup"><span data-stu-id="edb32-184">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="edb32-185">No se puede modificar la referencia a la que alude.</span><span class="sxs-lookup"><span data-stu-id="edb32-185">The reference to which it refers can't be modified.</span></span> <span data-ttu-id="edb32-186">Los intentos de hacerlo generarán un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="edb32-186">Attempts to do so result in a compile-time error.</span></span>

## <a name="readonly-struct-type"></a><span data-ttu-id="edb32-187">Tipo de `readonly struct`</span><span class="sxs-lookup"><span data-stu-id="edb32-187">`readonly struct` type</span></span>

<span data-ttu-id="edb32-188">La aplicación de `ref readonly` a usos de tráfico elevado de una estructura puede ser suficiente.</span><span class="sxs-lookup"><span data-stu-id="edb32-188">Applying `ref readonly` to high-traffic uses of a struct may be sufficient.</span></span>
<span data-ttu-id="edb32-189">En otras ocasiones, quizá desee crear una estructura inmutable.</span><span class="sxs-lookup"><span data-stu-id="edb32-189">Other times, you may want to create an immutable struct.</span></span> <span data-ttu-id="edb32-190">Así puede pasar siempre por referencia de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="edb32-190">Then you can always pass by read-only reference.</span></span> <span data-ttu-id="edb32-191">Esa práctica quita las copias defensivas que tienen lugar cuando se tiene acceso a métodos de una estructura que se utiliza como un parámetro `in`.</span><span class="sxs-lookup"><span data-stu-id="edb32-191">That practice removes the defensive copies that take place when you access methods of a struct used as an `in` parameter.</span></span>

<span data-ttu-id="edb32-192">Puede hacerlo mediante la creación de un tipo `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="edb32-192">You can do that by creating a `readonly struct` type.</span></span> <span data-ttu-id="edb32-193">Puede agregar el modificador `readonly` en una declaración de estructura.</span><span class="sxs-lookup"><span data-stu-id="edb32-193">You can add the `readonly` modifier to a struct declaration.</span></span> <span data-ttu-id="edb32-194">El compilador exige que todos los miembros de instancia de la estructura sean `readonly`; `struct` debe ser inmutable.</span><span class="sxs-lookup"><span data-stu-id="edb32-194">The compiler enforces that all instance members of the struct are `readonly`; the `struct` must be immutable.</span></span>

<span data-ttu-id="edb32-195">Hay otras optimizaciones para `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="edb32-195">There are other optimizations for a `readonly struct`.</span></span> <span data-ttu-id="edb32-196">Puede usar el modificador `in` en todas las ubicaciones donde `readonly struct` es un argumento.</span><span class="sxs-lookup"><span data-stu-id="edb32-196">You can use the `in` modifier at every location where a `readonly struct` is an argument.</span></span> <span data-ttu-id="edb32-197">Además, puede devolver `readonly struct` como `ref return` cuando devuelva un objeto cuya duración se extiende más allá del ámbito del método que devuelve del objeto.</span><span class="sxs-lookup"><span data-stu-id="edb32-197">In addition, you can return a `readonly struct` as a `ref return` when you are returning an object whose lifetime extends beyond the scope of the method returning the object.</span></span>

<span data-ttu-id="edb32-198">Por último, el compilador genera código más eficaz cuando se llama a los miembros de `readonly struct`: la referencia `this`, en lugar de una copia del receptor, siempre es un parámetro `in` pasado por referencia al método de miembro.</span><span class="sxs-lookup"><span data-stu-id="edb32-198">Finally, the compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="edb32-199">Esta optimización ahorra más procesos de copia cuando utiliza `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="edb32-199">This optimization saves more copying when you use a `readonly struct`.</span></span> <span data-ttu-id="edb32-200">Este valor `Point3D` es un excelente candidato para este cambio.</span><span class="sxs-lookup"><span data-stu-id="edb32-200">The `Point3D` is a great candidate for this change.</span></span> <span data-ttu-id="edb32-201">El código siguiente muestra una estructura actualizada de `ReadonlyPoint3D`:</span><span class="sxs-lookup"><span data-stu-id="edb32-201">The following code shows an updated `ReadonlyPoint3D` structure:</span></span>

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a><span data-ttu-id="edb32-202">Tipo de `ref struct`</span><span class="sxs-lookup"><span data-stu-id="edb32-202">`ref struct` type</span></span>

<span data-ttu-id="edb32-203">Otra característica de lenguaje relacionada es la capacidad de declarar un tipo de valor que debe estar asignado a la pila.</span><span class="sxs-lookup"><span data-stu-id="edb32-203">Another related language feature is the ability to declare a value type that must be stack allocated.</span></span> <span data-ttu-id="edb32-204">En otras palabras, estos tipos no se pueden crear nunca en el montón como miembro de otra clase.</span><span class="sxs-lookup"><span data-stu-id="edb32-204">In other words, these types can never be created on the heap as a member of another class.</span></span> <span data-ttu-id="edb32-205">La principal motivación para esta característica era <xref:System.Span%601> y las estructuras relacionadas.</span><span class="sxs-lookup"><span data-stu-id="edb32-205">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="edb32-206"><xref:System.Span%601> puede contener un puntero administrado como uno de sus miembros, siendo el otro la longitud del intervalo.</span><span class="sxs-lookup"><span data-stu-id="edb32-206"><xref:System.Span%601> may contain a managed pointer as one of its members, the other being the length of the span.</span></span> <span data-ttu-id="edb32-207">Se implementa de manera un poco diferente porque C# no admite punteros a la memoria administrada fuera de un contexto no seguro.</span><span class="sxs-lookup"><span data-stu-id="edb32-207">It's implemented a bit differently because C# doesn't support pointers to managed memory outside of an unsafe context.</span></span> <span data-ttu-id="edb32-208">Cualquier escritura que cambie el puntero y la longitud no es atómica.</span><span class="sxs-lookup"><span data-stu-id="edb32-208">Any write that changes the pointer and the length is not atomic.</span></span> <span data-ttu-id="edb32-209">Es decir, un valor de <xref:System.Span%601> estaría sujeto a errores de fuera de intervalo o infracciones de seguridad de otro tipo cuando no se limita a un único marco de pila.</span><span class="sxs-lookup"><span data-stu-id="edb32-209">That means a <xref:System.Span%601> would be subject to out of range errors or other type safety violations were it not constrained to a single stack frame.</span></span> <span data-ttu-id="edb32-210">Además, la colocación de un puntero administrado en el montón de GC normalmente se bloquea en tiempo JIT.</span><span class="sxs-lookup"><span data-stu-id="edb32-210">In addition, putting a managed pointer on the GC heap typically crashes at JIT time.</span></span>

<span data-ttu-id="edb32-211">Puede tener requisitos similares al trabajar con memoria creada mediante [`stackalloc`](language-reference/keywords/stackalloc.md) o al usar memoria de las API de interoperabilidad.</span><span class="sxs-lookup"><span data-stu-id="edb32-211">You may have similar requirements working with memory created using [`stackalloc`](language-reference/keywords/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="edb32-212">Puede definir sus propios tipos de `ref struct` para esas necesidades.</span><span class="sxs-lookup"><span data-stu-id="edb32-212">You can define your own `ref struct` types for those needs.</span></span> <span data-ttu-id="edb32-213">En este artículo, verá ejemplos del uso de `Span<T>` por hacerlo más sencillo.</span><span class="sxs-lookup"><span data-stu-id="edb32-213">In this article, you see examples using `Span<T>` for simplicity.</span></span>

<span data-ttu-id="edb32-214">La declaración `ref struct` declara que una estructura de este tipo debe estar en la pila.</span><span class="sxs-lookup"><span data-stu-id="edb32-214">The `ref struct` declaration declares a struct of this type must be on the stack.</span></span> <span data-ttu-id="edb32-215">Las reglas de lenguaje garantizan el uso seguro de estos tipos.</span><span class="sxs-lookup"><span data-stu-id="edb32-215">The language rules ensure the safe use of these types.</span></span> <span data-ttu-id="edb32-216">Entre otros tipos declarados como `ref struct` se encuentra <xref:System.ReadOnlySpan%601>.</span><span class="sxs-lookup"><span data-stu-id="edb32-216">Other types declared as `ref struct` include <xref:System.ReadOnlySpan%601>.</span></span> 

<span data-ttu-id="edb32-217">El objetivo de mantener un tipo `ref struct` como una variable asignada a la pila presenta varias reglas que el compilador exige para todos los tipos `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="edb32-217">The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.</span></span>

- <span data-ttu-id="edb32-218">No puede encerrar un valor de `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="edb32-218">You can't box a `ref struct`.</span></span> <span data-ttu-id="edb32-219">No puede asignar un tipo `ref struct` a una variable de tipo `object`, `dynamic` o cualquier tipo de interfaz.</span><span class="sxs-lookup"><span data-stu-id="edb32-219">You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.</span></span>
- <span data-ttu-id="edb32-220">No puede declarar un `ref struct` como miembro de una clase o una estructura normal.</span><span class="sxs-lookup"><span data-stu-id="edb32-220">You can't declare a `ref struct` as a member of a class or a normal struct.</span></span>
- <span data-ttu-id="edb32-221">No puede declarar variables locales que sean tipos `ref struct` en métodos asincrónicos.</span><span class="sxs-lookup"><span data-stu-id="edb32-221">You cannot declare local variables that are `ref struct` types in async methods.</span></span> <span data-ttu-id="edb32-222">Pueden declararlas en los métodos sincrónicos que devuelven `Task`, `Task<T>` o tipos similares a la tarea.</span><span class="sxs-lookup"><span data-stu-id="edb32-222">You can declare them in synchronous methods that return `Task`, `Task<T>` or Task-like types.</span></span>
- <span data-ttu-id="edb32-223">No puede declarar las variables locales de `ref struct` en iteradores.</span><span class="sxs-lookup"><span data-stu-id="edb32-223">You cannot declare `ref struct` local variables in iterators.</span></span>
- <span data-ttu-id="edb32-224">No puede capturar variables `ref struct` en expresiones lambda o funciones locales.</span><span class="sxs-lookup"><span data-stu-id="edb32-224">You cannot capture `ref struct` variables in lambda expressions or local functions.</span></span>

<span data-ttu-id="edb32-225">Estas restricciones aseguran que no se usará por error un valor `ref struct` de manera que pueda promoverlo al montón administrado.</span><span class="sxs-lookup"><span data-stu-id="edb32-225">These restrictions ensure you do not accidentally use a `ref struct` in a manner that could promote it to the managed heap.</span></span>

## <a name="readonly-ref-struct-type"></a><span data-ttu-id="edb32-226">Tipo de `readonly ref struct`</span><span class="sxs-lookup"><span data-stu-id="edb32-226">`readonly ref struct` type</span></span>

<span data-ttu-id="edb32-227">Si declara una estructura como `readonly ref` se combinan las ventajas y las restricciones de las declaraciones `ref struct` y `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="edb32-227">Declaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` declarations.</span></span> 

<span data-ttu-id="edb32-228">En el siguiente ejemplo se muestra la declaración de `readonly ref struct`.</span><span class="sxs-lookup"><span data-stu-id="edb32-228">The following example demonstrates the declaration of `readonly ref struct`.</span></span>

```csharp
readonly ref struct ReadOnlyRefPoint2D
{
    public int X { get; }
    public int Y { get; }
    
    public ReadOnlyRefPoint2D(int x, int y) => (X, Y) = (x, y);
}
```

## <a name="conclusions"></a><span data-ttu-id="edb32-229">Conclusiones</span><span class="sxs-lookup"><span data-stu-id="edb32-229">Conclusions</span></span>

<span data-ttu-id="edb32-230">Estas mejoras del lenguaje C# están diseñadas para algoritmos críticos de rendimiento donde las asignaciones de memoria pueden resultar fundamentales para lograr el rendimiento necesario.</span><span class="sxs-lookup"><span data-stu-id="edb32-230">These enhancements to the C# language are designed for performance critical algorithms where memory allocations can be critical to achieving the necessary performance.</span></span> <span data-ttu-id="edb32-231">Es posible que no use a menudo estas características en el código que escribe.</span><span class="sxs-lookup"><span data-stu-id="edb32-231">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="edb32-232">Sin embargo, estas mejoras se adoptaron en muchas ubicaciones en .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="edb32-232">However, these enhancements have been adopted in many locations in the .NET Framework.</span></span> <span data-ttu-id="edb32-233">Dado que cada vez son más las API que utilizan estas características, comprobará que mejora el rendimiento de sus propias aplicaciones.</span><span class="sxs-lookup"><span data-stu-id="edb32-233">As more and more APIs make use of these features, you'll see the performance of your own applications improve.</span></span>
