---
title: "Semántica de referencia con tipos de valor"
description: "Comprender las características del lenguaje que minimizan las estructuras de copias de forma segura"
author: billwagner
ms.author: wiwagn
ms.date: 11/10/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.custom: mvc
ms.openlocfilehash: 9eeaf201c1f5a58044db62e356199b609c4c035a
ms.sourcegitcommit: 7e99f66ef09d2903e22c789c67ff5a10aa953b2f
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 11/18/2017
---
# <a name="reference-semantics-with-value-types"></a><span data-ttu-id="b6c70-103">Semántica de referencia con tipos de valor</span><span class="sxs-lookup"><span data-stu-id="b6c70-103">Reference semantics with value types</span></span>

<span data-ttu-id="b6c70-104">Una ventaja de utilizar tipos de valor es que a menudo evitar las asignaciones del montón.</span><span class="sxs-lookup"><span data-stu-id="b6c70-104">An advantage to using value types is that they often avoid heap allocations.</span></span>
<span data-ttu-id="b6c70-105">La desventaja correspondiente es que se copian por valor.</span><span class="sxs-lookup"><span data-stu-id="b6c70-105">The corresponding disadvantage is that they are copied by value.</span></span> <span data-ttu-id="b6c70-106">Esta compensación hace más difícil optimizar los algoritmos que funcionan en grandes cantidades de datos.</span><span class="sxs-lookup"><span data-stu-id="b6c70-106">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="b6c70-107">Nuevas características del lenguaje en C# 7.2 proporcionan mecanismos que habilitan la semántica de paso por referencia con tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="b6c70-107">New language features in C# 7.2 provide mechanisms that enable pass-by-reference semantics with value types.</span></span> <span data-ttu-id="b6c70-108">Si utiliza estas características con sabiduría puede minimizar ambas asignaciones y las operaciones de copia.</span><span class="sxs-lookup"><span data-stu-id="b6c70-108">If you use these features wisely you can minimize both allocations and copy operations.</span></span> <span data-ttu-id="b6c70-109">Este artículo exploran las nuevas características.</span><span class="sxs-lookup"><span data-stu-id="b6c70-109">This article explores those new features.</span></span>

<span data-ttu-id="b6c70-110">Gran parte del código de ejemplo en este artículo muestra características agregadas en C# 7.2.</span><span class="sxs-lookup"><span data-stu-id="b6c70-110">Much of the sample code in this article demonstrates features added in C# 7.2.</span></span> <span data-ttu-id="b6c70-111">Para poder usar esas características, tendrá que configurar el proyecto para usar C# 7.2 o posterior en el proyecto.</span><span class="sxs-lookup"><span data-stu-id="b6c70-111">In order to use those features, you have to configure your project to use C# 7.2 or later in your project.</span></span> <span data-ttu-id="b6c70-112">Puede usar Visual Studio para seleccionarlo.</span><span class="sxs-lookup"><span data-stu-id="b6c70-112">You can use Visual Studio to select it.</span></span> <span data-ttu-id="b6c70-113">Para cada proyecto, seleccione **proyecto** en el menú, a continuación, **propiedades**.</span><span class="sxs-lookup"><span data-stu-id="b6c70-113">For each project, select **Project** from the menu, then **Properties**.</span></span> <span data-ttu-id="b6c70-114">Seleccione el **generar** ficha y haga clic en **avanzadas**.</span><span class="sxs-lookup"><span data-stu-id="b6c70-114">Select the **Build** tab and click **Advanced**.</span></span> <span data-ttu-id="b6c70-115">Desde allí, puede configurar la versión de idioma.</span><span class="sxs-lookup"><span data-stu-id="b6c70-115">From there, you can configure the language version.</span></span> <span data-ttu-id="b6c70-116">Elegir "7.2", o "más reciente".</span><span class="sxs-lookup"><span data-stu-id="b6c70-116">Choose either "7.2", or "latest".</span></span>  <span data-ttu-id="b6c70-117">También puede editar la *csproj* de archivos y agregue el siguiente nodo:</span><span class="sxs-lookup"><span data-stu-id="b6c70-117">Or you can edit the *csproj* file and add the following node:</span></span>

```XML
  <PropertyGroup>
    <LangVersion>7.2</LangVersion>
  </PropertyGroup>
```

<span data-ttu-id="b6c70-118">Puede usar "7,2" o "más reciente" para el valor.</span><span class="sxs-lookup"><span data-stu-id="b6c70-118">You can use either "7.2" or "latest" for the value.</span></span>

## <a name="specifying-in-parameters"></a><span data-ttu-id="b6c70-119">Especificar `in` parámetros</span><span class="sxs-lookup"><span data-stu-id="b6c70-119">Specifying `in` parameters</span></span>

<span data-ttu-id="b6c70-120">7.2 C# agrega los `in` palabra clave para complementar las existentes `ref` y `out` palabras clave al escribir un método que pasa argumentos por referencia.</span><span class="sxs-lookup"><span data-stu-id="b6c70-120">C# 7.2 adds the `in` keyword to complement the existing `ref` and `out` keywords when you write a method that passes arguments by reference.</span></span> <span data-ttu-id="b6c70-121">El `in` palabra clave especifica que está pasando el parámetro por referencia y el método llamado no modifica el valor pasado a él.</span><span class="sxs-lookup"><span data-stu-id="b6c70-121">The `in` keyword specifies that you are passing the parameter by reference and the called method does not modify the value passed to it.</span></span> 

<span data-ttu-id="b6c70-122">Esta adición proporciona un vocabulario completo para expresar la intención del diseño.</span><span class="sxs-lookup"><span data-stu-id="b6c70-122">This addition provides a full vocabulary to express your design intent.</span></span> <span data-ttu-id="b6c70-123">Tipos de valor se copian cuando se pasan a un método llamado cuando no se especifica ninguno de los siguientes modificadores.</span><span class="sxs-lookup"><span data-stu-id="b6c70-123">Value types are copied when passed to a called method when you do not specify any of the following modifiers.</span></span> <span data-ttu-id="b6c70-124">Cada uno de estos modificadores especifica que un tipo de valor se pasa por referencia, evitando la copia.</span><span class="sxs-lookup"><span data-stu-id="b6c70-124">Each of these modifiers specify that a value type is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="b6c70-125">Cada modificador expresa un propósito diferente:</span><span class="sxs-lookup"><span data-stu-id="b6c70-125">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="b6c70-126">`out`: Este método establece el valor de los argumentos utilizados como este parámetro.</span><span class="sxs-lookup"><span data-stu-id="b6c70-126">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="b6c70-127">`ref`: Este método puede establecer el valor de los argumentos utilizados como este parámetro.</span><span class="sxs-lookup"><span data-stu-id="b6c70-127">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="b6c70-128">`in`: Este método no modifica el valor de los argumentos utilizados como este parámetro.</span><span class="sxs-lookup"><span data-stu-id="b6c70-128">`in`: This method does not modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="b6c70-129">Cuando se agrega el `in` modificador para pasar un argumento por referencia, se declara la intención del diseño consiste en pasar argumentos por referencia para evitar la copia innecesaria.</span><span class="sxs-lookup"><span data-stu-id="b6c70-129">When you add the `in` modifier to pass an argument by reference, you declare your design intent is to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="b6c70-130">No se intenta modificar el objeto usado como ese argumento.</span><span class="sxs-lookup"><span data-stu-id="b6c70-130">You do not intend to modify the object used as that argument.</span></span> <span data-ttu-id="b6c70-131">El código siguiente muestra un ejemplo de un método que calcula la distancia entre dos puntos en un espacio 3D.</span><span class="sxs-lookup"><span data-stu-id="b6c70-131">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span> 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

<span data-ttu-id="b6c70-132">Los argumentos son dos estructuras que contienen tres valores Double.</span><span class="sxs-lookup"><span data-stu-id="b6c70-132">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="b6c70-133">Un valor doble que tiene 8 bytes, por lo que cada argumento es de 24 bytes.</span><span class="sxs-lookup"><span data-stu-id="b6c70-133">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="b6c70-134">Especificando el `in` modificador, se puede pasar una referencia 4 bytes o de 8 bits a esos argumentos, según la arquitectura de la máquina.</span><span class="sxs-lookup"><span data-stu-id="b6c70-134">By specifying the `in` modifier, you pass 4-byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="b6c70-135">La diferencia de tamaño es pequeña, pero puede agregar rápidamente cuando la aplicación llama a este método en un bucle ajustado con muchos valores diferentes.</span><span class="sxs-lookup"><span data-stu-id="b6c70-135">The difference in size is small, but it can quickly add up when your application calls this method in a tight loop using many different values.</span></span>
 
<span data-ttu-id="b6c70-136">El `in` modificador complementa `out` y `ref` de otras maneras.</span><span class="sxs-lookup"><span data-stu-id="b6c70-136">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="b6c70-137">No se puede crear las sobrecargas de un método que se diferencian solo en presencia de `in`, `out` o `ref`.</span><span class="sxs-lookup"><span data-stu-id="b6c70-137">You cannot create overloads of a method that differ only in the presence of `in`, `out` or `ref`.</span></span> <span data-ttu-id="b6c70-138">Estas nuevas reglas de extienden el mismo comportamiento que tenía que siempre se han definido para `out` y `ref` parámetros.</span><span class="sxs-lookup"><span data-stu-id="b6c70-138">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span>

<span data-ttu-id="b6c70-139">El `in` modificador se puede aplicar a cualquier miembro que toma parámetros: métodos, delegados, expresiones lambda, funciones locales, los indizadores, operadores.</span><span class="sxs-lookup"><span data-stu-id="b6c70-139">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="b6c70-140">A diferencia de `ref` y `out` argumentos, puede usar los valores literales o constantes para el argumento en un `in` parámetro.</span><span class="sxs-lookup"><span data-stu-id="b6c70-140">Unlike `ref` and `out` arguments, you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="b6c70-141">Además, a diferencia de un `ref` o `out` parámetro, no es necesario aplicar el `in` modificador en el sitio de llamada.</span><span class="sxs-lookup"><span data-stu-id="b6c70-141">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="b6c70-142">El código siguiente muestra dos ejemplos de llamar al método el `CalculateDistance` método.</span><span class="sxs-lookup"><span data-stu-id="b6c70-142">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="b6c70-143">El primero usa dos variables locales que se pasa por referencia.</span><span class="sxs-lookup"><span data-stu-id="b6c70-143">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="b6c70-144">La segunda incluye una variable temporal que se crea como parte de la llamada al método.</span><span class="sxs-lookup"><span data-stu-id="b6c70-144">The second includes a temporary variable created as part of the method call.</span></span> 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="b6c70-145">Hay varias maneras en que el compilador se asegura de que la naturaleza de solo lectura de un `in` se aplica el argumento.</span><span class="sxs-lookup"><span data-stu-id="b6c70-145">There are several ways in which the compiler ensures that the read-only nature of an `in` argument is enforced.</span></span>  <span data-ttu-id="b6c70-146">En primer lugar, el método llamado no se puede asignar directamente a un `in` parámetro.</span><span class="sxs-lookup"><span data-stu-id="b6c70-146">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="b6c70-147">No se puede asignar directamente a cualquier campo de un `in` parámetro.</span><span class="sxs-lookup"><span data-stu-id="b6c70-147">It can't directly assign to any field of an `in` parameter.</span></span> <span data-ttu-id="b6c70-148">Además, no puede pasar un `in` parámetro a cualquier método exigir la `ref` o `out` modificador.</span><span class="sxs-lookup"><span data-stu-id="b6c70-148">In addition, you cannot pass an `in` parameter to any method demanding the `ref` or `out` modifier.</span></span>
<span data-ttu-id="b6c70-149">El compilador exige que el `in` argumento es una variable de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="b6c70-149">The compiler enforces that the `in` argument is a readonly variable.</span></span> <span data-ttu-id="b6c70-150">Puede llamar a cualquier método de instancia que utiliza la semántica de paso por valor.</span><span class="sxs-lookup"><span data-stu-id="b6c70-150">You can call any instance method that uses pass-by-value semantics.</span></span> <span data-ttu-id="b6c70-151">En esos casos, una copia de la `in` se crea el parámetro.</span><span class="sxs-lookup"><span data-stu-id="b6c70-151">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="b6c70-152">Dado que el compilador puede crear una variable temporal para cualquier `in` parámetro, también puede especificar valores predeterminados para cualquier `in` parámetro.</span><span class="sxs-lookup"><span data-stu-id="b6c70-152">Because the compiler can create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="b6c70-153">El código de seguimiento utiliza para especificar el origen (punto 0,0) como el valor predeterminado para el segundo punto:</span><span class="sxs-lookup"><span data-stu-id="b6c70-153">The follow code uses that to specify the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="b6c70-154">El `in` designación de parámetro también se puede usar con tipos de referencia o integrado en valores numéricos.</span><span class="sxs-lookup"><span data-stu-id="b6c70-154">The `in` parameter designation can also be used with reference types or built in numeric values.</span></span> <span data-ttu-id="b6c70-155">Sin embargo, las ventajas de ambos casos son mínimas, si lo hay.</span><span class="sxs-lookup"><span data-stu-id="b6c70-155">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="ref-readonly-returns"></a><span data-ttu-id="b6c70-156">`ref readonly`Devuelve</span><span class="sxs-lookup"><span data-stu-id="b6c70-156">`ref readonly` returns</span></span>

<span data-ttu-id="b6c70-157">También puede devolver un tipo de valor por referencia, pero no permitir el llamador de modificar ese valor.</span><span class="sxs-lookup"><span data-stu-id="b6c70-157">You may also want to return a value type by reference, but disallow the caller from modifying that value.</span></span> <span data-ttu-id="b6c70-158">Use la `ref readonly` modificador para expresar la intención de diseño.</span><span class="sxs-lookup"><span data-stu-id="b6c70-158">Use the `ref readonly` modifier to express that design intent.</span></span> <span data-ttu-id="b6c70-159">Notifica a los lectores que se devuelve una referencia a los datos existentes, pero no permite la modificación.</span><span class="sxs-lookup"><span data-stu-id="b6c70-159">It notifies readers that you are returning a reference to existing data, but not allowing modification.</span></span> 

<span data-ttu-id="b6c70-160">El compilador exige que el autor de llamada no puede modificar la referencia.</span><span class="sxs-lookup"><span data-stu-id="b6c70-160">The compiler enforces that the caller cannot modify the reference.</span></span> <span data-ttu-id="b6c70-161">Intenta asignar directamente al valor genera un error de tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="b6c70-161">Attempts to assign to the value directly generate a compile-time error.</span></span> <span data-ttu-id="b6c70-162">Sin embargo, el compilador no puede saber si cualquier método de miembro modifica el estado de la estructura.</span><span class="sxs-lookup"><span data-stu-id="b6c70-162">However, the compiler cannot know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="b6c70-163">Para asegurarse de que el objeto no se modifica, el compilador crea una copia y llama a miembro referencias usando esa copia.</span><span class="sxs-lookup"><span data-stu-id="b6c70-163">To ensure that the object is not modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="b6c70-164">Las modificaciones son a dicha copia estable.</span><span class="sxs-lookup"><span data-stu-id="b6c70-164">Any modifications are to that defensive copy.</span></span> 

<span data-ttu-id="b6c70-165">Es probable que la biblioteca con `Point3D` a menudo utilizaría el origen en todo el código.</span><span class="sxs-lookup"><span data-stu-id="b6c70-165">It's likely that the library using `Point3D` would often use the origin throughout the code.</span></span> <span data-ttu-id="b6c70-166">Cada instancia crea un nuevo objeto en la pila.</span><span class="sxs-lookup"><span data-stu-id="b6c70-166">Every instance creates a new object on the stack.</span></span> <span data-ttu-id="b6c70-167">Puede ser conveniente crear una constante y se devuelve por referencia.</span><span class="sxs-lookup"><span data-stu-id="b6c70-167">It may be advantageous to create a constant and return it by reference.</span></span> <span data-ttu-id="b6c70-168">Sin embargo, si se devuelve una referencia al almacenamiento interno, puede querer exigir que el autor de llamada no puede modificar el almacenamiento que se hace referencia.</span><span class="sxs-lookup"><span data-stu-id="b6c70-168">But, if you return a reference to internal storage, you may want to enforce that the caller cannot modify the referenced storage.</span></span> <span data-ttu-id="b6c70-169">El código siguiente define una propiedad de solo lectura que devuelve una `readonly ref` a un `Point3D` que especifica el origen.</span><span class="sxs-lookup"><span data-stu-id="b6c70-169">The following code defines a read-only property that returns a `readonly ref` to a `Point3D` that specifies the origin.</span></span>

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

<span data-ttu-id="b6c70-170">Crear una copia de una operación readonly ref devuelto es fácil: solo se asigna a una variable no declarada con la `ref readonly` modificador.</span><span class="sxs-lookup"><span data-stu-id="b6c70-170">Creating a copy of a ref readonly return is easy: Just assign it to a variable not declared with the `ref readonly` modifier.</span></span> <span data-ttu-id="b6c70-171">El compilador genera código para copiar el objeto como parte de la asignación.</span><span class="sxs-lookup"><span data-stu-id="b6c70-171">The compiler generates code to copy the object as part of the assignment.</span></span> 

<span data-ttu-id="b6c70-172">Al asignar una variable a un `ref readonly return`, puede especificar un `ref readonly` variable o una copia por valor de la referencia de solo lectura:</span><span class="sxs-lookup"><span data-stu-id="b6c70-172">When you assign a variable to a `ref readonly return`, you can specify either a `ref readonly` variable, or a by-value copy of the readonly reference:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="b6c70-173">La primera asignación en el código anterior realiza una copia de la `Origin` constante y asigna ese copia.</span><span class="sxs-lookup"><span data-stu-id="b6c70-173">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="b6c70-174">La segunda asigna una referencia.</span><span class="sxs-lookup"><span data-stu-id="b6c70-174">The second assigns a reference.</span></span> <span data-ttu-id="b6c70-175">Tenga en cuenta que el `readonly` modificador debe formar parte de la declaración de la variable.</span><span class="sxs-lookup"><span data-stu-id="b6c70-175">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="b6c70-176">No se puede modificar la referencia al que hace referencia.</span><span class="sxs-lookup"><span data-stu-id="b6c70-176">The reference to which it refers cannot be modified.</span></span> <span data-ttu-id="b6c70-177">Intenta hacer esto producirá un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="b6c70-177">Attempts to do so result in a compile-time error.</span></span>

## <a name="readonly-struct-type"></a><span data-ttu-id="b6c70-178">Tipo de `readonly struct`</span><span class="sxs-lookup"><span data-stu-id="b6c70-178">`readonly struct` type</span></span>

<span data-ttu-id="b6c70-179">Aplicar `ref readonly` a tráfico elevado entre los usos de un struct puede ser suficiente.</span><span class="sxs-lookup"><span data-stu-id="b6c70-179">Applying `ref readonly` to high-traffic uses of a struct may be sufficient.</span></span>
<span data-ttu-id="b6c70-180">En otras ocasiones, puede que desee crear un struct inmutable.</span><span class="sxs-lookup"><span data-stu-id="b6c70-180">Other times, you may want to create an immutable struct.</span></span> <span data-ttu-id="b6c70-181">A continuación, siempre se puede pasar por referencia de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="b6c70-181">Then you can always pass by readonly reference.</span></span> <span data-ttu-id="b6c70-182">Que el procedimiento quita la defensiva copia que tienen lugar cuando se tiene acceso a métodos de una estructura que se utiliza como un `in` parámetro.</span><span class="sxs-lookup"><span data-stu-id="b6c70-182">That practice removes the defensive copies that take place when you access methods of a struct used as an `in` parameter.</span></span>

<span data-ttu-id="b6c70-183">Puede hacerlo mediante la creación de un `readonly struct` tipo.</span><span class="sxs-lookup"><span data-stu-id="b6c70-183">You can do that by creating a `readonly struct` type.</span></span> <span data-ttu-id="b6c70-184">Puede agregar el `readonly` modificador en una declaración de estructura.</span><span class="sxs-lookup"><span data-stu-id="b6c70-184">You can add the `readonly` modifier to a struct declaration.</span></span> <span data-ttu-id="b6c70-185">El compilador exige que todos los miembros de la estructura son `readonly`; el `struct` deben ser inmutables.</span><span class="sxs-lookup"><span data-stu-id="b6c70-185">The compiler enforces that all members of the struct are `readonly`; the `struct` must be immutable.</span></span>

<span data-ttu-id="b6c70-186">Hay otras optimizaciones para una `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="b6c70-186">There are other optimizations for a `readonly struct`.</span></span> <span data-ttu-id="b6c70-187">Puede usar el `in` modificador en todas las ubicaciones donde un `readonly struct` es un argumento.</span><span class="sxs-lookup"><span data-stu-id="b6c70-187">You can use the `in` modifier at every location where a `readonly struct` is an argument.</span></span> <span data-ttu-id="b6c70-188">Además, puede devolver un `readonly struct` como un `ref return` cuando se devuelve un objeto cuya duración se extiende más allá del ámbito del método de devolución del objeto.</span><span class="sxs-lookup"><span data-stu-id="b6c70-188">In addition, you can return a `readonly struct` as a `ref return` when you are returning an object whose lifetime extends beyond the scope of the method returning the object.</span></span>

<span data-ttu-id="b6c70-189">Por último, el compilador genera código más eficaz cuando se llama a los miembros de un `readonly struct`: el `this` referencia, en lugar de una copia del receptor, siempre es un `in` parámetro pasado por referencia al método de miembro.</span><span class="sxs-lookup"><span data-stu-id="b6c70-189">Finally, the compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="b6c70-190">Esta optimización guarda la copia más cuando se usa un `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="b6c70-190">This optimization saves more copying when you use a `readonly struct`.</span></span> <span data-ttu-id="b6c70-191">El `Point3D` es un excelente candidato para que este cambio.</span><span class="sxs-lookup"><span data-stu-id="b6c70-191">The `Point3D` is a great candidate for this change.</span></span> <span data-ttu-id="b6c70-192">El código siguiente muestra un controlador actualizado, `ReadonlyPoint3D` estructura:</span><span class="sxs-lookup"><span data-stu-id="b6c70-192">The following code shows an updated `ReadonlyPoint3D` structure:</span></span>

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a><span data-ttu-id="b6c70-193">Tipo de `ref struct`</span><span class="sxs-lookup"><span data-stu-id="b6c70-193">`ref struct` type</span></span>

<span data-ttu-id="b6c70-194">Otra característica del lenguaje relacionadas es la capacidad para declarar un tipo de valor que debe estar asignado a la pila.</span><span class="sxs-lookup"><span data-stu-id="b6c70-194">Another related language feature is the ability to declare a value type that must be stack allocated.</span></span> <span data-ttu-id="b6c70-195">En otras palabras, nunca se puede crear estos tipos en el montón como miembro de otra clase.</span><span class="sxs-lookup"><span data-stu-id="b6c70-195">In other words, these types can never be created on the heap as a member of another class.</span></span> <span data-ttu-id="b6c70-196">La principal motivación para esta característica estaba <xref:System.Span%601> y las estructuras relacionadas.</span><span class="sxs-lookup"><span data-stu-id="b6c70-196">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="b6c70-197"><xref:System.Span%601>puede contener un puntero administrado como uno de sus miembros, el otro en la longitud del intervalo.</span><span class="sxs-lookup"><span data-stu-id="b6c70-197"><xref:System.Span%601> may contain a managed pointer as one of its members, the other being the length of the span.</span></span> <span data-ttu-id="b6c70-198">En realidad se implementa un poco diferente porque C# no es compatible con punteros a la memoria administrada fuera de un contexto no seguro.</span><span class="sxs-lookup"><span data-stu-id="b6c70-198">It's actually implemented a bit differently because C# doesn't support pointers to managed memory outside of an unsafe context.</span></span> <span data-ttu-id="b6c70-199">Cualquier escritura que cambia el puntero y la longitud no es atómica.</span><span class="sxs-lookup"><span data-stu-id="b6c70-199">Any write that changes the pointer and the length is not atomic.</span></span> <span data-ttu-id="b6c70-200">Es decir, un <xref:System.Span%601> sería sujeto a errores de intervalo insuficiente u otras infracciones de seguridad de tipo estaban no restringido a un marco de pila único.</span><span class="sxs-lookup"><span data-stu-id="b6c70-200">That means a <xref:System.Span%601> would be subject to out of range errors or other type safety violations were it not constrained to a single stack frame.</span></span> <span data-ttu-id="b6c70-201">Además, colocar un puntero administrado en el montón del GC normalmente se bloquea en tiempo de JIT.</span><span class="sxs-lookup"><span data-stu-id="b6c70-201">In addition, putting a managed pointer on the GC heap typically crashes at JIT time.</span></span>

<span data-ttu-id="b6c70-202">Puede tener requisitos similares, trabajar con memoria creado con [ `stackalloc` ](language-reference/keywords/stackalloc.md) o al uso de memoria de API de interoperabilidad.</span><span class="sxs-lookup"><span data-stu-id="b6c70-202">You may have similar requirements working with memory created using [`stackalloc`](language-reference/keywords/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="b6c70-203">Puede definir sus propios `ref struct` tipos para esas necesidades.</span><span class="sxs-lookup"><span data-stu-id="b6c70-203">You can define your own `ref struct` types for those needs.</span></span> <span data-ttu-id="b6c70-204">En este artículo, consulte Ver ejemplos de uso `Span<T>` para simplificar el trabajo.</span><span class="sxs-lookup"><span data-stu-id="b6c70-204">In this article, you see examples using `Span<T>` for simplicity.</span></span>

<span data-ttu-id="b6c70-205">El `ref struct` declaración declara que un struct de este tipo debe estar en la pila.</span><span class="sxs-lookup"><span data-stu-id="b6c70-205">The `ref struct` declaration declares that a struct of this type must be on the stack.</span></span> <span data-ttu-id="b6c70-206">Las reglas de lenguaje garantizan el uso seguro de estos tipos.</span><span class="sxs-lookup"><span data-stu-id="b6c70-206">The language rules ensure the safe use of these types.</span></span> <span data-ttu-id="b6c70-207">Otros tipos declaran como `ref struct` incluir <xref:System.ReadOnlySpan%601>.</span><span class="sxs-lookup"><span data-stu-id="b6c70-207">Other types declared as `ref struct` include <xref:System.ReadOnlySpan%601>.</span></span> 

<span data-ttu-id="b6c70-208">El objetivo de mantener un `ref struct` escriba como una variable asignada a la pila presenta varias reglas que el compilador exige para todos los `ref struct` tipos.</span><span class="sxs-lookup"><span data-stu-id="b6c70-208">The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.</span></span>

- <span data-ttu-id="b6c70-209">No se cuadro un `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="b6c70-209">You can't box a `ref struct`.</span></span> <span data-ttu-id="b6c70-210">No se puede asignar un `ref struct` tipo a una variable de tipo `object`, `dynamic`, o cualquier tipo de interfaz.</span><span class="sxs-lookup"><span data-stu-id="b6c70-210">You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.</span></span>
- <span data-ttu-id="b6c70-211">No se puede declarar un `ref struct` como un miembro de una clase o un struct normal.</span><span class="sxs-lookup"><span data-stu-id="b6c70-211">You can't declare a `ref struct` as a member of a class or a normal struct.</span></span>
- <span data-ttu-id="b6c70-212">No se puede declarar variables locales que están `ref struct` tipos en métodos asincrónicos.</span><span class="sxs-lookup"><span data-stu-id="b6c70-212">You cannot declare local variables that are `ref struct` types in async methods.</span></span> <span data-ttu-id="b6c70-213">Se pueden declarar en los métodos sincrónicos que devuelven `Task`, `Task<T>` o tipos similares de la tarea.</span><span class="sxs-lookup"><span data-stu-id="b6c70-213">You can declare them in synchronous methods that return `Task`, `Task<T>` or Task-like types.</span></span>
- <span data-ttu-id="b6c70-214">No se puede declarar `ref struct` variables locales en iteradores.</span><span class="sxs-lookup"><span data-stu-id="b6c70-214">You cannot declare `ref struct` local variables in iterators.</span></span>
- <span data-ttu-id="b6c70-215">No se puede capturar `ref struct` variables en expresiones lambda o funciones locales.</span><span class="sxs-lookup"><span data-stu-id="b6c70-215">You cannot capture `ref struct` variables in lambda expressions or local functions.</span></span>

<span data-ttu-id="b6c70-216">Estas restricciones aseguran que se no usa accidentalmente una `ref struct` de manera que puede promoverlo al montón administrado.</span><span class="sxs-lookup"><span data-stu-id="b6c70-216">These restrictions ensure that you do not accidentally use a `ref struct` in a manner that could promote it to the managed heap.</span></span>

## <a name="conclusions"></a><span data-ttu-id="b6c70-217">Conclusiones</span><span class="sxs-lookup"><span data-stu-id="b6c70-217">Conclusions</span></span>

<span data-ttu-id="b6c70-218">Estas mejoras del lenguaje C# están diseñadas para algoritmos críticos de rendimiento donde las asignaciones de memoria pueden resultar fundamentales para lograr el rendimiento necesario.</span><span class="sxs-lookup"><span data-stu-id="b6c70-218">These enhancements to the C# language are designed for performance critical algorithms where memory allocations can be critical to achieving the necessary performance.</span></span> <span data-ttu-id="b6c70-219">Es posible que no use a menudo estas características en el código que escribe.</span><span class="sxs-lookup"><span data-stu-id="b6c70-219">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="b6c70-220">Sin embargo, estas mejoras fueron adoptadas en muchas ubicaciones en .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="b6c70-220">However, these enhancements have been adopted in many locations in the .NET Framework.</span></span> <span data-ttu-id="b6c70-221">Como cada vez más las API que simplifican el uso de estas características, podrá ver el rendimiento de sus propias aplicaciones mejorar.</span><span class="sxs-lookup"><span data-stu-id="b6c70-221">As more and more APIs make use of these features, you'll see the performance of your own applications improve.</span></span>
