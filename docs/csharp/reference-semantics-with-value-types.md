---
title: "Semántica de referencia con tipos de valor"
description: "Conozca las características del lenguaje que reducen al mínimo la copia de las estructuras de manera segura."
author: billwagner
ms.author: wiwagn
ms.date: 11/10/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.custom: mvc
ms.openlocfilehash: 0c6e44a3e1a1458f4211b66b6d1ef5b4b30cd7c1
ms.sourcegitcommit: 5177d6ae2e9baf026f07ee0631556700a5a193f7
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 11/28/2017
---
# <a name="reference-semantics-with-value-types"></a><span data-ttu-id="7c18a-103">Semántica de referencia con tipos de valor</span><span class="sxs-lookup"><span data-stu-id="7c18a-103">Reference semantics with value types</span></span>

<span data-ttu-id="7c18a-104">Una ventaja de utilizar tipos de valor es que a menudo evitan las asignaciones del montón.</span><span class="sxs-lookup"><span data-stu-id="7c18a-104">An advantage to using value types is that they often avoid heap allocations.</span></span>
<span data-ttu-id="7c18a-105">La desventaja correspondiente es que se copian por valor.</span><span class="sxs-lookup"><span data-stu-id="7c18a-105">The corresponding disadvantage is that they are copied by value.</span></span> <span data-ttu-id="7c18a-106">Este último aspecto dificulta la optimización de los algoritmos que funcionan en grandes cantidades de datos.</span><span class="sxs-lookup"><span data-stu-id="7c18a-106">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="7c18a-107">Las nuevas características del lenguaje en C# 7.2 proporcionan mecanismos que habilitan la semántica de paso por referencia con tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="7c18a-107">New language features in C# 7.2 provide mechanisms that enable pass-by-reference semantics with value types.</span></span> <span data-ttu-id="7c18a-108">Si utiliza estas características acertadamente puede minimizar tanto las asignaciones como las operaciones de copia.</span><span class="sxs-lookup"><span data-stu-id="7c18a-108">If you use these features wisely you can minimize both allocations and copy operations.</span></span> <span data-ttu-id="7c18a-109">En este artículo se exploran estas nuevas características.</span><span class="sxs-lookup"><span data-stu-id="7c18a-109">This article explores those new features.</span></span>

<span data-ttu-id="7c18a-110">Gran parte del código de ejemplo de este artículo muestra características agregadas en C# 7.2.</span><span class="sxs-lookup"><span data-stu-id="7c18a-110">Much of the sample code in this article demonstrates features added in C# 7.2.</span></span> <span data-ttu-id="7c18a-111">Para poder usar esas características, tendrá que configurar el proyecto para que utilice C# 7.2 o una versión posterior en el proyecto.</span><span class="sxs-lookup"><span data-stu-id="7c18a-111">In order to use those features, you have to configure your project to use C# 7.2 or later in your project.</span></span> <span data-ttu-id="7c18a-112">Puede usar Visual Studio para seleccionarlo.</span><span class="sxs-lookup"><span data-stu-id="7c18a-112">You can use Visual Studio to select it.</span></span> <span data-ttu-id="7c18a-113">Para cada proyecto, seleccione **Proyecto** en el menú y, a continuación, **Propiedades**.</span><span class="sxs-lookup"><span data-stu-id="7c18a-113">For each project, select **Project** from the menu, then **Properties**.</span></span> <span data-ttu-id="7c18a-114">Seleccione la pestaña **Compilar** y haga clic en **Opciones avanzadas**.</span><span class="sxs-lookup"><span data-stu-id="7c18a-114">Select the **Build** tab and click **Advanced**.</span></span> <span data-ttu-id="7c18a-115">Ahí podrá configurar la versión de lenguaje.</span><span class="sxs-lookup"><span data-stu-id="7c18a-115">From there, you can configure the language version.</span></span> <span data-ttu-id="7c18a-116">Elija "7.2", o "más reciente".</span><span class="sxs-lookup"><span data-stu-id="7c18a-116">Choose either "7.2", or "latest".</span></span>  <span data-ttu-id="7c18a-117">O puede editar el proyecto *csproj* y agregar el nodo siguiente:</span><span class="sxs-lookup"><span data-stu-id="7c18a-117">Or you can edit the *csproj* file and add the following node:</span></span>

```XML
  <PropertyGroup>
    <LangVersion>7.2</LangVersion>
  </PropertyGroup>
```

<span data-ttu-id="7c18a-118">Puede usar "7.2" o "más reciente" como valor.</span><span class="sxs-lookup"><span data-stu-id="7c18a-118">You can use either "7.2" or "latest" for the value.</span></span>

## <a name="specifying-in-parameters"></a><span data-ttu-id="7c18a-119">Especificación de parámetros `in`</span><span class="sxs-lookup"><span data-stu-id="7c18a-119">Specifying `in` parameters</span></span>

<span data-ttu-id="7c18a-120">C# 7.2 agrega la palabra clave `in` para complementar las palabras clave `ref` y `out` existentes al escribir un método que pasa argumentos por referencia.</span><span class="sxs-lookup"><span data-stu-id="7c18a-120">C# 7.2 adds the `in` keyword to complement the existing `ref` and `out` keywords when you write a method that passes arguments by reference.</span></span> <span data-ttu-id="7c18a-121">La palabra clave `in` especifica que está pasando el parámetro por referencia y el método llamado no modifica el valor que se le pasa.</span><span class="sxs-lookup"><span data-stu-id="7c18a-121">The `in` keyword specifies that you are passing the parameter by reference and the called method does not modify the value passed to it.</span></span> 

<span data-ttu-id="7c18a-122">Esta novedad proporciona un vocabulario completo para expresar la intención del diseño.</span><span class="sxs-lookup"><span data-stu-id="7c18a-122">This addition provides a full vocabulary to express your design intent.</span></span> <span data-ttu-id="7c18a-123">Los tipos de valor se copian al pasarlos a un método llamado cuando no se especifica ninguno de los siguientes modificadores.</span><span class="sxs-lookup"><span data-stu-id="7c18a-123">Value types are copied when passed to a called method when you do not specify any of the following modifiers.</span></span> <span data-ttu-id="7c18a-124">Cada uno de estos modificadores especifica que un tipo de valor se pasa por referencia, evitando la copia.</span><span class="sxs-lookup"><span data-stu-id="7c18a-124">Each of these modifiers specify that a value type is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="7c18a-125">Cada modificador expresa un propósito diferente:</span><span class="sxs-lookup"><span data-stu-id="7c18a-125">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="7c18a-126">`out`: este método establece el valor del argumento utilizado como este parámetro.</span><span class="sxs-lookup"><span data-stu-id="7c18a-126">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="7c18a-127">`ref`: este método puede establecer el valor del argumento utilizado como este parámetro.</span><span class="sxs-lookup"><span data-stu-id="7c18a-127">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="7c18a-128">`in`: este método no modifica el valor del argumento utilizado como este parámetro.</span><span class="sxs-lookup"><span data-stu-id="7c18a-128">`in`: This method does not modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="7c18a-129">Cuando se agrega el modificador `in` para pasar un argumento por referencia, se declara que la intención del diseño consiste en pasar argumentos por referencia para evitar la copia innecesaria.</span><span class="sxs-lookup"><span data-stu-id="7c18a-129">When you add the `in` modifier to pass an argument by reference, you declare your design intent is to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="7c18a-130">No pretende modificar el objeto usado como ese argumento.</span><span class="sxs-lookup"><span data-stu-id="7c18a-130">You do not intend to modify the object used as that argument.</span></span> <span data-ttu-id="7c18a-131">El código siguiente muestra un ejemplo de un método que calcula la distancia entre dos puntos en un espacio 3D.</span><span class="sxs-lookup"><span data-stu-id="7c18a-131">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span> 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

<span data-ttu-id="7c18a-132">Los argumentos son dos estructuras que contienen cada una de ellas tres valores dobles.</span><span class="sxs-lookup"><span data-stu-id="7c18a-132">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="7c18a-133">Un valor doble tiene 8 bytes, por lo que cada argumento es de 24 bytes.</span><span class="sxs-lookup"><span data-stu-id="7c18a-133">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="7c18a-134">Al especificar el modificador `in`, se pasa una referencia de 4 bytes o 8 bytes a esos argumentos, dependiendo de la arquitectura de la máquina.</span><span class="sxs-lookup"><span data-stu-id="7c18a-134">By specifying the `in` modifier, you pass 4-byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="7c18a-135">La diferencia de tamaño es pequeña; sin embargo, puede crecer rápidamente cuando la aplicación llama a este método en un bucle ajustado con muchos valores diferentes.</span><span class="sxs-lookup"><span data-stu-id="7c18a-135">The difference in size is small, but it can quickly add up when your application calls this method in a tight loop using many different values.</span></span>
 
<span data-ttu-id="7c18a-136">El modificador `in` complementa también a `out` y `ref` de otras maneras.</span><span class="sxs-lookup"><span data-stu-id="7c18a-136">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="7c18a-137">No puede crear sobrecargas de un método que difiere solo en cuanto a la presencia de `in`, `out` o `ref`.</span><span class="sxs-lookup"><span data-stu-id="7c18a-137">You cannot create overloads of a method that differ only in the presence of `in`, `out` or `ref`.</span></span> <span data-ttu-id="7c18a-138">Estas nuevas reglas extienden el mismo comportamiento que siempre se ha definido para los parámetros `out` y `ref`.</span><span class="sxs-lookup"><span data-stu-id="7c18a-138">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span>

<span data-ttu-id="7c18a-139">El modificador `in` se puede aplicar a cualquier miembro que toma parámetros: métodos, delegados, expresiones lambda, funciones locales, indexadores u operadores.</span><span class="sxs-lookup"><span data-stu-id="7c18a-139">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="7c18a-140">A diferencia de los argumentos `ref` y `out`, puede usar los valores literales o constantes para el argumento en un parámetro `in`.</span><span class="sxs-lookup"><span data-stu-id="7c18a-140">Unlike `ref` and `out` arguments, you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="7c18a-141">Además, a diferencia de un parámetro `ref` o `out`, no es necesario aplicar el modificador `in` en el sitio de llamada.</span><span class="sxs-lookup"><span data-stu-id="7c18a-141">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="7c18a-142">El código siguiente muestra dos ejemplos de llamada al método `CalculateDistance`.</span><span class="sxs-lookup"><span data-stu-id="7c18a-142">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="7c18a-143">El primero usa dos variables locales pasadas por referencia.</span><span class="sxs-lookup"><span data-stu-id="7c18a-143">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="7c18a-144">El segundo incluye una variable temporal creada como parte de la llamada al método.</span><span class="sxs-lookup"><span data-stu-id="7c18a-144">The second includes a temporary variable created as part of the method call.</span></span> 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="7c18a-145">El compilador tiene varias maneras de asegurarse de que se aplica la naturaleza de solo lectura de un argumento `in`.</span><span class="sxs-lookup"><span data-stu-id="7c18a-145">There are several ways in which the compiler ensures that the read-only nature of an `in` argument is enforced.</span></span>  <span data-ttu-id="7c18a-146">En primer lugar, el método llamado no se puede asignar directamente a un parámetro `in`.</span><span class="sxs-lookup"><span data-stu-id="7c18a-146">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="7c18a-147">No se puede asignar directamente a ningún campo de un parámetro `in`.</span><span class="sxs-lookup"><span data-stu-id="7c18a-147">It can't directly assign to any field of an `in` parameter.</span></span> <span data-ttu-id="7c18a-148">Además, no puede pasar un parámetro `in` a ningún método que exija el modificar `ref` o `out`.</span><span class="sxs-lookup"><span data-stu-id="7c18a-148">In addition, you cannot pass an `in` parameter to any method demanding the `ref` or `out` modifier.</span></span>
<span data-ttu-id="7c18a-149">El compilador exige que el argumento `in` sea una variable de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="7c18a-149">The compiler enforces that the `in` argument is a readonly variable.</span></span> <span data-ttu-id="7c18a-150">Puede llamar a cualquier método de instancia que utilice la semántica de paso por valor.</span><span class="sxs-lookup"><span data-stu-id="7c18a-150">You can call any instance method that uses pass-by-value semantics.</span></span> <span data-ttu-id="7c18a-151">En esos casos, se crea una copia del parámetro `in`.</span><span class="sxs-lookup"><span data-stu-id="7c18a-151">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="7c18a-152">Dado que el compilador puede crear una variable temporal para cualquier parámetro `in`, también puede especificar valores predeterminados para cualquier parámetro `in`.</span><span class="sxs-lookup"><span data-stu-id="7c18a-152">Because the compiler can create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="7c18a-153">El código siguiente utiliza esto para especificar el origen (punto 0,0) como valor predeterminado para el segundo punto:</span><span class="sxs-lookup"><span data-stu-id="7c18a-153">The follow code uses that to specify the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="7c18a-154">La designación del parámetro `in` también se puede usar con tipos de referencia o integrarse en valores numéricos.</span><span class="sxs-lookup"><span data-stu-id="7c18a-154">The `in` parameter designation can also be used with reference types or built in numeric values.</span></span> <span data-ttu-id="7c18a-155">Sin embargo, las ventajas de ambos casos son mínimas, si las hay.</span><span class="sxs-lookup"><span data-stu-id="7c18a-155">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="ref-readonly-returns"></a><span data-ttu-id="7c18a-156">Devoluciones de `ref readonly`</span><span class="sxs-lookup"><span data-stu-id="7c18a-156">`ref readonly` returns</span></span>

<span data-ttu-id="7c18a-157">También puede querer devolver un tipo de valor por referencia, pero no permitir que el llamador modifique ese valor.</span><span class="sxs-lookup"><span data-stu-id="7c18a-157">You may also want to return a value type by reference, but disallow the caller from modifying that value.</span></span> <span data-ttu-id="7c18a-158">Use el modificador `ref readonly` para expresar la intención del diseño.</span><span class="sxs-lookup"><span data-stu-id="7c18a-158">Use the `ref readonly` modifier to express that design intent.</span></span> <span data-ttu-id="7c18a-159">Esto notifica a los lectores que devuelve una referencia a los datos existentes, pero no permite la modificación.</span><span class="sxs-lookup"><span data-stu-id="7c18a-159">It notifies readers that you are returning a reference to existing data, but not allowing modification.</span></span> 

<span data-ttu-id="7c18a-160">El compilador exige que el llamador no pueda modificar la referencia.</span><span class="sxs-lookup"><span data-stu-id="7c18a-160">The compiler enforces that the caller cannot modify the reference.</span></span> <span data-ttu-id="7c18a-161">Los intentos de asignar al valor directamente generan un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="7c18a-161">Attempts to assign to the value directly generate a compile-time error.</span></span> <span data-ttu-id="7c18a-162">Sin embargo, el compilador no puede saber si algún método de miembro modifica el estado de la estructura.</span><span class="sxs-lookup"><span data-stu-id="7c18a-162">However, the compiler cannot know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="7c18a-163">Para asegurarse de que el objeto no se modifica, el compilador crea una copia y llama a las referencias de miembro usando esa copia.</span><span class="sxs-lookup"><span data-stu-id="7c18a-163">To ensure that the object is not modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="7c18a-164">Las modificaciones se realizan sobre esa copia defensiva.</span><span class="sxs-lookup"><span data-stu-id="7c18a-164">Any modifications are to that defensive copy.</span></span> 

<span data-ttu-id="7c18a-165">Es probable que la biblioteca con `Point3D` utilice a menudo el origen en todo el código.</span><span class="sxs-lookup"><span data-stu-id="7c18a-165">It's likely that the library using `Point3D` would often use the origin throughout the code.</span></span> <span data-ttu-id="7c18a-166">Cada instancia crea un nuevo objeto en la pila.</span><span class="sxs-lookup"><span data-stu-id="7c18a-166">Every instance creates a new object on the stack.</span></span> <span data-ttu-id="7c18a-167">Puede ser conveniente crear una constante y devolverla por referencia.</span><span class="sxs-lookup"><span data-stu-id="7c18a-167">It may be advantageous to create a constant and return it by reference.</span></span> <span data-ttu-id="7c18a-168">Sin embargo, si se devuelve una referencia al almacenamiento interno, es posible que desee exigir que el llamador no pueda modificar el almacenamiento al que se hace referencia.</span><span class="sxs-lookup"><span data-stu-id="7c18a-168">But, if you return a reference to internal storage, you may want to enforce that the caller cannot modify the referenced storage.</span></span> <span data-ttu-id="7c18a-169">El código siguiente define una propiedad de solo lectura que devuelve `readonly ref` a `Point3D` que especifica el origen.</span><span class="sxs-lookup"><span data-stu-id="7c18a-169">The following code defines a read-only property that returns a `readonly ref` to a `Point3D` that specifies the origin.</span></span>

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

<span data-ttu-id="7c18a-170">La creación de una copia de una devolución de solo lectura de referencia es fácil: basta con asignarla a una variable no declarada con el modificador `ref readonly`.</span><span class="sxs-lookup"><span data-stu-id="7c18a-170">Creating a copy of a ref readonly return is easy: Just assign it to a variable not declared with the `ref readonly` modifier.</span></span> <span data-ttu-id="7c18a-171">El compilador genera código para copiar el objeto como parte de la asignación.</span><span class="sxs-lookup"><span data-stu-id="7c18a-171">The compiler generates code to copy the object as part of the assignment.</span></span> 

<span data-ttu-id="7c18a-172">Al asignar una variable a `ref readonly return`, puede especificar una variable `ref readonly` o una copia por valor de la referencia de solo lectura:</span><span class="sxs-lookup"><span data-stu-id="7c18a-172">When you assign a variable to a `ref readonly return`, you can specify either a `ref readonly` variable, or a by-value copy of the readonly reference:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="7c18a-173">La primera asignación en el código anterior realiza una copia de la constante `Origin` y asigna esa copia.</span><span class="sxs-lookup"><span data-stu-id="7c18a-173">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="7c18a-174">La segunda asigna una referencia.</span><span class="sxs-lookup"><span data-stu-id="7c18a-174">The second assigns a reference.</span></span> <span data-ttu-id="7c18a-175">Tenga en cuenta que el modificador `readonly` debe formar parte de la declaración de la variable.</span><span class="sxs-lookup"><span data-stu-id="7c18a-175">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="7c18a-176">No se puede modificar la referencia a la que alude.</span><span class="sxs-lookup"><span data-stu-id="7c18a-176">The reference to which it refers cannot be modified.</span></span> <span data-ttu-id="7c18a-177">Los intentos de hacerlo generarán un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="7c18a-177">Attempts to do so result in a compile-time error.</span></span>

## <a name="readonly-struct-type"></a><span data-ttu-id="7c18a-178">Tipo de `readonly struct`</span><span class="sxs-lookup"><span data-stu-id="7c18a-178">`readonly struct` type</span></span>

<span data-ttu-id="7c18a-179">La aplicación de `ref readonly` a usos de tráfico elevado de una estructura puede ser suficiente.</span><span class="sxs-lookup"><span data-stu-id="7c18a-179">Applying `ref readonly` to high-traffic uses of a struct may be sufficient.</span></span>
<span data-ttu-id="7c18a-180">En otras ocasiones, quizá desee crear una estructura inmutable.</span><span class="sxs-lookup"><span data-stu-id="7c18a-180">Other times, you may want to create an immutable struct.</span></span> <span data-ttu-id="7c18a-181">Así puede pasar siempre por referencia de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="7c18a-181">Then you can always pass by readonly reference.</span></span> <span data-ttu-id="7c18a-182">Esa práctica quita las copias defensivas que tienen lugar cuando se tiene acceso a métodos de una estructura que se utiliza como un parámetro `in`.</span><span class="sxs-lookup"><span data-stu-id="7c18a-182">That practice removes the defensive copies that take place when you access methods of a struct used as an `in` parameter.</span></span>

<span data-ttu-id="7c18a-183">Puede hacerlo mediante la creación de un tipo `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="7c18a-183">You can do that by creating a `readonly struct` type.</span></span> <span data-ttu-id="7c18a-184">Puede agregar el modificador `readonly` en una declaración de estructura.</span><span class="sxs-lookup"><span data-stu-id="7c18a-184">You can add the `readonly` modifier to a struct declaration.</span></span> <span data-ttu-id="7c18a-185">El compilador exige que todos los miembros de instancia de la estructura sean `readonly`; `struct` debe ser inmutable.</span><span class="sxs-lookup"><span data-stu-id="7c18a-185">The compiler enforces that all instance members of the struct are `readonly`; the `struct` must be immutable.</span></span>

<span data-ttu-id="7c18a-186">Hay otras optimizaciones para `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="7c18a-186">There are other optimizations for a `readonly struct`.</span></span> <span data-ttu-id="7c18a-187">Puede usar el modificador `in` en todas las ubicaciones donde `readonly struct` es un argumento.</span><span class="sxs-lookup"><span data-stu-id="7c18a-187">You can use the `in` modifier at every location where a `readonly struct` is an argument.</span></span> <span data-ttu-id="7c18a-188">Además, puede devolver `readonly struct` como `ref return` cuando devuelva un objeto cuya duración se extiende más allá del ámbito del método que devuelve del objeto.</span><span class="sxs-lookup"><span data-stu-id="7c18a-188">In addition, you can return a `readonly struct` as a `ref return` when you are returning an object whose lifetime extends beyond the scope of the method returning the object.</span></span>

<span data-ttu-id="7c18a-189">Por último, el compilador genera código más eficaz cuando se llama a los miembros de `readonly struct`: la referencia `this`, en lugar de una copia del receptor, siempre es un parámetro `in` pasado por referencia al método de miembro.</span><span class="sxs-lookup"><span data-stu-id="7c18a-189">Finally, the compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="7c18a-190">Esta optimización ahorra más procesos de copia cuando utiliza `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="7c18a-190">This optimization saves more copying when you use a `readonly struct`.</span></span> <span data-ttu-id="7c18a-191">Este valor `Point3D` es un excelente candidato para este cambio.</span><span class="sxs-lookup"><span data-stu-id="7c18a-191">The `Point3D` is a great candidate for this change.</span></span> <span data-ttu-id="7c18a-192">El código siguiente muestra una estructura actualizada de `ReadonlyPoint3D`:</span><span class="sxs-lookup"><span data-stu-id="7c18a-192">The following code shows an updated `ReadonlyPoint3D` structure:</span></span>

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a><span data-ttu-id="7c18a-193">Tipo de `ref struct`</span><span class="sxs-lookup"><span data-stu-id="7c18a-193">`ref struct` type</span></span>

<span data-ttu-id="7c18a-194">Otra característica de lenguaje relacionada es la capacidad de declarar un tipo de valor que debe estar asignado a la pila.</span><span class="sxs-lookup"><span data-stu-id="7c18a-194">Another related language feature is the ability to declare a value type that must be stack allocated.</span></span> <span data-ttu-id="7c18a-195">En otras palabras, estos tipos no se pueden crear nunca en el montón como miembro de otra clase.</span><span class="sxs-lookup"><span data-stu-id="7c18a-195">In other words, these types can never be created on the heap as a member of another class.</span></span> <span data-ttu-id="7c18a-196">La principal motivación para esta característica era <xref:System.Span%601> y las estructuras relacionadas.</span><span class="sxs-lookup"><span data-stu-id="7c18a-196">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="7c18a-197"><xref:System.Span%601> puede contener un puntero administrado como uno de sus miembros, siendo el otro la longitud del intervalo.</span><span class="sxs-lookup"><span data-stu-id="7c18a-197"><xref:System.Span%601> may contain a managed pointer as one of its members, the other being the length of the span.</span></span> <span data-ttu-id="7c18a-198">En realidad se implementa de manera un poco diferente porque C# no admite punteros a la memoria administrada fuera de un contexto no seguro.</span><span class="sxs-lookup"><span data-stu-id="7c18a-198">It's actually implemented a bit differently because C# doesn't support pointers to managed memory outside of an unsafe context.</span></span> <span data-ttu-id="7c18a-199">Cualquier escritura que cambie el puntero y la longitud no es atómica.</span><span class="sxs-lookup"><span data-stu-id="7c18a-199">Any write that changes the pointer and the length is not atomic.</span></span> <span data-ttu-id="7c18a-200">Es decir, un valor de <xref:System.Span%601> estaría sujeto a errores de fuera de intervalo o infracciones de seguridad de otro tipo cuando no se limita a un único marco de pila.</span><span class="sxs-lookup"><span data-stu-id="7c18a-200">That means a <xref:System.Span%601> would be subject to out of range errors or other type safety violations were it not constrained to a single stack frame.</span></span> <span data-ttu-id="7c18a-201">Además, la colocación de un puntero administrado en el montón de GC normalmente se bloquea en tiempo JIT.</span><span class="sxs-lookup"><span data-stu-id="7c18a-201">In addition, putting a managed pointer on the GC heap typically crashes at JIT time.</span></span>

<span data-ttu-id="7c18a-202">Puede tener requisitos similares al trabajar con memoria creada mediante [`stackalloc`](language-reference/keywords/stackalloc.md) o al usar memoria de las API de interoperabilidad.</span><span class="sxs-lookup"><span data-stu-id="7c18a-202">You may have similar requirements working with memory created using [`stackalloc`](language-reference/keywords/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="7c18a-203">Puede definir sus propios tipos de `ref struct` para esas necesidades.</span><span class="sxs-lookup"><span data-stu-id="7c18a-203">You can define your own `ref struct` types for those needs.</span></span> <span data-ttu-id="7c18a-204">En este artículo, verá ejemplos del uso de `Span<T>` por hacerlo más sencillo.</span><span class="sxs-lookup"><span data-stu-id="7c18a-204">In this article, you see examples using `Span<T>` for simplicity.</span></span>

<span data-ttu-id="7c18a-205">La declaración `ref struct` declara que un estructura de este tipo debe estar en la pila.</span><span class="sxs-lookup"><span data-stu-id="7c18a-205">The `ref struct` declaration declares that a struct of this type must be on the stack.</span></span> <span data-ttu-id="7c18a-206">Las reglas de lenguaje garantizan el uso seguro de estos tipos.</span><span class="sxs-lookup"><span data-stu-id="7c18a-206">The language rules ensure the safe use of these types.</span></span> <span data-ttu-id="7c18a-207">Entre otros tipos declarados como `ref struct` se encuentra <xref:System.ReadOnlySpan%601>.</span><span class="sxs-lookup"><span data-stu-id="7c18a-207">Other types declared as `ref struct` include <xref:System.ReadOnlySpan%601>.</span></span> 

<span data-ttu-id="7c18a-208">El objetivo de mantener un tipo `ref struct` como una variable asignada a la pila presenta varias reglas que el compilador exige para todos los tipos `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="7c18a-208">The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.</span></span>

- <span data-ttu-id="7c18a-209">No puede encerrar un valor de `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="7c18a-209">You can't box a `ref struct`.</span></span> <span data-ttu-id="7c18a-210">No puede asignar un tipo `ref struct` a una variable de tipo `object`, `dynamic` o cualquier tipo de interfaz.</span><span class="sxs-lookup"><span data-stu-id="7c18a-210">You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.</span></span>
- <span data-ttu-id="7c18a-211">No puede declarar un `ref struct` como miembro de una clase o una estructura normal.</span><span class="sxs-lookup"><span data-stu-id="7c18a-211">You can't declare a `ref struct` as a member of a class or a normal struct.</span></span>
- <span data-ttu-id="7c18a-212">No puede declarar variables locales que sean tipos `ref struct` en métodos asincrónicos.</span><span class="sxs-lookup"><span data-stu-id="7c18a-212">You cannot declare local variables that are `ref struct` types in async methods.</span></span> <span data-ttu-id="7c18a-213">Pueden declararlas en los métodos sincrónicos que devuelven `Task`, `Task<T>` o tipos similares a la tarea.</span><span class="sxs-lookup"><span data-stu-id="7c18a-213">You can declare them in synchronous methods that return `Task`, `Task<T>` or Task-like types.</span></span>
- <span data-ttu-id="7c18a-214">No puede declarar las variables locales de `ref struct` en iteradores.</span><span class="sxs-lookup"><span data-stu-id="7c18a-214">You cannot declare `ref struct` local variables in iterators.</span></span>
- <span data-ttu-id="7c18a-215">No puede capturar variables `ref struct` en expresiones lambda o funciones locales.</span><span class="sxs-lookup"><span data-stu-id="7c18a-215">You cannot capture `ref struct` variables in lambda expressions or local functions.</span></span>

<span data-ttu-id="7c18a-216">Estas restricciones aseguran que no use por error un valor `ref struct` de manera que pueda promoverlo al montón administrado.</span><span class="sxs-lookup"><span data-stu-id="7c18a-216">These restrictions ensure that you do not accidentally use a `ref struct` in a manner that could promote it to the managed heap.</span></span>

## <a name="conclusions"></a><span data-ttu-id="7c18a-217">Conclusiones</span><span class="sxs-lookup"><span data-stu-id="7c18a-217">Conclusions</span></span>

<span data-ttu-id="7c18a-218">Estas mejoras del lenguaje C# están diseñadas para algoritmos críticos de rendimiento donde las asignaciones de memoria pueden resultar fundamentales para lograr el rendimiento necesario.</span><span class="sxs-lookup"><span data-stu-id="7c18a-218">These enhancements to the C# language are designed for performance critical algorithms where memory allocations can be critical to achieving the necessary performance.</span></span> <span data-ttu-id="7c18a-219">Es posible que no use a menudo estas características en el código que escribe.</span><span class="sxs-lookup"><span data-stu-id="7c18a-219">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="7c18a-220">Sin embargo, estas mejoras se adoptaron en muchas ubicaciones en .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="7c18a-220">However, these enhancements have been adopted in many locations in the .NET Framework.</span></span> <span data-ttu-id="7c18a-221">Dado que cada vez son más las API que utilizan estas características, comprobará que mejora el rendimiento de sus propias aplicaciones.</span><span class="sxs-lookup"><span data-stu-id="7c18a-221">As more and more APIs make use of these features, you'll see the performance of your own applications improve.</span></span>
