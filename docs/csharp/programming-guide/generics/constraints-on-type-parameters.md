---
title: "Restricciones de tipos de parámetros (Guía de programación de C#)"
ms.date: 07/20/2015
ms.prod: .net
ms.technology: devlang-csharp
ms.topic: article
helpviewer_keywords:
- generics [C#], type constraints
- type constraints [C#]
- type parameters [C#], constraints
- unbound type parameter [C#]
ms.assetid: 141b003e-1ddb-4e1c-bcb2-e1c3870e6a51
caps.latest.revision: "41"
author: BillWagner
ms.author: wiwagn
ms.openlocfilehash: 6f7c80acdb3815af4b5d545297894778029a9104
ms.sourcegitcommit: 8bde7a3432f30fc771079744955c75c58c4eb393
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 01/20/2018
---
# <a name="constraints-on-type-parameters-c-programming-guide"></a><span data-ttu-id="6524d-102">Restricciones de tipos de parámetros (Guía de programación de C#)</span><span class="sxs-lookup"><span data-stu-id="6524d-102">Constraints on Type Parameters (C# Programming Guide)</span></span>
<span data-ttu-id="6524d-103">Cuando define una clase genérica, puede aplicar restricciones a las clases de tipos que el código cliente puede usar para los argumentos de tipo cuando se crea una instancia de la clase.</span><span class="sxs-lookup"><span data-stu-id="6524d-103">When you define a generic class, you can apply restrictions to the kinds of types that client code can use for type arguments when it instantiates your class.</span></span> <span data-ttu-id="6524d-104">Si el código de cliente intenta crear una instancia de su clase mediante un tipo que no se permite por una restricción, el resultado es un error en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="6524d-104">If client code tries to instantiate your class by using a type that is not allowed by a constraint, the result is a compile-time error.</span></span> <span data-ttu-id="6524d-105">Estas limitaciones se denominan restricciones.</span><span class="sxs-lookup"><span data-stu-id="6524d-105">These restrictions are called constraints.</span></span> <span data-ttu-id="6524d-106">Las restricciones se especifican con la palabra clave contextual `where`.</span><span class="sxs-lookup"><span data-stu-id="6524d-106">Constraints are specified by using the `where` contextual keyword.</span></span> <span data-ttu-id="6524d-107">En la tabla siguiente se muestran los seis tipos de restricciones:</span><span class="sxs-lookup"><span data-stu-id="6524d-107">The following table lists the six types of constraints:</span></span>  
  
|<span data-ttu-id="6524d-108">Restricción</span><span class="sxs-lookup"><span data-stu-id="6524d-108">Constraint</span></span>|<span data-ttu-id="6524d-109">Description</span><span class="sxs-lookup"><span data-stu-id="6524d-109">Description</span></span>|  
|----------------|-----------------|  
|`where T: struct`|<span data-ttu-id="6524d-110">El argumento de tipo debe ser un tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="6524d-110">The type argument must be a value type.</span></span> <span data-ttu-id="6524d-111">Cualquier tipo de valor excepto <xref:System.Nullable> puede especificarse.</span><span class="sxs-lookup"><span data-stu-id="6524d-111">Any value type except <xref:System.Nullable> can be specified.</span></span> <span data-ttu-id="6524d-112">Para obtener más información, vea [Usar tipos que aceptan valores NULL](../../../csharp/programming-guide/nullable-types/using-nullable-types.md).</span><span class="sxs-lookup"><span data-stu-id="6524d-112">See [Using Nullable Types](../../../csharp/programming-guide/nullable-types/using-nullable-types.md) for more information.</span></span>|  
|`where T : class`|<span data-ttu-id="6524d-113">El argumento de tipo debe ser un tipo de referencia; esto se aplica también a cualquier tipo de clase, interfaz, delegado o matriz.</span><span class="sxs-lookup"><span data-stu-id="6524d-113">The type argument must be a reference type; this applies also to any class, interface, delegate, or array type.</span></span>|  
|`where T : new()`|<span data-ttu-id="6524d-114">El argumento de tipo debe tener un constructor sin parámetros público.</span><span class="sxs-lookup"><span data-stu-id="6524d-114">The type argument must have a public parameterless constructor.</span></span> <span data-ttu-id="6524d-115">Cuando se usa conjuntamente con otras restricciones, la restricción `new()` debe especificarse en último lugar.</span><span class="sxs-lookup"><span data-stu-id="6524d-115">When used together with other constraints, the `new()` constraint must be specified last.</span></span>|  
|<span data-ttu-id="6524d-116">`where T : `*\<nombre de clase base>*</span><span class="sxs-lookup"><span data-stu-id="6524d-116">`where T : `*\<base class name>*</span></span>|<span data-ttu-id="6524d-117">El argumento de tipo debe ser o derivarse de la clase base especificada.</span><span class="sxs-lookup"><span data-stu-id="6524d-117">The type argument must be or derive from the specified base class.</span></span>|  
|<span data-ttu-id="6524d-118">`where T : `*\<nombre de interfaz>*</span><span class="sxs-lookup"><span data-stu-id="6524d-118">`where T : `*\<interface name>*</span></span>|<span data-ttu-id="6524d-119">El argumento de tipo debe ser o implementar la interfaz especificada.</span><span class="sxs-lookup"><span data-stu-id="6524d-119">The type argument must be or implement the specified interface.</span></span> <span data-ttu-id="6524d-120">Pueden especificarse varias restricciones de interfaz.</span><span class="sxs-lookup"><span data-stu-id="6524d-120">Multiple interface constraints can be specified.</span></span> <span data-ttu-id="6524d-121">La interfaz de restricciones también puede ser genérica.</span><span class="sxs-lookup"><span data-stu-id="6524d-121">The constraining interface can also be generic.</span></span>|  
|`where T : U`|<span data-ttu-id="6524d-122">El argumento de tipo proporcionado por T debe ser o derivarse del argumento proporcionado para U.</span><span class="sxs-lookup"><span data-stu-id="6524d-122">The type argument supplied for T must be or derive from the argument supplied for U.</span></span>|  
  
## <a name="why-use-constraints"></a><span data-ttu-id="6524d-123">Por qué usar restricciones</span><span class="sxs-lookup"><span data-stu-id="6524d-123">Why Use Constraints</span></span>  
 <span data-ttu-id="6524d-124">Si quiere examinar un elemento de una lista genérica para determinar si es válido o para compararlo con otro elemento, el compilador debe tener alguna garantía de que el operador o el método que tiene que llamar se admitirá mediante cualquier argumento de tipo que pueda especificar el código cliente.</span><span class="sxs-lookup"><span data-stu-id="6524d-124">If you want to examine an item in a generic list to determine whether it is valid or to compare it to some other item, the compiler must have some guarantee that the operator or method it has to call will be supported by any type argument that might be specified by client code.</span></span> <span data-ttu-id="6524d-125">Esta garantía se obtiene aplicando una o más restricciones a su definición de clase genérica.</span><span class="sxs-lookup"><span data-stu-id="6524d-125">This guarantee is obtained by applying one or more constraints to your generic class definition.</span></span> <span data-ttu-id="6524d-126">Por ejemplo, la restricción de clase base indica al compilador que solo los objetos de este tipo o derivados de este tipo se usarán como argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="6524d-126">For example, the base class constraint tells the compiler that only objects of this type or derived from this type will be used as type arguments.</span></span> <span data-ttu-id="6524d-127">Una vez que el compilador tenga esta garantía, puede permitir que los métodos de ese tipo se llamen en la clase genérica.</span><span class="sxs-lookup"><span data-stu-id="6524d-127">Once the compiler has this guarantee, it can allow methods of that type to be called in the generic class.</span></span> <span data-ttu-id="6524d-128">Las restricciones se aplican con la palabra clave contextual `where`.</span><span class="sxs-lookup"><span data-stu-id="6524d-128">Constraints are applied by using the contextual keyword `where`.</span></span> <span data-ttu-id="6524d-129">En el ejemplo de código siguiente se muestran las funciones que podemos agregar a la clase `GenericList<T>` (en [Introducción a los genéricos](../../../csharp/programming-guide/generics/introduction-to-generics.md)) aplicando una restricción de clase base.</span><span class="sxs-lookup"><span data-stu-id="6524d-129">The following code example demonstrates the functionality we can add to the `GenericList<T>` class (in [Introduction to Generics](../../../csharp/programming-guide/generics/introduction-to-generics.md)) by applying a base class constraint.</span></span>  
  
 [!code-csharp[csProgGuideGenerics#11](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_1.cs)]  
  
 <span data-ttu-id="6524d-130">La restricción permite que la clase genérica use la propiedad `Employee.Name` porque se garantiza que todos los elementos de tipo T son un objeto `Employee` o un objeto que se hereda de `Employee`.</span><span class="sxs-lookup"><span data-stu-id="6524d-130">The constraint enables the generic class to use the `Employee.Name` property because all items of type T are guaranteed to be either an `Employee` object or an object that inherits from `Employee`.</span></span>  
  
 <span data-ttu-id="6524d-131">Pueden aplicarse varias restricciones en el mismo parámetro de tipo, y las propias restricciones pueden ser tipos genéricos, de la manera siguiente:</span><span class="sxs-lookup"><span data-stu-id="6524d-131">Multiple constraints can be applied to the same type parameter, and the constraints themselves can be generic types, as follows:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#12](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_2.cs)]  
  
 <span data-ttu-id="6524d-132">Al restringir el parámetro de tipo, aumenta el número de operaciones y llamadas al método permitidas a las que se admiten mediante el tipo de restricción y todos los tipos en su jerarquía de herencia.</span><span class="sxs-lookup"><span data-stu-id="6524d-132">By constraining the type parameter, you increase the number of allowable operations and method calls to those supported by the constraining type and all types in its inheritance hierarchy.</span></span> <span data-ttu-id="6524d-133">Por lo tanto, cuando diseña métodos o clases genéricas, si va a realizar cualquier operación en los miembros genéricos más allá de una asignación simple o una llamada a cualquier método que no admita `System.Object`, tendrá que aplicar restricciones al parámetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="6524d-133">Therefore, when you design generic classes or methods, if you will be performing any operation on the generic members beyond simple assignment or calling any methods not supported by `System.Object`, you will have to apply constraints to the type parameter.</span></span>  
  
 <span data-ttu-id="6524d-134">Al aplicar la restricción `where T : class`, evite los operadores `==` y `!=` en el parámetro de tipo porque estos operadores se probarán solo para la identidad de referencia, no para la igualdad de valor.</span><span class="sxs-lookup"><span data-stu-id="6524d-134">When applying the `where T : class` constraint, avoid the `==` and `!=` operators on the type parameter because these operators will test for reference identity only, not for value equality.</span></span> <span data-ttu-id="6524d-135">Esto sucede incluso si estos operadores están sobrecargados en un tipo que se usa como un argumento.</span><span class="sxs-lookup"><span data-stu-id="6524d-135">This is the case even if these operators are overloaded in a type that is used as an argument.</span></span> <span data-ttu-id="6524d-136">En el código siguiente se ilustra este punto; el resultado es False incluso cuando la clase <xref:System.String> sobrecarga al operador `==`.</span><span class="sxs-lookup"><span data-stu-id="6524d-136">The following code illustrates this point; the output is false even though the <xref:System.String> class overloads the `==` operator.</span></span>  
  
 [!code-csharp[csProgGuideGenerics#13](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_3.cs)]  
  
 <span data-ttu-id="6524d-137">La razón de este comportamiento es que, en tiempo de compilación, el compilador solo conoce que T es un tipo de referencia y, por lo tanto, debe usar los operadores predeterminados que son válidos para todos los tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="6524d-137">The reason for this behavior is that, at compile time, the compiler only knows that T is a reference type, and therefore must use the default operators that are valid for all reference types.</span></span> <span data-ttu-id="6524d-138">Si debe probar la igualdad de valor, la manera recomendada también es aplicar la restricción `where T : IComparable<T>` e implementar esa interfaz en cualquier clase que se usará para construir la clase genérica.</span><span class="sxs-lookup"><span data-stu-id="6524d-138">If you must test for value equality, the recommended way is to also apply the `where T : IComparable<T>` constraint and implement that interface in any class that will be used to construct the generic class.</span></span>  
  
## <a name="constraining-multiple-parameters"></a><span data-ttu-id="6524d-139">Restringir varios parámetros</span><span class="sxs-lookup"><span data-stu-id="6524d-139">Constraining Multiple Parameters</span></span>  
 <span data-ttu-id="6524d-140">Puede aplicar restricciones a varios parámetros, y varias restricciones a un solo parámetro, como se muestra en el siguiente ejemplo:</span><span class="sxs-lookup"><span data-stu-id="6524d-140">You can apply constraints to multiple parameters, and multiple constraints to a single parameter, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#64](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_4.cs)]  
  
## <a name="unbounded-type-parameters"></a><span data-ttu-id="6524d-141">Parámetros de tipo sin enlazar</span><span class="sxs-lookup"><span data-stu-id="6524d-141">Unbounded Type Parameters</span></span>  
 <span data-ttu-id="6524d-142">Los parámetros de tipo que no tienen restricciones, como T en la clase pública `SampleClass<T>{}`, se denominan parámetros de tipo sin enlazar.</span><span class="sxs-lookup"><span data-stu-id="6524d-142">Type parameters that have no constraints, such as T in public class `SampleClass<T>{}`, are called unbounded type parameters.</span></span> <span data-ttu-id="6524d-143">Los parámetros de tipo sin enlazar tienen las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="6524d-143">Unbounded type parameters have the following rules:</span></span>  
  
-   <span data-ttu-id="6524d-144">Los operadores `!=` y `==` no pueden usarse porque no existe ninguna garantía de que el argumento de tipo concreto admitirá estos operadores.</span><span class="sxs-lookup"><span data-stu-id="6524d-144">The `!=` and `==` operators cannot be used because there is no guarantee that the concrete type argument will support these operators.</span></span>  
  
-   <span data-ttu-id="6524d-145">Pueden convertirse a y desde `System.Object` o convertirse explícitamente en cualquier tipo de interfaz.</span><span class="sxs-lookup"><span data-stu-id="6524d-145">They can be converted to and from `System.Object` or explicitly converted to any interface type.</span></span>  
  
-   <span data-ttu-id="6524d-146">Puede comparar con [NULL](../../../csharp/language-reference/keywords/null.md).</span><span class="sxs-lookup"><span data-stu-id="6524d-146">You can compare to [null](../../../csharp/language-reference/keywords/null.md).</span></span> <span data-ttu-id="6524d-147">Si un parámetro sin enlazar se compara con `null`, la comparación siempre devolverá False si el argumento de tipo es un tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="6524d-147">If an unbounded parameter is compared to `null`, the comparison will always return false if the type argument is a value type.</span></span>  
  
## <a name="type-parameters-as-constraints"></a><span data-ttu-id="6524d-148">Parámetros de tipo como restricciones</span><span class="sxs-lookup"><span data-stu-id="6524d-148">Type Parameters as Constraints</span></span>  
 <span data-ttu-id="6524d-149">El uso de un parámetro de tipo genérico como una restricción es útil cuando una función de miembro con su propio parámetro de tipo tiene que restringir ese parámetro al parámetro de tipo del tipo contenedor, como se muestra en el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="6524d-149">The use of a generic type parameter as a constraint is useful when a member function with its own type parameter has to constrain that parameter to the type parameter of the containing type, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#14](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_5.cs)]  
  
 <span data-ttu-id="6524d-150">En el ejemplo anterior, `T` es una restricción de tipo en el contexto del método `Add`, y un parámetro de tipo sin enlazar en el contexto de la clase `List`.</span><span class="sxs-lookup"><span data-stu-id="6524d-150">In the previous example, `T` is a type constraint in the context of the `Add` method, and an unbounded type parameter in the context of the `List` class.</span></span>  
  
 <span data-ttu-id="6524d-151">Los parámetros de tipo también pueden usarse como restricciones en definiciones de clase genéricas.</span><span class="sxs-lookup"><span data-stu-id="6524d-151">Type parameters can also be used as constraints in generic class definitions.</span></span> <span data-ttu-id="6524d-152">Tenga en cuenta que el parámetro de tipo debe declararse dentro de los corchetes angulares junto con cualquier otro parámetro de tipo:</span><span class="sxs-lookup"><span data-stu-id="6524d-152">Note that the type parameter must be declared within the angle brackets together with any other type parameters:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#15](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_6.cs)]  
  
 <span data-ttu-id="6524d-153">La utilidad de los parámetros de tipo como restricciones con clases genéricas es muy limitada porque el compilador no puede asumir nada sobre el parámetro de tipo excepto que deriva de `System.Object`.</span><span class="sxs-lookup"><span data-stu-id="6524d-153">The usefulness of type parameters as constraints with generic classes is very limited because the compiler can assume nothing about the type parameter except that it derives from `System.Object`.</span></span> <span data-ttu-id="6524d-154">Use parámetros de tipo como restricciones en clases genéricas en escenarios en los que quiere aplicar una relación de herencia entre dos parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="6524d-154">Use type parameters as constraints on generic classes in scenarios in which you want to enforce an inheritance relationship between two type parameters.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="6524d-155">Vea también</span><span class="sxs-lookup"><span data-stu-id="6524d-155">See Also</span></span>  
 <xref:System.Collections.Generic>  
 [<span data-ttu-id="6524d-156">Guía de programación de C#</span><span class="sxs-lookup"><span data-stu-id="6524d-156">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)  
 [<span data-ttu-id="6524d-157">Introducción a los genéricos</span><span class="sxs-lookup"><span data-stu-id="6524d-157">Introduction to Generics</span></span>](../../../csharp/programming-guide/generics/introduction-to-generics.md)  
 [<span data-ttu-id="6524d-158">Clases genéricas</span><span class="sxs-lookup"><span data-stu-id="6524d-158">Generic Classes</span></span>](../../../csharp/programming-guide/generics/generic-classes.md)  
 [<span data-ttu-id="6524d-159">new (restricción)</span><span class="sxs-lookup"><span data-stu-id="6524d-159">new Constraint</span></span>](../../../csharp/language-reference/keywords/new-constraint.md)
