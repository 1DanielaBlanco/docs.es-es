---
title: "Polimorfismo (Guía de programación de C#)"
ms.date: 2015-07-20
ms.prod: .net
ms.technology:
- devlang-csharp
ms.topic: article
dev_langs:
- CSharp
helpviewer_keywords:
- C# language, polymorphism
- polymorphism [C#]
ms.assetid: 086af969-29a5-4ce8-a993-0b7d53839dab
caps.latest.revision: 31
author: BillWagner
ms.author: wiwagn
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
ms.translationtype: HT
ms.sourcegitcommit: 306c608dc7f97594ef6f72ae0f5aaba596c936e1
ms.openlocfilehash: c278a6a931154af97cab5b1ff33124dd31a3fa2e
ms.contentlocale: es-es
ms.lasthandoff: 07/28/2017

---
# <a name="polymorphism-c-programming-guide"></a><span data-ttu-id="64ece-102">Polimorfismo (Guía de programación de C#)</span><span class="sxs-lookup"><span data-stu-id="64ece-102">Polymorphism (C# Programming Guide)</span></span>
<span data-ttu-id="64ece-103">El polimorfismo suele considerarse el tercer pilar de la programación orientada a objetos, después de la encapsulación y la herencia.</span><span class="sxs-lookup"><span data-stu-id="64ece-103">Polymorphism is often referred to as the third pillar of object-oriented programming, after encapsulation and inheritance.</span></span> <span data-ttu-id="64ece-104">Polimorfismo es una palabra griega que significa "con muchas formas" y tiene dos aspectos diferentes:</span><span class="sxs-lookup"><span data-stu-id="64ece-104">Polymorphism is a Greek word that means "many-shaped" and it has two distinct aspects:</span></span>  
  
-   <span data-ttu-id="64ece-105">En tiempo de ejecución, los objetos de una clase derivada pueden ser tratados como objetos de una clase base en lugares como parámetros de métodos y colecciones o matrices.</span><span class="sxs-lookup"><span data-stu-id="64ece-105">At run time, objects of a derived class may be treated as objects of a base class in places such as method parameters and collections or arrays.</span></span> <span data-ttu-id="64ece-106">Cuando ocurre, el tipo declarado del objeto ya no es idéntico a su tipo en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="64ece-106">When this occurs, the object's declared type is no longer identical to its run-time type.</span></span>  
  
-   <span data-ttu-id="64ece-107">Las clases base pueden definir e implementar *métodos* [virtuales](../../../csharp/language-reference/keywords/virtual.md), y las clases derivadas pueden [invalidarlos](../../../csharp/language-reference/keywords/override.md), lo que significa que pueden proporcionar su propia definición e implementación.</span><span class="sxs-lookup"><span data-stu-id="64ece-107">Base classes may define and implement [virtual](../../../csharp/language-reference/keywords/virtual.md) *methods*, and derived classes can [override](../../../csharp/language-reference/keywords/override.md) them, which means they provide their own definition and implementation.</span></span> <span data-ttu-id="64ece-108">En tiempo de ejecución, cuando el código de cliente llama al método, CLR busca el tipo en tiempo de ejecución del objeto e invoca esa invalidación del método virtual.</span><span class="sxs-lookup"><span data-stu-id="64ece-108">At run-time, when client code calls the method, the CLR looks up the run-time type of the object, and invokes that override of the virtual method.</span></span> <span data-ttu-id="64ece-109">Por lo tanto, en el código fuente puede llamar a un método en una clase base y hacer que se ejecute una versión del método de la clase derivada.</span><span class="sxs-lookup"><span data-stu-id="64ece-109">Thus in your source code you can call a method on a base class, and cause a derived class's version of the method to be executed.</span></span>  
  
 <span data-ttu-id="64ece-110">Los métodos virtuales permiten trabajar con grupos de objetos relacionados de manera uniforme.</span><span class="sxs-lookup"><span data-stu-id="64ece-110">Virtual methods enable you to work with groups of related objects in a uniform way.</span></span> <span data-ttu-id="64ece-111">Por ejemplo, supongamos que tiene una aplicación de dibujo que permite a un usuario crear varios tipos de formas en una superficie de dibujo.</span><span class="sxs-lookup"><span data-stu-id="64ece-111">For example, suppose you have a drawing application that enables a user to create various kinds of shapes on a drawing surface.</span></span> <span data-ttu-id="64ece-112">En tiempo de compilación, no sabe qué tipos específicos de formas creará el usuario.</span><span class="sxs-lookup"><span data-stu-id="64ece-112">You do not know at compile time which specific types of shapes the user will create.</span></span> <span data-ttu-id="64ece-113">Sin embargo, la aplicación tiene que realizar el seguimiento de los distintos tipos de formas que se crean, y tiene que actualizarlos en respuesta a las acciones del mouse del usuario.</span><span class="sxs-lookup"><span data-stu-id="64ece-113">However, the application has to keep track of all the various types of shapes that are created, and it has to update them in response to user mouse actions.</span></span> <span data-ttu-id="64ece-114">Para solucionar este problema en dos pasos básicos, puede usar el polimorfismo:</span><span class="sxs-lookup"><span data-stu-id="64ece-114">You can use polymorphism to solve this problem in two basic steps:</span></span>  
  
1.  <span data-ttu-id="64ece-115">Crear una jerarquía de clases en la que cada clase de forma específica deriva de una clase base común.</span><span class="sxs-lookup"><span data-stu-id="64ece-115">Create a class hierarchy in which each specific shape class derives from a common base class.</span></span>  
  
2.  <span data-ttu-id="64ece-116">Usar un método virtual para invocar el método apropiado en una clase derivada mediante una sola llamada al método de la clase base.</span><span class="sxs-lookup"><span data-stu-id="64ece-116">Use a virtual method to invoke the appropriate method on any derived class through a single call to the base class method.</span></span>  
  
 <span data-ttu-id="64ece-117">Primero, cree una clase base llamada `Shape` y clases derivadas como `Rectangle`, `Circle` y `Triangle`.</span><span class="sxs-lookup"><span data-stu-id="64ece-117">First, create a base class called `Shape`, and derived classes such as `Rectangle`, `Circle`, and `Triangle`.</span></span> <span data-ttu-id="64ece-118">Dé a la clase `Shape` un método virtual llamado `Draw` e invalídelo en cada clase derivada para dibujar la forma determinada que la clase representa.</span><span class="sxs-lookup"><span data-stu-id="64ece-118">Give the `Shape` class a virtual method called `Draw`, and override it in each derived class to draw the particular shape that the class represents.</span></span> <span data-ttu-id="64ece-119">Cree un objeto `List<Shape>` y agregue Circle, Triangle y Rectangle a él.</span><span class="sxs-lookup"><span data-stu-id="64ece-119">Create a `List<Shape>` object and add a Circle, Triangle and Rectangle to it.</span></span> <span data-ttu-id="64ece-120">Para actualizar la superficie de dibujo, use un bucle [foreach](../../../csharp/language-reference/keywords/foreach-in.md) para iterar por la lista y llamar al método `Draw` en cada objeto `Shape` de la lista.</span><span class="sxs-lookup"><span data-stu-id="64ece-120">To update the drawing surface, use a [foreach](../../../csharp/language-reference/keywords/foreach-in.md) loop to iterate through the list and call the `Draw` method on each `Shape` object in the list.</span></span> <span data-ttu-id="64ece-121">Aunque cada objeto de la lista tenga un tipo declarado de `Shape`, se invocará el tipo en tiempo de ejecución (la versión invalidada del método en cada clase derivada).</span><span class="sxs-lookup"><span data-stu-id="64ece-121">Even though each object in the list has a declared type of `Shape`, it is the run-time type (the overridden version of the method in each derived class) that will be invoked.</span></span>  
  
 <span data-ttu-id="64ece-122">[!code-cs[csProgGuideInheritance#50](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_1.cs)]</span><span class="sxs-lookup"><span data-stu-id="64ece-122">[!code-cs[csProgGuideInheritance#50](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_1.cs)]</span></span>  
  
 <span data-ttu-id="64ece-123">En C#, cada tipo es polimórfico porque todos los tipos, incluidos los definidos por el usuario, heredan de <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="64ece-123">In C#, every type is polymorphic because all types, including user-defined types, inherit from <xref:System.Object>.</span></span>  
  
## <a name="polymorphism-overview"></a><span data-ttu-id="64ece-124">Introducción al polimorfismo</span><span class="sxs-lookup"><span data-stu-id="64ece-124">Polymorphism Overview</span></span>  
  
### <a name="virtual-members"></a><span data-ttu-id="64ece-125">Miembros virtuales</span><span class="sxs-lookup"><span data-stu-id="64ece-125">Virtual Members</span></span>  
 <span data-ttu-id="64ece-126">Cuando una clase derivada hereda de una clase base, obtiene todos los métodos, campos, propiedades y eventos de la clase base.</span><span class="sxs-lookup"><span data-stu-id="64ece-126">When a derived class inherits from a base class, it gains all the methods, fields, properties and events of the base class.</span></span> <span data-ttu-id="64ece-127">El diseñador de la clase derivada tiene las siguientes opciones:</span><span class="sxs-lookup"><span data-stu-id="64ece-127">The designer of the derived class can choose whether to</span></span>  
  
-   <span data-ttu-id="64ece-128">Invalidar los miembros virtuales de la clase base.</span><span class="sxs-lookup"><span data-stu-id="64ece-128">override virtual members in the base class,</span></span>  
  
-   <span data-ttu-id="64ece-129">Heredar el método de la clase base más próximo sin invalidarlo.</span><span class="sxs-lookup"><span data-stu-id="64ece-129">inherit the closest base class method without overriding it</span></span>  
  
-   <span data-ttu-id="64ece-130">Definir una nueva implementación no virtual de esos miembros que oculte las implementaciones de la clase base.</span><span class="sxs-lookup"><span data-stu-id="64ece-130">define new non-virtual implementation of those members that hide the base class implementations</span></span>  
  
 <span data-ttu-id="64ece-131">Una clase derivada puede invalidar un miembro de la clase base si este se declara como [virtual](../../../csharp/language-reference/keywords/virtual.md) o [abstracto](../../../csharp/language-reference/keywords/abstract.md).</span><span class="sxs-lookup"><span data-stu-id="64ece-131">A derived class can override a base class member only if the base class member is declared as [virtual](../../../csharp/language-reference/keywords/virtual.md) or [abstract](../../../csharp/language-reference/keywords/abstract.md).</span></span> <span data-ttu-id="64ece-132">El miembro derivado debe usar la palabra clave [override](../../../csharp/language-reference/keywords/override.md) para indicar explícitamente que el propósito del método es participar en una invocación virtual.</span><span class="sxs-lookup"><span data-stu-id="64ece-132">The derived member must use the [override](../../../csharp/language-reference/keywords/override.md) keyword to explicitly indicate that the method is intended to participate in virtual invocation.</span></span> <span data-ttu-id="64ece-133">El siguiente fragmento de código muestra un ejemplo:</span><span class="sxs-lookup"><span data-stu-id="64ece-133">The following code provides an example:</span></span>  
  
 <span data-ttu-id="64ece-134">[!code-cs[csProgGuideInheritance#20](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_2.cs)]</span><span class="sxs-lookup"><span data-stu-id="64ece-134">[!code-cs[csProgGuideInheritance#20](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_2.cs)]</span></span>  
  
 <span data-ttu-id="64ece-135">Los campos no pueden ser virtuales; solo los métodos, propiedades, eventos e indizadores pueden ser virtuales.</span><span class="sxs-lookup"><span data-stu-id="64ece-135">Fields cannot be virtual; only methods, properties, events and indexers can be virtual.</span></span> <span data-ttu-id="64ece-136">Cuando una clase derivada invalida un miembro virtual, se llama a ese miembro aunque se acceda a una instancia de esa clase como una instancia de la clase base.</span><span class="sxs-lookup"><span data-stu-id="64ece-136">When a derived class overrides a virtual member, that member is called even when an instance of that class is being accessed as an instance of the base class.</span></span> <span data-ttu-id="64ece-137">El siguiente fragmento de código muestra un ejemplo:</span><span class="sxs-lookup"><span data-stu-id="64ece-137">The following code provides an example:</span></span>  
  
 <span data-ttu-id="64ece-138">[!code-cs[csProgGuideInheritance#21](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_3.cs)]</span><span class="sxs-lookup"><span data-stu-id="64ece-138">[!code-cs[csProgGuideInheritance#21](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_3.cs)]</span></span>  
  
 <span data-ttu-id="64ece-139">Los métodos y propiedades virtuales permiten a las clases derivadas extender una clase base sin necesidad de usar la implementación de clase base de un método.</span><span class="sxs-lookup"><span data-stu-id="64ece-139">Virtual methods and properties enable derived classes to extend a base class without needing to use the base class implementation of a method.</span></span> <span data-ttu-id="64ece-140">Para obtener más información, consulte [Control de versiones con las palabras clave Override y New](../../../csharp/programming-guide/classes-and-structs/versioning-with-the-override-and-new-keywords.md).</span><span class="sxs-lookup"><span data-stu-id="64ece-140">For more information, see [Versioning with the Override and New Keywords](../../../csharp/programming-guide/classes-and-structs/versioning-with-the-override-and-new-keywords.md).</span></span> <span data-ttu-id="64ece-141">Una interfaz proporciona otra manera de definir un método o conjunto de métodos cuya implementación se deja a las clases derivadas.</span><span class="sxs-lookup"><span data-stu-id="64ece-141">An interface provides another way to define a method or set of methods whose implementation is left to derived classes.</span></span> <span data-ttu-id="64ece-142">Para obtener más información, vea [Interfaces](../../../csharp/programming-guide/interfaces/index.md).</span><span class="sxs-lookup"><span data-stu-id="64ece-142">For more information, see [Interfaces](../../../csharp/programming-guide/interfaces/index.md).</span></span>  
  
### <a name="hiding-base-class-members-with-new-members"></a><span data-ttu-id="64ece-143">Ocultar miembros de clase base con nuevos miembros</span><span class="sxs-lookup"><span data-stu-id="64ece-143">Hiding Base Class Members with New Members</span></span>  
 <span data-ttu-id="64ece-144">Si quiere que el miembro derivado tenga el mismo nombre que un miembro de una clase base, pero no quiere que participe en la invocación virtual, puede usar la palabra clave [new](../../../csharp/language-reference/keywords/new.md).</span><span class="sxs-lookup"><span data-stu-id="64ece-144">If you want your derived member to have the same name as a member in a base class, but you do not want it to participate in virtual invocation, you can use the [new](../../../csharp/language-reference/keywords/new.md) keyword.</span></span> <span data-ttu-id="64ece-145">La palabra clave `new` se coloca antes que el tipo devuelto del miembro de la clase que se está reemplazando.</span><span class="sxs-lookup"><span data-stu-id="64ece-145">The `new` keyword is put before the return type of a class member that is being replaced.</span></span> <span data-ttu-id="64ece-146">El siguiente fragmento de código muestra un ejemplo:</span><span class="sxs-lookup"><span data-stu-id="64ece-146">The following code provides an example:</span></span>  
  
 <span data-ttu-id="64ece-147">[!code-cs[csProgGuideInheritance#18](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_4.cs)]</span><span class="sxs-lookup"><span data-stu-id="64ece-147">[!code-cs[csProgGuideInheritance#18](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_4.cs)]</span></span>  
  
 <span data-ttu-id="64ece-148">Aún se puede acceder a los miembros de la clase base ocultos desde el código de cliente convirtiendo la instancia de la clase derivada en una instancia de la clase base.</span><span class="sxs-lookup"><span data-stu-id="64ece-148">Hidden base class members can still be accessed from client code by casting the instance of the derived class to an instance of the base class.</span></span> <span data-ttu-id="64ece-149">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="64ece-149">For example:</span></span>  
  
 <span data-ttu-id="64ece-150">[!code-cs[csProgGuideInheritance#19](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_5.cs)]</span><span class="sxs-lookup"><span data-stu-id="64ece-150">[!code-cs[csProgGuideInheritance#19](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_5.cs)]</span></span>  
  
### <a name="preventing-derived-classes-from-overriding-virtual-members"></a><span data-ttu-id="64ece-151">Evitar que las clases derivadas invaliden los miembros virtuales</span><span class="sxs-lookup"><span data-stu-id="64ece-151">Preventing Derived Classes from Overriding Virtual Members</span></span>  
 <span data-ttu-id="64ece-152">Los miembros virtuales permanecen virtuales indefinidamente, independientemente de cuántas clases se hayan declarado entre el miembro virtual y la clase que originalmente la declaró.</span><span class="sxs-lookup"><span data-stu-id="64ece-152">Virtual members remain virtual indefinitely, regardless of how many classes have been declared between the virtual member and the class that originally declared it.</span></span> <span data-ttu-id="64ece-153">Si la clase A declara un miembro virtual y la clase B deriva de A, y la clase C deriva de B, la clase C hereda el miembro virtual y tiene la opción de invalidarlo, independientemente de que la clase B declarara una invalidación para ese miembro.</span><span class="sxs-lookup"><span data-stu-id="64ece-153">If class A declares a virtual member, and class B derives from A, and class C derives from B, class C inherits the virtual member, and has the option to override it, regardless of whether class B declared an override for that member.</span></span> <span data-ttu-id="64ece-154">El siguiente fragmento de código muestra un ejemplo:</span><span class="sxs-lookup"><span data-stu-id="64ece-154">The following code provides an example:</span></span>  
  
 <span data-ttu-id="64ece-155">[!code-cs[csProgGuideInheritance#22](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_6.cs)]</span><span class="sxs-lookup"><span data-stu-id="64ece-155">[!code-cs[csProgGuideInheritance#22](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_6.cs)]</span></span>  
  
 <span data-ttu-id="64ece-156">Una clase derivada puede detener la herencia virtual al declarar una invalidación como [sealed](../../../csharp/language-reference/keywords/sealed.md).</span><span class="sxs-lookup"><span data-stu-id="64ece-156">A derived class can stop virtual inheritance by declaring an override as [sealed](../../../csharp/language-reference/keywords/sealed.md).</span></span> <span data-ttu-id="64ece-157">Para ello, es necesario colocar la palabra clave `sealed` antes de la palabra clave `override` en la declaración del miembro de la clase.</span><span class="sxs-lookup"><span data-stu-id="64ece-157">This requires putting the `sealed` keyword before the `override` keyword in the class member declaration.</span></span> <span data-ttu-id="64ece-158">El siguiente fragmento de código muestra un ejemplo:</span><span class="sxs-lookup"><span data-stu-id="64ece-158">The following code provides an example:</span></span>  
  
 <span data-ttu-id="64ece-159">[!code-cs[csProgGuideInheritance#24](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_7.cs)]</span><span class="sxs-lookup"><span data-stu-id="64ece-159">[!code-cs[csProgGuideInheritance#24](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_7.cs)]</span></span>  
  
 <span data-ttu-id="64ece-160">En el ejemplo anterior, el método `DoWork` ya no es virtual para ninguna clase que derive de C. Sigue siendo virtual para instancias de C, aunque se conviertan al tipo B o A. Los métodos sellados pueden reemplazarse por las clases derivadas al usar la palabra clave `new`, como se muestra en el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="64ece-160">In the previous example, the method `DoWork` is no longer virtual to any class derived from C. It is still virtual for instances of C, even if they are cast to type B or type A. Sealed methods can be replaced by derived classes by using the `new` keyword, as the following example shows:</span></span>  
  
 <span data-ttu-id="64ece-161">[!code-cs[csProgGuideInheritance#25](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_8.cs)]</span><span class="sxs-lookup"><span data-stu-id="64ece-161">[!code-cs[csProgGuideInheritance#25](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_8.cs)]</span></span>  
  
 <span data-ttu-id="64ece-162">En este caso, si se llama a `DoWork` en D usando una variable de tipo D, se llama al nuevo `DoWork`.</span><span class="sxs-lookup"><span data-stu-id="64ece-162">In this case, if `DoWork` is called on D using a variable of type D, the new `DoWork` is called.</span></span> <span data-ttu-id="64ece-163">Si se usa una variable de tipo C, B o A para acceder a una instancia de D, la llamada a `DoWork` seguirá las reglas de herencia virtual y enrutará dichas llamadas a la implementación de `DoWork` en la clase C.</span><span class="sxs-lookup"><span data-stu-id="64ece-163">If a variable of type C, B, or A is used to access an instance of D, a call to `DoWork` will follow the rules of virtual inheritance, routing those calls to the implementation of `DoWork` on class C.</span></span>  
  
### <a name="accessing-base-class-virtual-members-from-derived-classes"></a><span data-ttu-id="64ece-164">Acceder a miembros virtuales de clases base desde clases derivadas</span><span class="sxs-lookup"><span data-stu-id="64ece-164">Accessing Base Class Virtual Members from Derived Classes</span></span>  
 <span data-ttu-id="64ece-165">Una clase derivada que ha reemplazado o invalidado un método o propiedad puede seguir accediendo al método o propiedad en la clase base usando la siguiente palabra clave base.</span><span class="sxs-lookup"><span data-stu-id="64ece-165">A derived class that has replaced or overridden a method or property can still access the method or property on the base class using the base keyword.</span></span> <span data-ttu-id="64ece-166">El siguiente fragmento de código muestra un ejemplo:</span><span class="sxs-lookup"><span data-stu-id="64ece-166">The following code provides an example:</span></span>  
  
 <span data-ttu-id="64ece-167">[!code-cs[csProgGuideInheritance#26](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_9.cs)]</span><span class="sxs-lookup"><span data-stu-id="64ece-167">[!code-cs[csProgGuideInheritance#26](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/polymorphism_9.cs)]</span></span>  
  
 <span data-ttu-id="64ece-168">Para obtener más información, vea [base](../../../csharp/language-reference/keywords/base.md).</span><span class="sxs-lookup"><span data-stu-id="64ece-168">For more information, see [base](../../../csharp/language-reference/keywords/base.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="64ece-169">Se recomienda que las máquinas virtuales usen `base` para llamar a la implementación de la clase base de ese miembro en su propia implementación.</span><span class="sxs-lookup"><span data-stu-id="64ece-169">It is recommended that virtual members use `base` to call the base class implementation of that member in their own implementation.</span></span> <span data-ttu-id="64ece-170">Dejar que se produzca el comportamiento de la clase base permite a la clase derivada concentrarse en implementar el comportamiento específico de la clase derivada.</span><span class="sxs-lookup"><span data-stu-id="64ece-170">Letting the base class behavior occur enables the derived class to concentrate on implementing behavior specific to the derived class.</span></span> <span data-ttu-id="64ece-171">Si no se llama a la implementación de la clase base, depende de la clase derivada hacer que su comportamiento sea compatible con el de la clase base.</span><span class="sxs-lookup"><span data-stu-id="64ece-171">If the base class implementation is not called, it is up to the derived class to make their behavior compatible with the behavior of the base class.</span></span>  
  
## <a name="in-this-section"></a><span data-ttu-id="64ece-172">En esta sección</span><span class="sxs-lookup"><span data-stu-id="64ece-172">In This Section</span></span>  
  
-   [<span data-ttu-id="64ece-173">Control de versiones con las palabras clave Override y New</span><span class="sxs-lookup"><span data-stu-id="64ece-173">Versioning with the Override and New Keywords</span></span>](../../../csharp/programming-guide/classes-and-structs/versioning-with-the-override-and-new-keywords.md)  
  
-   [<span data-ttu-id="64ece-174">Saber cuándo utilizar las palabras clave Override y New</span><span class="sxs-lookup"><span data-stu-id="64ece-174">Knowing When to Use Override and New Keywords</span></span>](../../../csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords.md)  
  
-   [<span data-ttu-id="64ece-175">Cómo: Invalidar el método ToString</span><span class="sxs-lookup"><span data-stu-id="64ece-175">How to: Override the ToString Method</span></span>](../../../csharp/programming-guide/classes-and-structs/how-to-override-the-tostring-method.md)  
  
## <a name="see-also"></a><span data-ttu-id="64ece-176">Vea también</span><span class="sxs-lookup"><span data-stu-id="64ece-176">See Also</span></span>  
 <span data-ttu-id="64ece-177">[Guía de programación de C#](../../../csharp/programming-guide/index.md) </span><span class="sxs-lookup"><span data-stu-id="64ece-177">[C# Programming Guide](../../../csharp/programming-guide/index.md) </span></span>  
 <span data-ttu-id="64ece-178">[Guía de programación de C#](../../../csharp/programming-guide/index.md) </span><span class="sxs-lookup"><span data-stu-id="64ece-178">[C# Programming Guide](../../../csharp/programming-guide/index.md) </span></span>  
 <span data-ttu-id="64ece-179">[Herencia](../../../csharp/programming-guide/classes-and-structs/inheritance.md) </span><span class="sxs-lookup"><span data-stu-id="64ece-179">[Inheritance](../../../csharp/programming-guide/classes-and-structs/inheritance.md) </span></span>  
 <span data-ttu-id="64ece-180">[Clases y miembros de clase abstractos y sellados](../../../csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md) </span><span class="sxs-lookup"><span data-stu-id="64ece-180">[Abstract and Sealed Classes and Class Members](../../../csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md) </span></span>  
 <span data-ttu-id="64ece-181">[Métodos](../../../csharp/programming-guide/classes-and-structs/methods.md) </span><span class="sxs-lookup"><span data-stu-id="64ece-181">[Methods](../../../csharp/programming-guide/classes-and-structs/methods.md) </span></span>  
 <span data-ttu-id="64ece-182">[Eventos](../../../csharp/programming-guide/events/index.md) </span><span class="sxs-lookup"><span data-stu-id="64ece-182">[Events](../../../csharp/programming-guide/events/index.md) </span></span>  
 <span data-ttu-id="64ece-183">[Propiedades](../../../csharp/programming-guide/classes-and-structs/properties.md) </span><span class="sxs-lookup"><span data-stu-id="64ece-183">[Properties](../../../csharp/programming-guide/classes-and-structs/properties.md) </span></span>  
 <span data-ttu-id="64ece-184">[Indexers](../../../csharp/programming-guide/indexers/index.md)  (Indexadores)</span><span class="sxs-lookup"><span data-stu-id="64ece-184">[Indexers](../../../csharp/programming-guide/indexers/index.md) </span></span>  
 [<span data-ttu-id="64ece-185">Tipos</span><span class="sxs-lookup"><span data-stu-id="64ece-185">Types</span></span>](../../../csharp/programming-guide/types/index.md)

