---
title: "Sincronización de subprocesos (C#)"
ms.custom: 
ms.date: 07/20/2015
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: devlang-csharp
ms.topic: article
ms.assetid: e42b1be6-c93c-479f-a148-be0759f1a4e1
caps.latest.revision: "3"
author: BillWagner
ms.author: wiwagn
ms.openlocfilehash: 2b51775eac5221ec8c723d89323d1f4f542d2453
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 11/21/2017
---
# <a name="thread-synchronization-c"></a><span data-ttu-id="20ace-102">Sincronización de subprocesos (C#)</span><span class="sxs-lookup"><span data-stu-id="20ace-102">Thread Synchronization (C#)</span></span>
<span data-ttu-id="20ace-103">En las secciones siguientes se describen las características y clases que se pueden usar para sincronizar el acceso a recursos en aplicaciones multiproceso.</span><span class="sxs-lookup"><span data-stu-id="20ace-103">The following sections describe features and classes that can be used to synchronize access to resources in multithreaded applications.</span></span>  
  
 <span data-ttu-id="20ace-104">Una de las ventajas de usar varios subprocesos en una aplicación es que cada subproceso se ejecuta de manera asincrónica.</span><span class="sxs-lookup"><span data-stu-id="20ace-104">One of the benefits of using multiple threads in an application is that each thread executes asynchronously.</span></span> <span data-ttu-id="20ace-105">En las aplicaciones para Windows, esto permite realizar las tareas que exigen mucho tiempo en segundo plano mientras la ventana de la aplicación y los controles siguen respondiendo.</span><span class="sxs-lookup"><span data-stu-id="20ace-105">For Windows applications, this allows time-consuming tasks to be performed in the background while the application window and controls remain responsive.</span></span> <span data-ttu-id="20ace-106">En las aplicaciones de servidor, el multithreading proporciona la capacidad de controlar cada solicitud de entrada con un subproceso diferente.</span><span class="sxs-lookup"><span data-stu-id="20ace-106">For server applications, multithreading provides the ability to handle each incoming request with a different thread.</span></span> <span data-ttu-id="20ace-107">De lo contrario, no se atendería cada nueva solicitud hasta que se hubiera satisfecho totalmente la solicitud anterior.</span><span class="sxs-lookup"><span data-stu-id="20ace-107">Otherwise, each new request would not get serviced until the previous request had been fully satisfied.</span></span>  
  
 <span data-ttu-id="20ace-108">En cambio, la naturaleza asincrónica de los subprocesos significa que el acceso a recursos como identificadores de archivos, conexiones de red y memoria se deben coordinar.</span><span class="sxs-lookup"><span data-stu-id="20ace-108">However, the asynchronous nature of threads means that access to resources such as file handles, network connections, and memory must be coordinated.</span></span> <span data-ttu-id="20ace-109">De lo contrario, dos o más subprocesos podrían tener acceso al mismo tiempo al mismo recurso, cada uno desprevenido de las acciones del otro.</span><span class="sxs-lookup"><span data-stu-id="20ace-109">Otherwise, two or more threads could access the same resource at the same time, each unaware of the other's actions.</span></span> <span data-ttu-id="20ace-110">El resultado serían daños imprevisibles en los datos.</span><span class="sxs-lookup"><span data-stu-id="20ace-110">The result is unpredictable data corruption.</span></span>  
  
 <span data-ttu-id="20ace-111">Para las operaciones simples en tipos de datos numéricos enteros, la sincronización de subprocesos se puede lograr con miembros de la clase <xref:System.Threading.Interlocked>.</span><span class="sxs-lookup"><span data-stu-id="20ace-111">For simple operations on integral numeric data types, synchronizing threads can be accomplished with members of the <xref:System.Threading.Interlocked> class.</span></span> <span data-ttu-id="20ace-112">Para todos los demás tipos de datos y los recursos no seguros para subprocesos, el multithreading solo se puede realizar de manera segura con las construcciones de este tema.</span><span class="sxs-lookup"><span data-stu-id="20ace-112">For all other data types and non thread-safe resources, multithreading can only be safely performed using the constructs in this topic.</span></span>  
  
 <span data-ttu-id="20ace-113">Para obtener información general sobre la programación multiproceso, vea:</span><span class="sxs-lookup"><span data-stu-id="20ace-113">For background information on multithreaded programming, see:</span></span>  
  
-   [<span data-ttu-id="20ace-114">Principios básicos del subprocesamiento administrado</span><span class="sxs-lookup"><span data-stu-id="20ace-114">Managed Threading Basics</span></span>](../../../../standard/threading/managed-threading-basics.md)  
  
-   [<span data-ttu-id="20ace-115">Usar subprocesos y subprocesamiento</span><span class="sxs-lookup"><span data-stu-id="20ace-115">Using Threads and Threading</span></span>](../../../../standard/threading/using-threads-and-threading.md)  
  
-   [<span data-ttu-id="20ace-116">Procedimientos recomendados para el subprocesamiento administrado</span><span class="sxs-lookup"><span data-stu-id="20ace-116">Managed Threading Best Practices</span></span>](../../../../standard/threading/managed-threading-best-practices.md)  
  
## <a name="the-lock-keyword"></a><span data-ttu-id="20ace-117">La palabra clave lock</span><span class="sxs-lookup"><span data-stu-id="20ace-117">The lock Keyword</span></span>  
 <span data-ttu-id="20ace-118">La instrucción `lock` de C# se puede usar para garantizar que un bloque de código se ejecuta hasta el final sin que lo interrumpan otros subprocesos.</span><span class="sxs-lookup"><span data-stu-id="20ace-118">The C# `lock` statement can be used to ensure that a block of code runs to completion without interruption by other threads.</span></span> <span data-ttu-id="20ace-119">Esto se logra obteniendo un bloqueo de exclusión mutua para un objeto determinado durante la ejecución de un bloque de código.</span><span class="sxs-lookup"><span data-stu-id="20ace-119">This is accomplished by obtaining a mutual-exclusion lock for a given object for the duration of the code block.</span></span>  
  
 <span data-ttu-id="20ace-120">Una instrucción `lock` consiste en dar un objeto como argumento, seguido de un bloque de código que solo un subproceso puede ejecutar simultáneamente.</span><span class="sxs-lookup"><span data-stu-id="20ace-120">A `lock` statement is given an object as an argument, and is followed by a code block that is to be executed by only one thread at a time.</span></span> <span data-ttu-id="20ace-121">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="20ace-121">For example:</span></span>  
  
```csharp  
public class TestThreading  
{  
    private System.Object lockThis = new System.Object();  
  
    public void Process()  
    {  
  
        lock (lockThis)  
        {  
            // Access thread-sensitive resources.  
        }  
    }  
  
}  
```  
  
 <span data-ttu-id="20ace-122">El argumento suministrado a la palabra clave `lock` debe ser un objeto basado en un tipo de referencia y se usa para definir el ámbito del bloqueo.</span><span class="sxs-lookup"><span data-stu-id="20ace-122">The argument provided to the `lock` keyword must be an object based on a reference type, and is used to define the scope of the lock.</span></span> <span data-ttu-id="20ace-123">En el ejemplo anterior, el ámbito del bloqueo se limita a esta función porque no existe ninguna referencia al objeto `lockThis` fuera de la función.</span><span class="sxs-lookup"><span data-stu-id="20ace-123">In the example above, the lock scope is limited to this function because no references to the object `lockThis` exist outside the function.</span></span> <span data-ttu-id="20ace-124">Si existiese una referencia de ese tipo, el ámbito del bloqueo se extendería a ese objeto.</span><span class="sxs-lookup"><span data-stu-id="20ace-124">If such a reference did exist, lock scope would extend to that object.</span></span> <span data-ttu-id="20ace-125">Estrictamente, el objeto suministrado solo se usa para identificar únicamente el recurso que varios subprocesos comparten, de modo que puede ser una instancia de clase arbitraria.</span><span class="sxs-lookup"><span data-stu-id="20ace-125">Strictly speaking, the object provided is used solely to uniquely identify the resource being shared among multiple threads, so it can be an arbitrary class instance.</span></span> <span data-ttu-id="20ace-126">En cambio, en la práctica, este objeto normalmente representa el recurso para el que la sincronización de subprocesos es necesaria.</span><span class="sxs-lookup"><span data-stu-id="20ace-126">In practice, however, this object usually represents the resource for which thread synchronization is necessary.</span></span> <span data-ttu-id="20ace-127">Por ejemplo, si varios subprocesos van a usar un objeto contenedor, se puede pasar el contenedor para bloquearlo. Entonces, el bloque de código sincronizado que sigue al bloqueo tendría acceso al contenedor.</span><span class="sxs-lookup"><span data-stu-id="20ace-127">For example, if a container object is to be used by multiple threads, then the container can be passed to lock, and the synchronized code block following the lock would access the container.</span></span> <span data-ttu-id="20ace-128">Con tal de que otros subprocesos bloqueen el mismo contenedor antes de tener acceso a él, el acceso al objeto se sincroniza de manera segura.</span><span class="sxs-lookup"><span data-stu-id="20ace-128">As long as other threads locks on the same contain before accessing it, then access to the object is safely synchronized.</span></span>  
  
 <span data-ttu-id="20ace-129">Generalmente, es mejor evitar el bloqueo en un tipo `public` o en instancias de objeto que estén fuera del control de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="20ace-129">Generally, it is best to avoid locking on a `public` type, or on object instances beyond the control of your application.</span></span> <span data-ttu-id="20ace-130">Por ejemplo, `lock(this)` puede ser problemático si se puede tener acceso a la instancia públicamente, ya que el código que está fuera de su control también puede bloquear el objeto.</span><span class="sxs-lookup"><span data-stu-id="20ace-130">For example, `lock(this)` can be problematic if the instance can be accessed publicly, because code beyond your control may lock on the object as well.</span></span> <span data-ttu-id="20ace-131">Esto podría crear situaciones del interbloqueo, en las que dos o más subprocesos esperan a que se libere el mismo objeto.</span><span class="sxs-lookup"><span data-stu-id="20ace-131">This could create deadlock situations where two or more threads wait for the release of the same object.</span></span> <span data-ttu-id="20ace-132">El bloqueo de un tipo de datos público, como opuesto a un objeto, puede crear problemas por la misma razón.</span><span class="sxs-lookup"><span data-stu-id="20ace-132">Locking on a public data type, as opposed to an object, can cause problems for the same reason.</span></span> <span data-ttu-id="20ace-133">El bloqueo de cadenas literales es especialmente arriesgado porque Common Language Runtime (CLR) *interna* las cadenas literales.</span><span class="sxs-lookup"><span data-stu-id="20ace-133">Locking on literal strings is especially risky because literal strings are *interned* by the common language runtime (CLR).</span></span> <span data-ttu-id="20ace-134">Esto significa que hay una instancia de un literal de cadena determinado para todo el programa, exactamente el mismo objeto representa el literal en todos los dominios de la aplicación en ejecución, en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="20ace-134">This means that there is one instance of any given string literal for the entire program, the exact same object represents the literal in all running application domains, on all threads.</span></span> <span data-ttu-id="20ace-135">Como resultado, un bloqueo sobre una cadena que tiene el mismo contenido en cualquier parte del proceso de la aplicación bloquea todas las instancias de esa cadena en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="20ace-135">As a result, a lock placed on a string with the same contents anywhere in the application process locks all instances of that string in the application.</span></span> <span data-ttu-id="20ace-136">Por tanto, es mejor bloquear un miembro privado o protegido que no esté internado.</span><span class="sxs-lookup"><span data-stu-id="20ace-136">As a result, it is best to lock a private or protected member that is not interned.</span></span> <span data-ttu-id="20ace-137">Algunas clases proporcionan específicamente los miembros para bloquear.</span><span class="sxs-lookup"><span data-stu-id="20ace-137">Some classes provide members specifically for locking.</span></span> <span data-ttu-id="20ace-138">El tipo <xref:System.Array>, por ejemplo, proporciona <xref:System.Array.SyncRoot%2A>.</span><span class="sxs-lookup"><span data-stu-id="20ace-138">The <xref:System.Array> type, for example, provides <xref:System.Array.SyncRoot%2A>.</span></span> <span data-ttu-id="20ace-139">Muchos tipos de colección también proporcionan un miembro `SyncRoot`.</span><span class="sxs-lookup"><span data-stu-id="20ace-139">Many collection types provide a `SyncRoot` member as well.</span></span>  
  
 <span data-ttu-id="20ace-140">Vea los siguientes temas para obtener más información sobre la instrucción `lock`:</span><span class="sxs-lookup"><span data-stu-id="20ace-140">For more information about the `lock` statement, see the following topics:</span></span>  
  
-   [<span data-ttu-id="20ace-141">lock (instrucción)</span><span class="sxs-lookup"><span data-stu-id="20ace-141">lock Statement</span></span>](../../../../csharp/language-reference/keywords/lock-statement.md)  
  
-   <xref:System.Threading.Monitor>  
  
## <a name="monitors"></a><span data-ttu-id="20ace-142">Monitores</span><span class="sxs-lookup"><span data-stu-id="20ace-142">Monitors</span></span>  
 <span data-ttu-id="20ace-143">Como la palabra clave `lock`, los monitores evitan que varios subprocesos ejecuten simultáneamente bloques de código.</span><span class="sxs-lookup"><span data-stu-id="20ace-143">Like the `lock` keyword, monitors prevent blocks of code from simultaneous execution by multiple threads.</span></span> <span data-ttu-id="20ace-144">El método <xref:System.Threading.Monitor.Enter%2A> permite que un subproceso, y solo uno, continúe con las instrucciones siguientes; todos los demás subprocesos se bloquean hasta que el subproceso en ejecución llama a <xref:System.Threading.Monitor.Exit%2A>.</span><span class="sxs-lookup"><span data-stu-id="20ace-144">The <xref:System.Threading.Monitor.Enter%2A> method allows one and only one thread to proceed into the following statements; all other threads are blocked until the executing thread calls <xref:System.Threading.Monitor.Exit%2A>.</span></span> <span data-ttu-id="20ace-145">Esto es similar a usar la palabra clave `lock`.</span><span class="sxs-lookup"><span data-stu-id="20ace-145">This is just like using the `lock` keyword.</span></span> <span data-ttu-id="20ace-146">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="20ace-146">For example:</span></span>  
  
```csharp  
lock (x)  
{  
    DoSomething();  
}  
```  
  
 <span data-ttu-id="20ace-147">Esto equivale a:</span><span class="sxs-lookup"><span data-stu-id="20ace-147">This is equivalent to:</span></span>  
  
```csharp  
System.Object obj = (System.Object)x;  
System.Threading.Monitor.Enter(obj);  
try  
{  
    DoSomething();  
}  
finally  
{  
    System.Threading.Monitor.Exit(obj);  
}  
```  
  
 <span data-ttu-id="20ace-148">Normalmente, es preferible usar la palabra clave `lock` en vez de usar directamente la clase <xref:System.Threading.Monitor>, porque `lock` es más conciso y porque `lock` garantiza que se libera el monitor subyacente, aunque el código protegido produzca una excepción.</span><span class="sxs-lookup"><span data-stu-id="20ace-148">Using the `lock` keyword is generally preferred over using the <xref:System.Threading.Monitor> class directly, both because `lock` is more concise, and because `lock` insures that the underlying monitor is released, even if the protected code throws an exception.</span></span> <span data-ttu-id="20ace-149">Esto se logra con la palabra clave `finally`, que ejecuta su bloque de código asociado independientemente de que se produzca una excepción.</span><span class="sxs-lookup"><span data-stu-id="20ace-149">This is accomplished with the `finally` keyword, which executes its associated code block regardless of whether an exception is thrown.</span></span>  
  
## <a name="synchronization-events-and-wait-handles"></a><span data-ttu-id="20ace-150">Eventos de sincronización y controladores de espera</span><span class="sxs-lookup"><span data-stu-id="20ace-150">Synchronization Events and Wait Handles</span></span>  
 <span data-ttu-id="20ace-151">El uso de un bloqueo o un monitor es útil para evitar la ejecución simultánea de bloques de código usados por varios subprocesos, pero estas construcciones no permiten que un subproceso comunique un evento a otro.</span><span class="sxs-lookup"><span data-stu-id="20ace-151">Using a lock or monitor is useful for preventing the simultaneous execution of thread-sensitive blocks of code, but these constructs do not allow one thread to communicate an event to another.</span></span> <span data-ttu-id="20ace-152">Esto requiere *eventos de sincronización*, que son objetos que tienen uno de dos estados, señalizado y no señalizado, que se pueden usar para activar y suspender subprocesos.</span><span class="sxs-lookup"><span data-stu-id="20ace-152">This requires *synchronization events*, which are objects that have one of two states, signaled and un-signaled, that can be used to activate and suspend threads.</span></span> <span data-ttu-id="20ace-153">Los subprocesos se pueden suspender haciendo que esperen a que se produzca un evento de sincronización que no esté señalizado y se pueden activar cambiando el estado del evento a señalizado.</span><span class="sxs-lookup"><span data-stu-id="20ace-153">Threads can be suspended by being made to wait on a synchronization event that is unsignaled, and can be activated by changing the event state to signaled.</span></span> <span data-ttu-id="20ace-154">Si un subproceso intenta esperar a que se produzca un evento que ya está señalizado, el subproceso se sigue ejecutando sin retraso.</span><span class="sxs-lookup"><span data-stu-id="20ace-154">If a thread attempts to wait on an event that is already signaled, then the thread continues to execute without delay.</span></span>  
  
 <span data-ttu-id="20ace-155">Existen dos tipos de eventos de sincronización: <xref:System.Threading.AutoResetEvent> y <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="20ace-155">There are two kinds of synchronization events: <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="20ace-156">Solo difieren en que <xref:System.Threading.AutoResetEvent> cambia automáticamente de señalizado a no señalizado siempre que activa un subproceso.</span><span class="sxs-lookup"><span data-stu-id="20ace-156">They differ only in that <xref:System.Threading.AutoResetEvent> changes from signaled to unsignaled automatically any time it activates a thread.</span></span> <span data-ttu-id="20ace-157">Por el contrario, <xref:System.Threading.ManualResetEvent> permite que se active cualquier número de subprocesos mediante su estado señalizado, y solo volverá a un estado no señalizado cuando se llame a su método <xref:System.Threading.EventWaitHandle.Reset%2A>.</span><span class="sxs-lookup"><span data-stu-id="20ace-157">Conversely, a <xref:System.Threading.ManualResetEvent> allows any number of threads to be activated by its signaled state, and will only revert to an unsignaled state when its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
 <span data-ttu-id="20ace-158">Los subprocesos pueden crearse para que esperen en eventos llamando a uno de los métodos de espera, como <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A> o <xref:System.Threading.WaitHandle.WaitAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="20ace-158">Threads can be made to wait on events by calling one of the wait methods, such as <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.WaitAll%2A>.</span></span> <span data-ttu-id="20ace-159"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> hace que el subproceso espere hasta que un único evento se señaliza, <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> bloquea un subproceso hasta que uno o más eventos indicados se señalizan y <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> bloquea el subproceso hasta que todos los eventos indicados se señalizan.</span><span class="sxs-lookup"><span data-stu-id="20ace-159"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> causes the thread to wait until a single event becomes signaled, <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> blocks a thread until one or more indicated events become signaled, and <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> blocks the thread until all of the indicated events become signaled.</span></span> <span data-ttu-id="20ace-160">Un evento se señaliza cuando se llama a su método <xref:System.Threading.EventWaitHandle.Set%2A>.</span><span class="sxs-lookup"><span data-stu-id="20ace-160">An event becomes signaled when its <xref:System.Threading.EventWaitHandle.Set%2A> method is called.</span></span>  
  
 <span data-ttu-id="20ace-161">En el ejemplo siguiente, la función `Main` crea e inicia un subproceso.</span><span class="sxs-lookup"><span data-stu-id="20ace-161">In the following example, a thread is created and started by the `Main` function.</span></span> <span data-ttu-id="20ace-162">El nuevo subproceso espera en un evento con el método <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="20ace-162">The new thread waits on an event using the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="20ace-163">Se suspende el subproceso hasta que el evento sea señalizado por el subproceso primario que está ejecutando la función `Main`.</span><span class="sxs-lookup"><span data-stu-id="20ace-163">The thread is suspended until the event becomes signaled by the primary thread that is executing the `Main` function.</span></span> <span data-ttu-id="20ace-164">Cuando el evento se señaliza, el subproceso auxiliar se devuelve.</span><span class="sxs-lookup"><span data-stu-id="20ace-164">Once the event becomes signaled, the auxiliary thread returns.</span></span> <span data-ttu-id="20ace-165">En este caso, como el evento solo se usa para una activación de subproceso, pueden usarse las clases <xref:System.Threading.AutoResetEvent> o <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="20ace-165">In this case, because the event is only used for one thread activation, either the <xref:System.Threading.AutoResetEvent> or <xref:System.Threading.ManualResetEvent> classes could be used.</span></span>  
  
```csharp  
using System;  
using System.Threading;  
  
class ThreadingExample  
{  
    static AutoResetEvent autoEvent;  
  
    static void DoWork()  
    {  
        Console.WriteLine("   worker thread started, now waiting on event...");  
        autoEvent.WaitOne();  
        Console.WriteLine("   worker thread reactivated, now exiting...");  
    }  
  
    static void Main()  
    {  
        autoEvent = new AutoResetEvent(false);  
  
        Console.WriteLine("main thread starting worker thread...");  
        Thread t = new Thread(DoWork);  
        t.Start();  
  
        Console.WriteLine("main thread sleeping for 1 second...");  
        Thread.Sleep(1000);  
  
        Console.WriteLine("main thread signaling worker thread...");  
        autoEvent.Set();  
    }  
}  
```  
  
## <a name="mutex-object"></a><span data-ttu-id="20ace-166">Objeto Mutex</span><span class="sxs-lookup"><span data-stu-id="20ace-166">Mutex Object</span></span>  
 <span data-ttu-id="20ace-167">Una *exclusión mutua* es similar a un monitor; impide la ejecución simultánea de un bloque de código por más de un subproceso a la vez.</span><span class="sxs-lookup"><span data-stu-id="20ace-167">A *mutex* is similar to a monitor; it prevents the simultaneous execution of a block of code by more than one thread at a time.</span></span> <span data-ttu-id="20ace-168">De hecho, el nombre "mutex" es una manera abreviada del término "mutuamente exclusivo".</span><span class="sxs-lookup"><span data-stu-id="20ace-168">In fact, the name "mutex" is a shortened form of the term "mutually exclusive."</span></span> <span data-ttu-id="20ace-169">En cambio, a diferencia de los monitores, una exclusión mutua se puede usar para sincronizar los subprocesos entre varios procesos.</span><span class="sxs-lookup"><span data-stu-id="20ace-169">Unlike monitors, however, a mutex can be used to synchronize threads across processes.</span></span> <span data-ttu-id="20ace-170">La clase <xref:System.Threading.Mutex> representa una exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="20ace-170">A mutex is represented by the <xref:System.Threading.Mutex> class.</span></span>  
  
 <span data-ttu-id="20ace-171">Cuando se usa para la sincronización entre procesos, una exclusión mutua se denomina una *exclusión mutua con nombre* porque va a usarla otra aplicación y, por tanto, no se puede compartir por medio de una variable global o estática.</span><span class="sxs-lookup"><span data-stu-id="20ace-171">When used for inter-process synchronization, a mutex is called a *named mutex* because it is to be used in another application, and therefore it cannot be shared by means of a global or static variable.</span></span> <span data-ttu-id="20ace-172">Se debe asignar un nombre para que ambas aplicaciones puedan tener acceso al mismo objeto de exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="20ace-172">It must be given a name so that both applications can access the same mutex object.</span></span>  
  
 <span data-ttu-id="20ace-173">Aunque se puede usar una exclusión mutua para la sincronización de subprocesos dentro de un proceso, normalmente es preferible usar <xref:System.Threading.Monitor> porque los monitores se diseñaron específicamente para .NET Framework y, por tanto, hacen un mejor uso de los recursos.</span><span class="sxs-lookup"><span data-stu-id="20ace-173">Although a mutex can be used for intra-process thread synchronization, using <xref:System.Threading.Monitor> is generally preferred, because monitors were designed specifically for the .NET Framework and therefore make better use of resources.</span></span> <span data-ttu-id="20ace-174">Por el contrario, la clase <xref:System.Threading.Mutex> es un contenedor para una construcción de Win32.</span><span class="sxs-lookup"><span data-stu-id="20ace-174">In contrast, the <xref:System.Threading.Mutex> class is a wrapper to a Win32 construct.</span></span> <span data-ttu-id="20ace-175">Aunque es más eficaz que un monitor, una exclusión mutua requiere transiciones de interoperabilidad que son más costosas a nivel computacional que las requeridas por la clase <xref:System.Threading.Monitor>.</span><span class="sxs-lookup"><span data-stu-id="20ace-175">While it is more powerful than a monitor, a mutex requires interop transitions that are more computationally expensive than those required by the <xref:System.Threading.Monitor> class.</span></span> <span data-ttu-id="20ace-176">Para obtener un ejemplo de uso de la exclusión mutua, vea [Exclusiones mutuas (mutex)](../../../../standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="20ace-176">For an example of using a mutex, see [Mutexes](../../../../standard/threading/mutexes.md).</span></span>  
  
## <a name="interlocked-class"></a><span data-ttu-id="20ace-177">Clase Interlocked</span><span class="sxs-lookup"><span data-stu-id="20ace-177">Interlocked Class</span></span>  
 <span data-ttu-id="20ace-178">Puede usar los métodos de la clase <xref:System.Threading.Interlocked> para evitar problemas que pueden producirse cuando varios subprocesos intentan actualizar o comparar simultáneamente el mismo valor.</span><span class="sxs-lookup"><span data-stu-id="20ace-178">You can use the methods of the <xref:System.Threading.Interlocked> class to prevent problems that can occur when multiple threads attempt to simultaneously update or compare the same value.</span></span> <span data-ttu-id="20ace-179">Los métodos de esta clase le permiten incrementar, reducir, intercambiar y comparar valores, de manera segura, desde cualquier subproceso.</span><span class="sxs-lookup"><span data-stu-id="20ace-179">The methods of this class let you safely increment, decrement, exchange, and compare values from any thread.</span></span>  
  
## <a name="readerwriter-locks"></a><span data-ttu-id="20ace-180">Bloqueos ReaderWriter</span><span class="sxs-lookup"><span data-stu-id="20ace-180">ReaderWriter Locks</span></span>  
 <span data-ttu-id="20ace-181">En algunos casos, quizá quiera bloquear un recurso solo mientras se están escribiendo los datos y permitir que varios clientes puedan leer datos simultáneamente cuando no se estén actualizando los datos.</span><span class="sxs-lookup"><span data-stu-id="20ace-181">In some cases, you may want to lock a resource only when data is being written and permit multiple clients to simultaneously read data when data is not being updated.</span></span> <span data-ttu-id="20ace-182">La clase <xref:System.Threading.ReaderWriterLock> fuerza el acceso exclusivo a un recurso mientras hay un subproceso modificando el recurso, pero permite el acceso no exclusivo al leer el recurso.</span><span class="sxs-lookup"><span data-stu-id="20ace-182">The <xref:System.Threading.ReaderWriterLock> class enforces exclusive access to a resource while a thread is modifying the resource, but it allows non-exclusive access when reading the resource.</span></span> <span data-ttu-id="20ace-183">Los bloqueos de ReaderWriter son una alternativa útil a los bloqueos exclusivos que hacen esperar a otros subprocesos, incluso cuando esos subprocesos no necesitan actualizar datos.</span><span class="sxs-lookup"><span data-stu-id="20ace-183">ReaderWriter locks are a useful alternative to exclusive locks, which cause other threads to wait, even when those threads do not need to update data.</span></span>  
  
## <a name="deadlocks"></a><span data-ttu-id="20ace-184">Interbloqueos</span><span class="sxs-lookup"><span data-stu-id="20ace-184">Deadlocks</span></span>  
 <span data-ttu-id="20ace-185">La sincronización de subprocesos resulta de un valor incalculable en aplicaciones multiproceso, pero siempre existe el peligro de crear un `deadlock`, en el que varios subprocesos están esperando unos a otros y la aplicación se bloquea.</span><span class="sxs-lookup"><span data-stu-id="20ace-185">Thread synchronization is invaluable in multithreaded applications, but there is always the danger of creating a `deadlock`, where multiple threads are waiting for each other and the application comes to a halt.</span></span> <span data-ttu-id="20ace-186">Un interbloqueo es una situación análoga a otra en la que hay automóviles parados en un cruce con cuatro señales de stop y cada uno de los conductores está esperando a que los otros se pongan en marcha.</span><span class="sxs-lookup"><span data-stu-id="20ace-186">A deadlock is analogous to a situation in which cars are stopped at a four-way stop and each person is waiting for the other to go.</span></span> <span data-ttu-id="20ace-187">Evitar los interbloqueos es importante; la clave se planea cuidadosamente.</span><span class="sxs-lookup"><span data-stu-id="20ace-187">Avoiding deadlocks is important; the key is careful planning.</span></span> <span data-ttu-id="20ace-188">A menudo es posible predecir situaciones de interbloqueo mediante la creación de diagramas de las aplicaciones multiproceso, antes de empezar a escribir código.</span><span class="sxs-lookup"><span data-stu-id="20ace-188">You can often predict deadlock situations by diagramming multithreaded applications before you start coding.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="20ace-189">Vea también</span><span class="sxs-lookup"><span data-stu-id="20ace-189">See Also</span></span>  
 <xref:System.Threading.Thread>  
 <xref:System.Threading.WaitHandle.WaitOne%2A>  
 <xref:System.Threading.WaitHandle.WaitAny%2A>  
 <xref:System.Threading.WaitHandle.WaitAll%2A>  
 <xref:System.Threading.Thread.Join%2A>  
 <xref:System.Threading.Thread.Start%2A>  
 <xref:System.Threading.Thread.Sleep%2A>  
 <xref:System.Threading.Monitor>  
 <xref:System.Threading.Mutex>  
 <xref:System.Threading.AutoResetEvent>  
 <xref:System.Threading.ManualResetEvent>  
 <xref:System.Threading.Interlocked>  
 <xref:System.Threading.WaitHandle>  
 <xref:System.Threading.EventWaitHandle>  
 <xref:System.Threading>  
 <xref:System.Threading.EventWaitHandle.Set%2A>  
 <xref:System.Threading.Monitor>  
 [<span data-ttu-id="20ace-190">Aplicaciones multiproceso (C#)</span><span class="sxs-lookup"><span data-stu-id="20ace-190">Multithreaded Applications (C#)</span></span>](../../../../csharp/programming-guide/concepts/threading/multithreaded-applications.md)  
 [<span data-ttu-id="20ace-191">lock (instrucción)</span><span class="sxs-lookup"><span data-stu-id="20ace-191">lock Statement</span></span>](../../../../csharp/language-reference/keywords/lock-statement.md)  
 <span data-ttu-id="20ace-192">[Mutexes](../../../../standard/threading/mutexes.md) (Clases Mutex)</span><span class="sxs-lookup"><span data-stu-id="20ace-192">[Mutexes](../../../../standard/threading/mutexes.md)</span></span>  
 <span data-ttu-id="20ace-193">[Interlocked Operations](../../../../standard/threading/interlocked-operations.md) (Operaciones Interlocked)</span><span class="sxs-lookup"><span data-stu-id="20ace-193">[Interlocked Operations](../../../../standard/threading/interlocked-operations.md)</span></span>  
 [<span data-ttu-id="20ace-194">AutoResetEvent</span><span class="sxs-lookup"><span data-stu-id="20ace-194">AutoResetEvent</span></span>](../../../../standard/threading/autoresetevent.md)  
 [<span data-ttu-id="20ace-195">Sincronizar datos para subprocesamiento múltiple</span><span class="sxs-lookup"><span data-stu-id="20ace-195">Synchronizing Data for Multithreading</span></span>](../../../../standard/threading/synchronizing-data-for-multithreading.md)
