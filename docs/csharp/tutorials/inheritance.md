---
title: Herencia en C#
description: Aprenda a usar la herencia en bibliotecas y aplicaciones en C#.
author: rpetrusha
ms.author: ronpet
ms.date: 08/16/2017
ms.assetid: aeb68c74-0ea0-406f-9fbe-2ce02d47ef31
ms.openlocfilehash: 1476425594e55531fdb56de531ee61808dccd7db
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 05/04/2018
ms.locfileid: "33365766"
---
# <a name="inheritance-in-c-and-net"></a><span data-ttu-id="a312f-103">Herencia en C# y .NET</span><span class="sxs-lookup"><span data-stu-id="a312f-103">Inheritance in C# and .NET</span></span>

<span data-ttu-id="a312f-104">Este tutorial es una introducción a la herencia en C#.</span><span class="sxs-lookup"><span data-stu-id="a312f-104">This tutorial introduces you to inheritance in C#.</span></span> <span data-ttu-id="a312f-105">La herencia es una característica de los lenguajes de programación orientados a objetos que permite definir una clase base, que proporciona funcionalidad específica (datos y comportamiento), así como clases derivadas, que heredan o invalidan esa funcionalidad.</span><span class="sxs-lookup"><span data-stu-id="a312f-105">Inheritance is a feature of object-oriented programming languages that allows you to define a base class that provides specific functionality (data and behavior) and to define derived classes that either inherit or override that functionality.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="a312f-106">Requisitos previos</span><span class="sxs-lookup"><span data-stu-id="a312f-106">Prerequisites</span></span>

<span data-ttu-id="a312f-107">En este tutorial se supone que ha instalado .NET Core.</span><span class="sxs-lookup"><span data-stu-id="a312f-107">This tutorial assumes that you've installed .NET Core.</span></span> <span data-ttu-id="a312f-108">Para obtener instrucciones de instalación, consulte [.NET Core installation guide](https://www.microsoft.com/net/core) (Guía de instalación de .NET Core).</span><span class="sxs-lookup"><span data-stu-id="a312f-108">For installation instructions, see [.NET Core installation guide](https://www.microsoft.com/net/core).</span></span> <span data-ttu-id="a312f-109">También necesitará un editor de código.</span><span class="sxs-lookup"><span data-stu-id="a312f-109">You also need a code editor.</span></span> <span data-ttu-id="a312f-110">En este tutorial se usa [Visual Studio Code](https://code.visualstudio.com), aunque puede elegir el que prefiera.</span><span class="sxs-lookup"><span data-stu-id="a312f-110">This tutorial uses [Visual Studio Code](https://code.visualstudio.com), although you can use any code editor of your choice.</span></span>

## <a name="running-the-examples"></a><span data-ttu-id="a312f-111">Ejecución de los ejemplos</span><span class="sxs-lookup"><span data-stu-id="a312f-111">Running the examples</span></span>

<span data-ttu-id="a312f-112">Para crear y ejecutar los ejemplos de este tutorial, use la utilidad [dotnet](../../core/tools/dotnet.md) desde la línea de comandos.</span><span class="sxs-lookup"><span data-stu-id="a312f-112">To create and run the examples in this tutorial, you use the [dotnet](../../core/tools/dotnet.md) utility from the command line.</span></span> <span data-ttu-id="a312f-113">Siga estos pasos para cada ejemplo:</span><span class="sxs-lookup"><span data-stu-id="a312f-113">Follow these steps for each example:</span></span>

1. <span data-ttu-id="a312f-114">Cree un directorio para almacenar el ejemplo.</span><span class="sxs-lookup"><span data-stu-id="a312f-114">Create a directory to store the example.</span></span>
1. <span data-ttu-id="a312f-115">Escriba el comando [dotnet new console](../../core/tools/dotnet-new.md) en el símbolo del sistema para crear un nuevo proyecto de .NET Core.</span><span class="sxs-lookup"><span data-stu-id="a312f-115">Enter the [dotnet new console](../../core/tools/dotnet-new.md) command at a command prompt to create a new .NET Core project.</span></span>
1. <span data-ttu-id="a312f-116">Copie y pegue el código del ejemplo en el editor de código.</span><span class="sxs-lookup"><span data-stu-id="a312f-116">Copy and paste the code from the example into your code editor.</span></span>
1. <span data-ttu-id="a312f-117">Escriba el comando [dotnet restore](../../core/tools/dotnet-restore.md) desde la línea de comandos para cargar o restaurar las dependencias del proyecto.</span><span class="sxs-lookup"><span data-stu-id="a312f-117">Enter the [dotnet restore](../../core/tools/dotnet-restore.md) command from the command line to load or restore the project's dependencies.</span></span>

  [!INCLUDE[DotNet Restore Note](~/includes/dotnet-restore-note.md)]

1. <span data-ttu-id="a312f-118">Escriba el comando [dotnet run](../../core/tools/dotnet-run.md) para compilar y ejecutar el ejemplo.</span><span class="sxs-lookup"><span data-stu-id="a312f-118">Enter the [dotnet run](../../core/tools/dotnet-run.md) command to compile and execute the example.</span></span>


## <a name="background-what-is-inheritance"></a><span data-ttu-id="a312f-119">Contexto: ¿Qué es la herencia?</span><span class="sxs-lookup"><span data-stu-id="a312f-119">Background: What is inheritance?</span></span>

<span data-ttu-id="a312f-120">La *herencia* es uno de los atributos fundamentales de la programación orientada a objetos.</span><span class="sxs-lookup"><span data-stu-id="a312f-120">*Inheritance* is one of the fundamental attributes of object-oriented programming.</span></span> <span data-ttu-id="a312f-121">Permite definir una clase secundaria que reutiliza (hereda), amplía o modifica el comportamiento de una clase primaria.</span><span class="sxs-lookup"><span data-stu-id="a312f-121">It allows you to define a child class that reuses (inherits), extends, or modifies the behavior of a parent class.</span></span> <span data-ttu-id="a312f-122">La clase cuyos miembros son heredados se conoce como *clase base*.</span><span class="sxs-lookup"><span data-stu-id="a312f-122">The class whose members are inherited is called the *base class*.</span></span> <span data-ttu-id="a312f-123">La clase que hereda los miembros de la clase base se conoce como *clase derivada*.</span><span class="sxs-lookup"><span data-stu-id="a312f-123">The class that inherits the members of the base class is called the *derived class*.</span></span>

<span data-ttu-id="a312f-124">C# y .NET solo admiten *herencia única*.</span><span class="sxs-lookup"><span data-stu-id="a312f-124">C# and .NET support *single inheritance* only.</span></span> <span data-ttu-id="a312f-125">Es decir, una clase solo puede heredar de una clase única.</span><span class="sxs-lookup"><span data-stu-id="a312f-125">That is, a class can only inherit from a single class.</span></span> <span data-ttu-id="a312f-126">Sin embargo, la herencia es transitiva, lo que le permite definir una jerarquía de herencia para un conjunto de tipos.</span><span class="sxs-lookup"><span data-stu-id="a312f-126">However, inheritance is transitive, which allows you to define an inheritance hierarchy for a set of types.</span></span> <span data-ttu-id="a312f-127">En otras palabras, el tipo `D` puede heredar del tipo `C`, que hereda del tipo `B`, que hereda del tipo de clase base `A`.</span><span class="sxs-lookup"><span data-stu-id="a312f-127">In other words, type `D` can inherit from type `C`, which inherits from type `B`, which inherits from the base class type `A`.</span></span> <span data-ttu-id="a312f-128">Dado que la herencia es transitiva, los miembros de tipo `A` están disponibles para el tipo `D`.</span><span class="sxs-lookup"><span data-stu-id="a312f-128">Because inheritance is transitive, the members of type `A` are available to type `D`.</span></span>

<span data-ttu-id="a312f-129">No todos los miembros de una clase base los heredan las clases derivadas.</span><span class="sxs-lookup"><span data-stu-id="a312f-129">Not all members of a base class are inherited by derived classes.</span></span> <span data-ttu-id="a312f-130">Los siguientes miembros no se heredan:</span><span class="sxs-lookup"><span data-stu-id="a312f-130">The following members are not inherited:</span></span>

- <span data-ttu-id="a312f-131">[Constructores estáticos](../programming-guide/classes-and-structs/static-constructors.md), que inicializan los datos estáticos de una clase.</span><span class="sxs-lookup"><span data-stu-id="a312f-131">[Static constructors](../programming-guide/classes-and-structs/static-constructors.md), which initialize the static data of a class.</span></span>

- <span data-ttu-id="a312f-132">[Constructores de instancias](../programming-guide/classes-and-structs/constructors.md), a los que se llama para crear una nueva instancia de la clase.</span><span class="sxs-lookup"><span data-stu-id="a312f-132">[Instance constructors](../programming-guide/classes-and-structs/constructors.md), which you call to create a new instance of the class.</span></span> <span data-ttu-id="a312f-133">Cada clase debe definir sus propios constructores.</span><span class="sxs-lookup"><span data-stu-id="a312f-133">Each class must define its own constructors.</span></span>

- <span data-ttu-id="a312f-134">[Finalizadores](../programming-guide/classes-and-structs/destructors.md), llamados por el recolector de elementos no utilizados en tiempo de ejecución para destruir instancias de una clase.</span><span class="sxs-lookup"><span data-stu-id="a312f-134">[Finalizers](../programming-guide/classes-and-structs/destructors.md), which are called by the runtime's garbage collector to destroy instances of a class.</span></span>

<span data-ttu-id="a312f-135">Si bien las clases derivadas heredan todos los demás miembros de una clase base, que dichos miembros estén o no visibles depende de su accesibilidad.</span><span class="sxs-lookup"><span data-stu-id="a312f-135">While all other members of a base class are inherited by derived classes, whether they are visible or not depends on their accessibility.</span></span> <span data-ttu-id="a312f-136">La accesibilidad del miembro afecta a su visibilidad en las clases derivadas del modo siguiente:</span><span class="sxs-lookup"><span data-stu-id="a312f-136">A member's accessibility affects its visibility for derived classes as follows:</span></span>

- <span data-ttu-id="a312f-137">Los miembros [privados](../language-reference/keywords/private.md) solo son visible en las clases derivadas que están anidadas en su clase base.</span><span class="sxs-lookup"><span data-stu-id="a312f-137">[Private](../language-reference/keywords/private.md) members are visible only in derived classes that are nested in their base class.</span></span> <span data-ttu-id="a312f-138">De lo contrario, no son visibles en las clases derivadas.</span><span class="sxs-lookup"><span data-stu-id="a312f-138">Otherwise, they are not visible in derived classes.</span></span> <span data-ttu-id="a312f-139">En el ejemplo siguiente, `A.B` es una clase anidada que se deriva de `A`, y `C` se deriva de `A`.</span><span class="sxs-lookup"><span data-stu-id="a312f-139">In the following example, `A.B` is a nested class that derives from `A`, and `C` derives from `A`.</span></span> <span data-ttu-id="a312f-140">El campo `A.value` privado es visible en A.B.</span><span class="sxs-lookup"><span data-stu-id="a312f-140">The private `A.value` field is visible in A.B.</span></span> <span data-ttu-id="a312f-141">Sin embargo, si quita los comentarios del método `C.GetValue` e intenta compilar el ejemplo, se produce el error del compilador CS0122: ""A.value" no es accesible debido a su nivel de protección".</span><span class="sxs-lookup"><span data-stu-id="a312f-141">However, if you remove the comments from the `C.GetValue` method and attempt to compile the example, it produces compiler error CS0122: "'A.value' is inaccessible due to its protection level."</span></span>

  [!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/private.cs#1)]

- <span data-ttu-id="a312f-142">Los miembros [protegidos](../language-reference/keywords/protected.md) solo son visibles en las clases derivadas.</span><span class="sxs-lookup"><span data-stu-id="a312f-142">[Protected](../language-reference/keywords/protected.md) members are visible only in derived classes.</span></span>

- <span data-ttu-id="a312f-143">Los miembros [internos](../language-reference/keywords/internal.md) solo son visibles en las clases derivadas que se encuentran en el mismo ensamblado que la clase base.</span><span class="sxs-lookup"><span data-stu-id="a312f-143">[Internal](../language-reference/keywords/internal.md) members are visible only in derived classes that are located in the same assembly as the base class.</span></span> <span data-ttu-id="a312f-144">No son visibles en las clases derivadas ubicadas en un ensamblado diferente al de la clase base.</span><span class="sxs-lookup"><span data-stu-id="a312f-144">They are not visible in derived classes located in a different assembly from the base class.</span></span>

- <span data-ttu-id="a312f-145">Los miembros [públicos](../language-reference/keywords/public.md) son visibles en las clases derivadas y forman parte de la interfaz pública de dichas clases.</span><span class="sxs-lookup"><span data-stu-id="a312f-145">[Public](../language-reference/keywords/public.md) members are visible in derived classes and are part of the derived class' public interface.</span></span> <span data-ttu-id="a312f-146">Los miembros públicos heredados se pueden llamar como si se hubieran definido en la clase derivada.</span><span class="sxs-lookup"><span data-stu-id="a312f-146">Public inherited members can be called just as if they were defined in the derived class.</span></span> <span data-ttu-id="a312f-147">En el ejemplo siguiente, la clase `A` define un método denominado `Method1` y la clase `B` hereda de la clase `A`.</span><span class="sxs-lookup"><span data-stu-id="a312f-147">In the following example, class `A` defines a method named `Method1`, and class `B` inherits from class `A`.</span></span> <span data-ttu-id="a312f-148">El ejemplo llama a `Method1` como si fuera un método de instancia en `B`.</span><span class="sxs-lookup"><span data-stu-id="a312f-148">The example then calls `Method1` as if it were an instance method on `B`.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/basics.cs#1)]

<span data-ttu-id="a312f-149">Las clases derivadas pueden también *invalidar* los miembros heredados al proporcionar una implementación alternativa.</span><span class="sxs-lookup"><span data-stu-id="a312f-149">Derived classes can also *override* inherited members by providing an alternate implementation.</span></span> <span data-ttu-id="a312f-150">Para poder invalidar un miembro, el miembro de la clase base debe marcarse con la palabra clave [virtual](../language-reference/keywords/virtual.md).</span><span class="sxs-lookup"><span data-stu-id="a312f-150">In order to be able to override a member, the member in the base class must be marked with the [virtual](../language-reference/keywords/virtual.md) keyword.</span></span> <span data-ttu-id="a312f-151">De forma predeterminada, los miembros de clase base no están marcados con `virtual` y no se pueden invalidar.</span><span class="sxs-lookup"><span data-stu-id="a312f-151">By default, base class members are not marked as `virtual` and cannot be overridden.</span></span> <span data-ttu-id="a312f-152">Al intentar invalidar un miembro no virtual, como en el ejemplo siguiente, se genera el error de compilador CS0506: "<member> no se puede invalidar el miembro heredado <member> porque no está marcado como virtual, abstract ni override.</span><span class="sxs-lookup"><span data-stu-id="a312f-152">Attempting to override a non-virtual member, as the following example does, generates compiler error CS0506: "<member> cannot override inherited member <member> because it is not marked virtual, abstract, or override.</span></span>

```csharp
public class A
{
    public void Method1()
    {
        // Do something.
    }
}

public class B : A
{
    public override void Method1() // Generates CS0506.
    {
        // Do something else.
    }
}
```

<span data-ttu-id="a312f-153">En algunos casos, una clase derivada *debe* invalidar la implementación de la clase base.</span><span class="sxs-lookup"><span data-stu-id="a312f-153">In some cases, a derived class *must* override the base class implementation.</span></span> <span data-ttu-id="a312f-154">Los miembros de clase base marcados con la palabra clave [abstract](../language-reference/keywords/abstract.md) requieren que las clases derivadas los invaliden.</span><span class="sxs-lookup"><span data-stu-id="a312f-154">Base class members marked with the [abstract](../language-reference/keywords/abstract.md) keyword require that derived classes override them.</span></span> <span data-ttu-id="a312f-155">Al intentar compilar el ejemplo siguiente, se genera el error de compilador CS0534, "<class> no implementa el miembro abstracto heredado <member>", porque la clase `B` no proporciona ninguna implementación para `A.Method1`.</span><span class="sxs-lookup"><span data-stu-id="a312f-155">Attempting to compile the following example generates compiler error CS0534, "<class> does not implement inherited abstract member <member>', because class `B` provides no implementation for `A.Method1`.</span></span>

```csharp
public abstract class A
{
    public abstract void Method1();
}

public class B : A // Generates CS0534.
{
    public void Method3()
    {
        // Do something.
    }
}
```

<span data-ttu-id="a312f-156">La herencia solo se aplica a clases e interfaces.</span><span class="sxs-lookup"><span data-stu-id="a312f-156">Inheritance applies only to classes and interfaces.</span></span> <span data-ttu-id="a312f-157">Other type categories (structs, delegates, and enums) do not support inheritance.</span><span class="sxs-lookup"><span data-stu-id="a312f-157">Other type categories (structs, delegates, and enums) do not support inheritance.</span></span> <span data-ttu-id="a312f-158">Por este motivo, al intentar compilar código como el siguiente se genera el error de compilador CS0527: "El tipo "ValueType" de la lista de interfaces no es una interfaz".</span><span class="sxs-lookup"><span data-stu-id="a312f-158">Because of this, attempting to compile code like the following produces compiler error CS0527: "Type 'ValueType' in interface list is not an interface."</span></span> <span data-ttu-id="a312f-159">El mensaje de error indica que, aunque se pueden definir las interfaces que implementa un struct, no se admite la herencia.</span><span class="sxs-lookup"><span data-stu-id="a312f-159">The error message indicates that, although you can define the interfaces that a struct implements, inheritance is not supported.</span></span>

```csharp
using System;

public struct ValueStructure : ValueType // Generates CS0527.
{
}
```

## <a name="implicit-inheritance"></a><span data-ttu-id="a312f-160">Herencia implícita</span><span class="sxs-lookup"><span data-stu-id="a312f-160">Implicit inheritance</span></span>

<span data-ttu-id="a312f-161">Aparte de los tipos de los que puedan heredar mediante herencia única, todos los tipos del sistema de tipos .NET heredan implícitamente de <xref:System.Object> o de un tipo derivado de este.</span><span class="sxs-lookup"><span data-stu-id="a312f-161">Besides any types that they may inherit from through single inheritance, all types in the .NET type system implicitly inherit from <xref:System.Object> or a type derived from it.</span></span> <span data-ttu-id="a312f-162">Esto garantiza que la funcionalidad común está disponible para cualquier tipo.</span><span class="sxs-lookup"><span data-stu-id="a312f-162">This ensures that common functionality is available to any type.</span></span>

<span data-ttu-id="a312f-163">Para ver lo que significa la herencia implícita, vamos a definir una nueva clase, `SimpleClass`, que es simplemente una definición de clase vacía:</span><span class="sxs-lookup"><span data-stu-id="a312f-163">To see what implicit inheritance means, let's define a new class, `SimpleClass`, that is simply an empty class definition:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#1)]

<span data-ttu-id="a312f-164">A continuación, podemos usar reflexión (que nos permite inspeccionar los metadatos de un tipo para obtener información sobre ese tipo) para obtener una lista de los miembros que pertenecen al tipo `SimpleClass`.</span><span class="sxs-lookup"><span data-stu-id="a312f-164">We can then use reflection (which lets us inspect a type's metadata to get information about that type) to get a list of the members that belong to the `SimpleClass` type.</span></span> <span data-ttu-id="a312f-165">Aunque no hemos definido ningún miembro en nuestra clase `SimpleClass`, la salida del ejemplo indica que en realidad tiene nueve miembros.</span><span class="sxs-lookup"><span data-stu-id="a312f-165">Although we haven't defined any members in our `SimpleClass` class, output from the example indicates that it actually has nine members.</span></span> <span data-ttu-id="a312f-166">Uno de ellos es un constructor sin parámetros (o predeterminado) que el compilador de C# proporciona automáticamente para el tipo `SimpleClass`.</span><span class="sxs-lookup"><span data-stu-id="a312f-166">One of these is a parameterless (or default) constructor that is automatically supplied for the `SimpleClass` type by the C# compiler.</span></span> <span data-ttu-id="a312f-167">Los ocho restantes son miembros de <xref:System.Object>, el tipo del que heredan implícitamente a la larga todas las clases e interfaces del sistema de tipo .NET.</span><span class="sxs-lookup"><span data-stu-id="a312f-167">The remaining eight are members of <xref:System.Object>, the type from which all classes and interfaces in the .NET type system ultimately implicitly inherit.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#2)]

<span data-ttu-id="a312f-168">La herencia implícita desde la clase <xref:System.Object> permite que estos métodos estén disponibles para la clase `SimpleClass`:</span><span class="sxs-lookup"><span data-stu-id="a312f-168">Implicit inheritance from the <xref:System.Object> class makes these methods available to the `SimpleClass` class:</span></span>

- <span data-ttu-id="a312f-169">El método público `ToString`, que convierte un objeto `SimpleClass` en su representación de cadena, devuelve el nombre de tipo completo.</span><span class="sxs-lookup"><span data-stu-id="a312f-169">The public `ToString` method, which converts a `SimpleClass` object to its string representation, returns the fully qualified type name.</span></span> <span data-ttu-id="a312f-170">En este caso, el método `ToString` devuelve la cadena "SimpleClass".</span><span class="sxs-lookup"><span data-stu-id="a312f-170">In this case, the `ToString` method returns the string "SimpleClass".</span></span>

- <span data-ttu-id="a312f-171">Tres métodos de prueba de igualdad de dos objetos: el método de instancia pública `Equals(Object)`, el método público estático `Equals(Object, Object)` y el método público estático `ReferenceEquals(Object, Object)`.</span><span class="sxs-lookup"><span data-stu-id="a312f-171">Three methods that test for equality of two objects: the public instance `Equals(Object)` method, the public static `Equals(Object, Object)` method, and the public static `ReferenceEquals(Object, Object)` method.</span></span> <span data-ttu-id="a312f-172">De forma predeterminada, estos métodos prueban la igualdad de referencia; es decir, para que sean iguales, dos variables de objeto deben hacer referencia al mismo objeto.</span><span class="sxs-lookup"><span data-stu-id="a312f-172">By default, these methods test for reference equality; that is, to be equal, two object variables must refer to the same object.</span></span>

- <span data-ttu-id="a312f-173">El método público `GetHashCode`, que calcula un valor que permite que una instancia del tipo se use en colecciones con hash.</span><span class="sxs-lookup"><span data-stu-id="a312f-173">The public `GetHashCode` method, which computes a value that allows an instance of the type to be used in hashed collections.</span></span>

- <span data-ttu-id="a312f-174">El método público `GetType`, que devuelve un objeto <xref:System.Type> que representa el tipo `SimpleClass`.</span><span class="sxs-lookup"><span data-stu-id="a312f-174">The public `GetType` method, which returns a <xref:System.Type> object that represents the `SimpleClass` type.</span></span>

- <span data-ttu-id="a312f-175">El método protegido <xref:System.Object.Finalize%2A>, que está diseñado para liberar recursos no administrados antes de que el recolector de elementos no utilizados reclame la memoria de un objeto.</span><span class="sxs-lookup"><span data-stu-id="a312f-175">The protected <xref:System.Object.Finalize%2A> method, which is designed to release unmanaged resources before an object's memory is reclaimed by the garbage collector.</span></span>

- <span data-ttu-id="a312f-176">El método protegido <xref:System.Object.MemberwiseClone%2A>, que crea un clon superficial del objeto actual.</span><span class="sxs-lookup"><span data-stu-id="a312f-176">The protected <xref:System.Object.MemberwiseClone%2A> method, which creates a shallow clone of the current object.</span></span>

<span data-ttu-id="a312f-177">Debido a la herencia implícita, podemos llamar a cualquier miembro heredado de un objeto `SimpleClass` como si fuera realmente un miembro definido en la clase `SimpleClass`.</span><span class="sxs-lookup"><span data-stu-id="a312f-177">Because of implicit inheritance, we can call any inherited member from a `SimpleClass` object just as if it was actually a member defined in the `SimpleClass` class.</span></span> <span data-ttu-id="a312f-178">Así, en el ejemplo siguiente se llama al método `SimpleClass.ToString`, que `SimpleClass` hereda de <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="a312f-178">For instance, the following example calls the `SimpleClass.ToString` method, which `SimpleClass` inherits from <xref:System.Object>.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass2.cs#1)]

<span data-ttu-id="a312f-179">En la tabla siguiente se enumeran las categorías de tipos que se pueden crear en C# y los tipos de los que heredan implícitamente.</span><span class="sxs-lookup"><span data-stu-id="a312f-179">The following table lists the categories of types that you can create in C# and the types from which they implicitly inherit.</span></span> <span data-ttu-id="a312f-180">Cada tipo base constituye un conjunto diferente de miembros disponible mediante herencia para los tipos derivados de forma implícita.</span><span class="sxs-lookup"><span data-stu-id="a312f-180">Each base type makes a different set of members available through inheritance to implicitly derived types.</span></span>

| <span data-ttu-id="a312f-181">Categoría de tipo</span><span class="sxs-lookup"><span data-stu-id="a312f-181">Type category</span></span> | <span data-ttu-id="a312f-182">Hereda implícitamente de</span><span class="sxs-lookup"><span data-stu-id="a312f-182">Implicitly inherits from</span></span>                                                      |
| ------------- | ----------------------------------------------------------------------------- |
| <span data-ttu-id="a312f-183">clase</span><span class="sxs-lookup"><span data-stu-id="a312f-183">class</span></span>         | <xref:System.Object>                                                          |
| <span data-ttu-id="a312f-184">struct</span><span class="sxs-lookup"><span data-stu-id="a312f-184">struct</span></span>        | <span data-ttu-id="a312f-185"><xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="a312f-185"><xref:System.ValueType>, <xref:System.Object></span></span>                                 |
| <span data-ttu-id="a312f-186">enum</span><span class="sxs-lookup"><span data-stu-id="a312f-186">enum</span></span>          | <span data-ttu-id="a312f-187"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="a312f-187"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span></span>             |
| <span data-ttu-id="a312f-188">delegado</span><span class="sxs-lookup"><span data-stu-id="a312f-188">delegate</span></span>      | <span data-ttu-id="a312f-189"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="a312f-189"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span></span> |

## <a name="inheritance-and-an-is-a-relationship"></a><span data-ttu-id="a312f-190">Herencia y una relación "is a"</span><span class="sxs-lookup"><span data-stu-id="a312f-190">Inheritance and an "is a" relationship</span></span>

<span data-ttu-id="a312f-191">Normalmente, la herencia se usa para expresar una relación "is a" entre una clase base y una o varias clases derivadas, donde las clases derivadas son versiones especializadas de la clase base; la clase derivada es un tipo de la clase base.</span><span class="sxs-lookup"><span data-stu-id="a312f-191">Ordinarily, inheritance is used to express an "is a" relationship between a base class and one or more derived classes, where the derived classes are specialized versions of the base class; the derived class is a type of the base class.</span></span> <span data-ttu-id="a312f-192">Por ejemplo, la clase `Publication` representa una publicación de cualquier tipo y las clases `Book` y `Magazine` representan tipos específicos de publicaciones.</span><span class="sxs-lookup"><span data-stu-id="a312f-192">For example, the `Publication` class represents a publication of any kind, and the `Book` and `Magazine` classes represent specific types of publications.</span></span>

> [!NOTE]
> <span data-ttu-id="a312f-193">Una clase o struct puede implementar una o varias interfaces.</span><span class="sxs-lookup"><span data-stu-id="a312f-193">A class or struct can implement one more interfaces.</span></span> <span data-ttu-id="a312f-194">Aunque a menudo la implementación se presenta como una solución alternativa para la herencia única o como una forma de usar la herencia con structs, su finalidad es expresar una relación diferente (una relación "can do") entre una interfaz y su tipo de implementación que la herencia.</span><span class="sxs-lookup"><span data-stu-id="a312f-194">While interface implementation is often presented as a workaround for single inheritance or as a way of using inheritance with structs, it is intended to express a different relationship (a "can do" relationship) between an interface and its implementing type than inheritance.</span></span> <span data-ttu-id="a312f-195">Una interfaz define un subconjunto de funcionalidad (por ejemplo, la posibilidad de probar la igualdad, comparar u ordenar objetos o de admitir análisis y formato con referencia cultural) que la interfaz pone a disposición de sus tipos de implementación.</span><span class="sxs-lookup"><span data-stu-id="a312f-195">An interface defines a subset of functionality (such as the ability to test for equality, to compare or sort objects, or to support culture-sensitive parsing and formatting) that the interface makes available to its implementing types.</span></span>

<span data-ttu-id="a312f-196">Tenga en cuenta que "is a" también expresa la relación entre un tipo y una instancia específica de ese tipo.</span><span class="sxs-lookup"><span data-stu-id="a312f-196">Note that "is a" also expresses the relationship between a type and a specific instantiation of that type.</span></span> <span data-ttu-id="a312f-197">En el ejemplo siguiente, `Automobile` es una clase que tiene tres propiedades de solo lectura exclusivas: `Make`, el fabricante del automóvil; `Model`, el tipo de automóvil; y `Year`, el año de fabricación.</span><span class="sxs-lookup"><span data-stu-id="a312f-197">In the following example, `Automobile` is a class that has three unique read-only properties: `Make`, the manufacturer of the automobile; `Model`, the kind of automobile; and `Year`, its year of manufacture.</span></span> <span data-ttu-id="a312f-198">Nuestra clase `Automobile` también tiene un constructor cuyos argumentos se asignan a los valores de propiedad, y reemplaza al método <xref:System.Object.ToString%2A?displayProperty=nameWithType> para producir una cadena que identifica de forma única la instancia `Automobile` en lugar de la clase `Automobile`.</span><span class="sxs-lookup"><span data-stu-id="a312f-198">Our `Automobile` class also has a constructor whose arguments are assigned to the property values, and it overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to produce a string that uniquely identifies the `Automobile` instance rather than the `Automobile` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#1)]

<span data-ttu-id="a312f-199">En este caso, no debemos confiar en la herencia para representar marcas y modelos de coches específicos.</span><span class="sxs-lookup"><span data-stu-id="a312f-199">In this case, we should not rely on inheritance to represent specific car makes and models.</span></span> <span data-ttu-id="a312f-200">Por ejemplo, no es necesario definir un tipo `Packard` para representar los automóviles fabricados por la empresa de automóviles Packard Motor.</span><span class="sxs-lookup"><span data-stu-id="a312f-200">For example, we do not need to define a `Packard` type to represent automobiles manufactured by the Packard Motor Car Company.</span></span> <span data-ttu-id="a312f-201">En su lugar, se pueden representar mediante la creación de un objeto `Automobile` con los valores adecuados que se pasan a su constructor de clase, como en el siguiente ejemplo.</span><span class="sxs-lookup"><span data-stu-id="a312f-201">Instead, we can represent them by creating an `Automobile` object with the appropriate values passed to its class constructor, as the following example does.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#2)]

<span data-ttu-id="a312f-202">Una relación "is a" basada en la herencia se aplica mejor a una clase base y a clases derivadas que agregan miembros adicionales a la clase base o que requieren funcionalidad adicional que no está presente en la clase base.</span><span class="sxs-lookup"><span data-stu-id="a312f-202">An is-a relationship based on inheritance is best applied to a base class and to derived classes that add additional members to the base class or that require additional functionality not present in the base class.</span></span>

## <a name="designing-the-base-class-and-derived-classes"></a><span data-ttu-id="a312f-203">Diseño de la clase base y las clases derivadas</span><span class="sxs-lookup"><span data-stu-id="a312f-203">Designing the base class and derived classes</span></span>

<span data-ttu-id="a312f-204">Veamos el proceso de diseño de una clase base y sus clases derivadas.</span><span class="sxs-lookup"><span data-stu-id="a312f-204">Let's look at the process of designing a base class and its derived classes.</span></span> <span data-ttu-id="a312f-205">En esta sección, se definirá una clase base, `Publication`, que representa una publicación de cualquier tipo, como un libro, una revista, un periódico, un diario, un artículo, etc. También definiremos una clase `Book` que se deriva de `Publication`.</span><span class="sxs-lookup"><span data-stu-id="a312f-205">In this section, we'll define a base class, `Publication`, which represents a publication of any kind, such as a book, a magazine, a newspaper, a journal, an article, etc. We'll also define a `Book` class that derives from `Publication`.</span></span> <span data-ttu-id="a312f-206">Podríamos ampliar fácilmente el ejemplo para definir otras clases derivadas, como `Magazine`, `Journal`, `Newspaper` y `Article`.</span><span class="sxs-lookup"><span data-stu-id="a312f-206">We could easily extend the example to define other derived classes, such as `Magazine`, `Journal`, `Newspaper`, and `Article`.</span></span>

### <a name="the-base-publication-class"></a><span data-ttu-id="a312f-207">Clase base Publication</span><span class="sxs-lookup"><span data-stu-id="a312f-207">The base Publication class</span></span>

<span data-ttu-id="a312f-208">A la hora de diseñar nuestra clase `Publication`, debemos tomar varias decisiones en cuanto al diseño:</span><span class="sxs-lookup"><span data-stu-id="a312f-208">In designing our `Publication` class, we need to make several design decisions:</span></span>

- <span data-ttu-id="a312f-209">Qué miembros se incluirán en nuestra clase base `Publication` y si los miembros de `Publication` proporcionarán implementaciones de método, o si `Publication` es una clase base abstracta que funciona como plantilla para sus clases derivadas.</span><span class="sxs-lookup"><span data-stu-id="a312f-209">What members to include in our base `Publication` class, and whether the `Publication` members provide method implementations, or whether `Publication` is an abstract base class that serves as a template for its derived classes.</span></span>

  <span data-ttu-id="a312f-210">En este caso, la clase `Publication` proporcionará implementaciones de método.</span><span class="sxs-lookup"><span data-stu-id="a312f-210">In this case, the `Publication` class will provide method implementations.</span></span> <span data-ttu-id="a312f-211">La sección [Diseño de clases base abstractas y sus clases derivadas](#abstract) contiene un ejemplo en el que se usa una clase base abstracta para definir los métodos que deben invalidar las clases derivadas.</span><span class="sxs-lookup"><span data-stu-id="a312f-211">The [Designing abstract base classes and their derived classes](#abstract) section contains an example that uses an abstract base class to define the methods that derived classes must override.</span></span> <span data-ttu-id="a312f-212">Las clases derivadas pueden proporcionar cualquier implementación que sea adecuada para el tipo derivado.</span><span class="sxs-lookup"><span data-stu-id="a312f-212">Derived classes are free to provide any implementation that is suitable for the derived type.</span></span>

  <span data-ttu-id="a312f-213">La posibilidad de reutilizar el código (es decir, varias clases derivadas comparten la declaración y la implementación de los métodos de clase base y no tienen que invalidarlos) es una ventaja de las clases base no abstractas.</span><span class="sxs-lookup"><span data-stu-id="a312f-213">The ability to reuse code (that is, multiple derived classes share the declaration and implementation of base class methods and do not need to override them) is an advantage of non-abstract base classes.</span></span> <span data-ttu-id="a312f-214">Por lo tanto, debemos agregar miembros a `Publication` si es probable que algunos o la mayoría de tipos `Publication` especializados compartan su código.</span><span class="sxs-lookup"><span data-stu-id="a312f-214">Therefore, we should add members to `Publication` if their code is likely to be shared by some or most specialized `Publication` types.</span></span> <span data-ttu-id="a312f-215">Si no lo hacemos bien, acabaremos por tener que proporcionar implementaciones de miembros prácticamente idénticas en las clases derivadas en lugar de una única implementación en la clase base.</span><span class="sxs-lookup"><span data-stu-id="a312f-215">If we fail to do this efficiently, we'll end up having to provide largely identical member implementations in derived classes rather a single implementation in the base class.</span></span> <span data-ttu-id="a312f-216">La necesidad de mantener código duplicado en varias ubicaciones es un origen potencial de errores.</span><span class="sxs-lookup"><span data-stu-id="a312f-216">The need to maintain duplicated code in multiple locations is a potential source of bugs.</span></span>

  <span data-ttu-id="a312f-217">Tanto para maximizar la reutilización del código como para crear una jerarquía de herencia lógica e intuitiva, queremos estar seguros de incluir en la clase `Publication` solo los datos y la funcionalidad común a todos o a la mayoría de las publicaciones.</span><span class="sxs-lookup"><span data-stu-id="a312f-217">Both to maximize code reuse and to create a logical and intuitive inheritance hierarchy, we want to be sure that we include in the `Publication` class only the data and functionality that is common to all or to most publications.</span></span> <span data-ttu-id="a312f-218">Así, las clases derivadas implementan miembros que son únicos para una clase determinada de publicación que representan.</span><span class="sxs-lookup"><span data-stu-id="a312f-218">Derived classes then implement members that are unique to the particular kinds of publication that they represent.</span></span>

- <span data-ttu-id="a312f-219">Hasta qué punto extender nuestra jerarquía de clases.</span><span class="sxs-lookup"><span data-stu-id="a312f-219">How far to extend our class hierarchy.</span></span> <span data-ttu-id="a312f-220">¿Desea desarrollar una jerarquía de tres o más clases, en lugar de simplemente una clase base y una o más clases derivadas?</span><span class="sxs-lookup"><span data-stu-id="a312f-220">Do we want to develop a hierarchy of three or more classes, rather than simply a base class and one or more derived classes?</span></span> <span data-ttu-id="a312f-221">Por ejemplo, `Publication` podría ser una clase base de `Periodical`, que, a su vez, es una clase base de `Magazine`, `Journal` y `Newspaper`.</span><span class="sxs-lookup"><span data-stu-id="a312f-221">For example, `Publication` could be a base class of `Periodical`, which in turn is a base class of `Magazine`, `Journal` and `Newspaper`.</span></span>

  <span data-ttu-id="a312f-222">En nuestro ejemplo, vamos a usar la jerarquía simple de una clase `Publication` y una sola clase derivada, `Book`.</span><span class="sxs-lookup"><span data-stu-id="a312f-222">For our example, we'll use the simple hierarchy of a `Publication` class and a single derived classes, `Book`.</span></span> <span data-ttu-id="a312f-223">Podríamos extender fácilmente el ejemplo para crear una serie de clases adicionales que se derivan de `Publication`, como `Magazine` y `Article`.</span><span class="sxs-lookup"><span data-stu-id="a312f-223">We could easily extend the example to create a number of additional   classes that derive from `Publication`, such as `Magazine` and `Article`.</span></span>

- <span data-ttu-id="a312f-224">Si tiene sentido crear instancias de la clase base.</span><span class="sxs-lookup"><span data-stu-id="a312f-224">Whether it makes sense to instantiate the base class.</span></span> <span data-ttu-id="a312f-225">Si no, debemos aplicar la palabra clave [abstract](../language-reference/keywords/abstract.md) a la clase.</span><span class="sxs-lookup"><span data-stu-id="a312f-225">If it does not, we should apply the [abstract](../language-reference/keywords/abstract.md) keyword to the class.</span></span> <span data-ttu-id="a312f-226">Si se intenta crear una instancia de una clase marcada con la palabra clave `abstract` mediante una llamada directa a su constructor de clase, el compilador de C# genera el error CS0144: "No se puede crear una instancia de la interfaz o clase abstracta".</span><span class="sxs-lookup"><span data-stu-id="a312f-226">If an attempt is made to instantiate a class marked with the `abstract` keyword by a direct call to its class constructor, the C# compiler generates error CS0144, "Cannot create an instance of the abstract class or interface."</span></span> <span data-ttu-id="a312f-227">Si se intenta crear una instancia de la clase mediante reflexión, el método de reflexión produce una excepción <xref:System.MemberAccessException>.</span><span class="sxs-lookup"><span data-stu-id="a312f-227">If an attempt is made to instantiate the class by using reflection, the reflection method throws a <xref:System.MemberAccessException>.</span></span> <span data-ttu-id="a312f-228">De lo contrario, se puede crear una instancia de nuestra clase `Publication` mediante una llamada a su constructor de clase.</span><span class="sxs-lookup"><span data-stu-id="a312f-228">Otherwise, our `Publication` class can be instantiated by calling its class constructor.</span></span>

  <span data-ttu-id="a312f-229">De forma predeterminada, se puede crear una instancia de una clase base mediante una llamada a su constructor de clase.</span><span class="sxs-lookup"><span data-stu-id="a312f-229">By default, a base class can be instantiated by calling its class constructor.</span></span> <span data-ttu-id="a312f-230">Tenga en cuenta que no tenemos que definir explícitamente un constructor de clase.</span><span class="sxs-lookup"><span data-stu-id="a312f-230">Note that we do not have to explicitly define a class constructor.</span></span> <span data-ttu-id="a312f-231">Si uno no está presente en el código fuente de la clase base, el compilador de C# proporciona automáticamente un constructor (sin parámetros) de forma predeterminada.</span><span class="sxs-lookup"><span data-stu-id="a312f-231">If one is not present in the base class' source code, the C# compiler automatically provides a default (parameterless) constructor.</span></span>

  <span data-ttu-id="a312f-232">En nuestro ejemplo, marcaremos la clase `Publication` como [abstract](../language-reference/keywords/abstract.md) para que no se pueden crear instancias.</span><span class="sxs-lookup"><span data-stu-id="a312f-232">For our example, we'll mark the `Publication` class as [abstract](../language-reference/keywords/abstract.md) so that it cannot be instantiated.</span></span>

- <span data-ttu-id="a312f-233">Si las clases derivadas deben heredar la implementación de la clase base de un determinado miembro o tienen la opción de invalidar la implementación de la clase base.</span><span class="sxs-lookup"><span data-stu-id="a312f-233">Whether derived classes must inherit the base class implementation of a particular members, or whether they have the option to override the base class implementation.</span></span> <span data-ttu-id="a312f-234">Debemos usar la palabra clave [virtual](../language-reference/keywords/virtual.md) para permitir que las clases derivadas invaliden un método de clase base.</span><span class="sxs-lookup"><span data-stu-id="a312f-234">We have to use the [virtual](../language-reference/keywords/virtual.md) keyword to allow derived classes to override a base class method.</span></span> <span data-ttu-id="a312f-235">De forma predeterminada, *no se pueden invalidar* los métodos definidos en la clase base.</span><span class="sxs-lookup"><span data-stu-id="a312f-235">By default, methods defined in the base class are *not* overridable.</span></span>

- <span data-ttu-id="a312f-236">Si una clase derivada representa la clase final en la jerarquía de herencia y no se puede usar ella misma como clase base para clases derivadas adicionales.</span><span class="sxs-lookup"><span data-stu-id="a312f-236">Whether a derived class represents the final class in the inheritance hierarchy and cannot itself be used as a base class for additional derived classes.</span></span> <span data-ttu-id="a312f-237">De forma predeterminada, cualquier clase puede servir como clase base.</span><span class="sxs-lookup"><span data-stu-id="a312f-237">By default, any class can serve as a base class.</span></span> <span data-ttu-id="a312f-238">Podemos aplicar la palabra clave [sealed](../language-reference/keywords/sealed.md) para indicar que una clase no puede servir como clase base para las clases adicionales.</span><span class="sxs-lookup"><span data-stu-id="a312f-238">We can apply the [sealed](../language-reference/keywords/sealed.md) keyword to indicate that a class cannot serve as a base class for any additional classes.</span></span> <span data-ttu-id="a312f-239">Al intentar derivar de una clase sealed se genera el error de compilador CS0509: "no puede derivar del tipo sealed <typeName>".</span><span class="sxs-lookup"><span data-stu-id="a312f-239">Attempting to derive from a sealed class generated compiler error CS0509, "cannot derive from sealed type <typeName>".</span></span>

  <span data-ttu-id="a312f-240">En nuestro ejemplo, marcaremos nuestra clase derivada como `sealed`.</span><span class="sxs-lookup"><span data-stu-id="a312f-240">For our example, we'll mark our derived class as `sealed`.</span></span>

<span data-ttu-id="a312f-241">En el ejemplo siguiente se muestra el código fuente para la clase `Publication`, así como una enumeración `PublicationType` que devuelve la propiedad `Publication.PublicationType`.</span><span class="sxs-lookup"><span data-stu-id="a312f-241">The following example shows the source code for the `Publication` class, as well as a `PublicationType` enumeration that is returned by the `Publication.PublicationType` property.</span></span> <span data-ttu-id="a312f-242">Además de los miembros que hereda de <xref:System.Object>, la clase `Publication` define los siguientes miembros únicos e invalidaciones de miembros:</span><span class="sxs-lookup"><span data-stu-id="a312f-242">In addition to the members that it inherits from <xref:System.Object>, the `Publication` class defines the following unique members and member overrides:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#1)]

- <span data-ttu-id="a312f-243">Un constructor</span><span class="sxs-lookup"><span data-stu-id="a312f-243">A constructor</span></span>

  <span data-ttu-id="a312f-244">Dado que la clase `Publication` es `abstract`, no se puede crear una instancia de ella directamente desde código similar al siguiente:</span><span class="sxs-lookup"><span data-stu-id="a312f-244">Because the `Publication` class is `abstract`, it cannot be instantiated directly from code like the following:</span></span>

  ```csharp
  var publication = new Publication("Tiddlywinks for Experts", "Fun and Games",
                                    PublicationType.Book);
  ```

  <span data-ttu-id="a312f-245">Sin embargo, su constructor de instancia se puede llamar directamente desde los constructores de clases derivadas, como muestra el código fuente de la clase `Book`.</span><span class="sxs-lookup"><span data-stu-id="a312f-245">However, its instance constructor can be called directly from derived class constructors, as the source code for the `Book` class shows.</span></span>

- <span data-ttu-id="a312f-246">Dos propiedades relacionadas con la publicación</span><span class="sxs-lookup"><span data-stu-id="a312f-246">Two publication-related properties</span></span>

  <span data-ttu-id="a312f-247">`Title` es una propiedad <xref:System.String> de solo lectura cuyo valor se suministra mediante la llamada al constructor `Publication`.</span><span class="sxs-lookup"><span data-stu-id="a312f-247">`Title` is a read-only <xref:System.String> property whose value is supplied by calling the `Publication` constructor.</span></span>

  <span data-ttu-id="a312f-248">`Pages` es una propiedad <xref:System.Int32> de solo lectura que indica cuántas páginas en total tiene la publicación.</span><span class="sxs-lookup"><span data-stu-id="a312f-248">`Pages` is a read-write <xref:System.Int32> property that indicates how many total pages the publication has.</span></span> <span data-ttu-id="a312f-249">El valor se almacena en un campo privado denominado `totalPages`.</span><span class="sxs-lookup"><span data-stu-id="a312f-249">The value is stored in a private field named `totalPages`.</span></span> <span data-ttu-id="a312f-250">Debe ser un número positivo o se inicia una excepción <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="a312f-250">It must be a positive number or an <xref:System.ArgumentOutOfRangeException> is thrown.</span></span>

- <span data-ttu-id="a312f-251">Miembros relacionados con el publicador</span><span class="sxs-lookup"><span data-stu-id="a312f-251">Publisher-related members</span></span>

  <span data-ttu-id="a312f-252">Dos propiedades de solo lectura, `Publisher` y `Type`.</span><span class="sxs-lookup"><span data-stu-id="a312f-252">Two read-only properties, `Publisher` and `Type`.</span></span> <span data-ttu-id="a312f-253">Los valores se proporcionan originalmente mediante la llamada al constructor de clase `Publication`.</span><span class="sxs-lookup"><span data-stu-id="a312f-253">The values are originally supplied by the call to the `Publication` class constructor.</span></span>

- <span data-ttu-id="a312f-254">Miembros relacionados con la publicación</span><span class="sxs-lookup"><span data-stu-id="a312f-254">Publishing-related members</span></span>

  <span data-ttu-id="a312f-255">Dos métodos, `Publish` y `GetPublicationDate`, establecen y devuelven la fecha de publicación.</span><span class="sxs-lookup"><span data-stu-id="a312f-255">Two methods, `Publish` and `GetPublicationDate`, set and return the publication date.</span></span> <span data-ttu-id="a312f-256">El método `Publish` establece una marca `published` privada en `true` cuando se llama y asigna la fecha pasada a él como argumento al campo `datePublished` privado.</span><span class="sxs-lookup"><span data-stu-id="a312f-256">The `Publish` method sets a private  `published` flag to `true` when it is called and assigns the date passed to it as an argument to the private `datePublished` field.</span></span> <span data-ttu-id="a312f-257">El método `GetPublicationDate` devuelve la cadena "NYP" si la marca `published` es `false`, y el valor del campo `datePublished` si es `true`.</span><span class="sxs-lookup"><span data-stu-id="a312f-257">The `GetPublicationDate` method returns the string "NYP" if the `published` flag is `false`, and the value of the `datePublished` field if it is `true`.</span></span>

- <span data-ttu-id="a312f-258">Miembros relacionados con copyright</span><span class="sxs-lookup"><span data-stu-id="a312f-258">Copyright-related members</span></span>

  <span data-ttu-id="a312f-259">El método `Copyright` toma como argumentos el nombre del propietario del copyright y el año del copyright, y los asigna a las propiedades `CopyrightName` y `CopyrightDate`.</span><span class="sxs-lookup"><span data-stu-id="a312f-259">The `Copyright` method takes the name of the copyright holder and the year of the copyright as arguments and assigns them to the `CopyrightName` and `CopyrightDate` properties.</span></span>

- <span data-ttu-id="a312f-260">Una invalidación del método `ToString`</span><span class="sxs-lookup"><span data-stu-id="a312f-260">An override of the `ToString` method</span></span>

  <span data-ttu-id="a312f-261">Si un tipo no invalida al método <xref:System.Object.ToString%2A?displayProperty=nameWithType>, devuelve el nombre completo del tipo, que es de poca utilidad a la hora de diferenciar una instancia de otra.</span><span class="sxs-lookup"><span data-stu-id="a312f-261">If a type does not override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, it returns the fully qualified name of the type, which is of little use in differentiating one instance from another.</span></span> <span data-ttu-id="a312f-262">La clase `Publication` invalida <xref:System.Object.ToString%2A?displayProperty=nameWithType> para devolver el valor de la propiedad `Title`.</span><span class="sxs-lookup"><span data-stu-id="a312f-262">The `Publication` class overrides <xref:System.Object.ToString%2A?displayProperty=nameWithType> to return the value of the `Title` property.</span></span>

<span data-ttu-id="a312f-263">En la siguiente ilustración se muestra la relación entre nuestra clase base `Publication` y su clase heredada implícitamente <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="a312f-263">The following figure illustrates the relationship between our base `Publication` class and its implicitly inherited <xref:System.Object> class.</span></span>

![Las clases de objeto y publicación](media/publication-class.jpg)

### <a name="the-book-class"></a><span data-ttu-id="a312f-265">La clase `Book`.</span><span class="sxs-lookup"><span data-stu-id="a312f-265">The `Book` class</span></span>

<span data-ttu-id="a312f-266">La clase `Book` representa un libro como un tipo especializado de publicación.</span><span class="sxs-lookup"><span data-stu-id="a312f-266">The `Book` class represents a book as a specialized type of publication.</span></span> <span data-ttu-id="a312f-267">En el ejemplo siguiente se muestra el código fuente de la clase `Book`.</span><span class="sxs-lookup"><span data-stu-id="a312f-267">The following example shows the source code for the `Book` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#2)]

<span data-ttu-id="a312f-268">Además de los miembros que hereda de `Publication`, la clase `Book` define los siguientes miembros únicos e invalidaciones de miembros:</span><span class="sxs-lookup"><span data-stu-id="a312f-268">In addition to the members that it inherits from `Publication`, the `Book` class defines the following unique members and member overrides:</span></span>

- <span data-ttu-id="a312f-269">Dos constructores</span><span class="sxs-lookup"><span data-stu-id="a312f-269">Two constructors</span></span>

  <span data-ttu-id="a312f-270">Los dos constructores `Book` comparten tres parámetros comunes.</span><span class="sxs-lookup"><span data-stu-id="a312f-270">The two `Book` constructors share three common parameters.</span></span> <span data-ttu-id="a312f-271">Dos, *title* y *publisher*, corresponden a los parámetros del constructor `Publication`.</span><span class="sxs-lookup"><span data-stu-id="a312f-271">Two, *title* and *publisher*, correspond to parameters of the `Publication` constructor.</span></span> <span data-ttu-id="a312f-272">El tercero, *author*, se almacena en un campo privado `authorName`.</span><span class="sxs-lookup"><span data-stu-id="a312f-272">The third is *author*, which is stored to a private `authorName` field.</span></span> <span data-ttu-id="a312f-273">Un constructor incluye un parámetro *isbn*, que se almacena en la propiedad automática `ISBN`.</span><span class="sxs-lookup"><span data-stu-id="a312f-273">One constructor includes an *isbn* parameter, which is stored in the `ISBN` auto-property.</span></span>

  <span data-ttu-id="a312f-274">El primer constructor usa [esta](../language-reference/keywords/this.md) palabra clave para llamar al otro constructor.</span><span class="sxs-lookup"><span data-stu-id="a312f-274">The first constructor uses the [this](../language-reference/keywords/this.md) keyword to call the other constructor.</span></span> <span data-ttu-id="a312f-275">Se trata de un patrón común en la definición de constructores.</span><span class="sxs-lookup"><span data-stu-id="a312f-275">This is a common pattern in defining constructors.</span></span> <span data-ttu-id="a312f-276">Los constructores con menos parámetros proporcionan valores predeterminados al llamar al constructor con el mayor número de parámetros.</span><span class="sxs-lookup"><span data-stu-id="a312f-276">Constructors with fewer parameters provide default values when calling the constructor with the greatest number of parameters.</span></span>

  <span data-ttu-id="a312f-277">El segundo constructor usa la palabra clave [base](../language-reference/keywords/base.md) para pasar el título y el nombre del editor al constructor de clase base.</span><span class="sxs-lookup"><span data-stu-id="a312f-277">The second constructor uses the [base](../language-reference/keywords/base.md) keyword to pass the title and publisher name to the base class constructor.</span></span> <span data-ttu-id="a312f-278">Si no realiza una llamada explícita a un constructor de clase base en el código fuente, el compilador de C# proporciona automáticamente una llamada al constructor sin parámetros o predeterminado de la clase base.</span><span class="sxs-lookup"><span data-stu-id="a312f-278">If you don't make an explicit call to a base class constructor in your source code, the C# compiler automatically supplies a call to the base class' default or parameterless constructor.</span></span>

- <span data-ttu-id="a312f-279">Una propiedad `ISBN` de solo lectura, que devuelve el ISBN (International Standard Book Number) del objeto `Book`, un número exclusivo de 10 y 13 caracteres.</span><span class="sxs-lookup"><span data-stu-id="a312f-279">A read-only `ISBN` property, which returns the `Book` object's International Standard Book Number, a unique 10- or 13-digit number.</span></span> <span data-ttu-id="a312f-280">El ISBN se proporciona como argumento para uno de los constructores `Book`.</span><span class="sxs-lookup"><span data-stu-id="a312f-280">The ISBN is supplied as an argument to one of the `Book` constructors.</span></span> <span data-ttu-id="a312f-281">El ISBN se almacena en un campo de respaldo privado, generado automáticamente por el compilador.</span><span class="sxs-lookup"><span data-stu-id="a312f-281">The ISBN is stored in a private backing field, which is auto-generated by the compiler.</span></span>

- <span data-ttu-id="a312f-282">Una propiedad `Author` de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="a312f-282">A read-only `Author` property.</span></span> <span data-ttu-id="a312f-283">El nombre del autor se proporciona como argumento para ambos constructores `Book` y se almacena en el campo privado `authorName`.</span><span class="sxs-lookup"><span data-stu-id="a312f-283">The author name is supplied as an argument to both `Book` constructors and is stored in the private `authorName` field.</span></span>

- <span data-ttu-id="a312f-284">Dos propiedades relacionadas con el precio de solo lectura, `Price` y `Currency`.</span><span class="sxs-lookup"><span data-stu-id="a312f-284">Two read-only price-related properties, `Price` and `Currency`.</span></span> <span data-ttu-id="a312f-285">Sus valores se proporcionan como argumentos en una llamada al método `SetPrice`.</span><span class="sxs-lookup"><span data-stu-id="a312f-285">Their values are provided as arguments in a `SetPrice` method call.</span></span> <span data-ttu-id="a312f-286">El precio se almacena en un campo privado, `bookPrice`.</span><span class="sxs-lookup"><span data-stu-id="a312f-286">The price is stored in a private field, `bookPrice`.</span></span> <span data-ttu-id="a312f-287">La propiedad `Currency` es el símbolo de moneda ISO de tres dígitos (por ejemplo, USD para el dólar estadounidense) y se almacena en el campo privado `ISOCurrencySymbol`.</span><span class="sxs-lookup"><span data-stu-id="a312f-287">The `Currency` property is the three-digit ISO currency symbol (for example, USD for the U.S. dollar) and is stored in the private `ISOCurrencySymbol` field.</span></span> <span data-ttu-id="a312f-288">Los símbolos de moneda ISO se pueden recuperar de la propiedad <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A>.</span><span class="sxs-lookup"><span data-stu-id="a312f-288">ISO currency symbols can be retrieved from the <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> property.</span></span>

- <span data-ttu-id="a312f-289">Un método `SetPrice`, que establece los valores de los campos `bookPrice` y `ISOCurrencySymbol`.</span><span class="sxs-lookup"><span data-stu-id="a312f-289">A `SetPrice` method, which sets the values of the `bookPrice` and `ISOCurrencySymbol` fields.</span></span> <span data-ttu-id="a312f-290">Estos son los valores devueltos por las propiedades `Price` y `Currency`.</span><span class="sxs-lookup"><span data-stu-id="a312f-290">These are the values returned by the `Price` and `Currency` properties.</span></span>

- <span data-ttu-id="a312f-291">Invalida el método `ToString` (heredado de `Publication`) y los métodos <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> y <xref:System.Object.GetHashCode%2A> (heredados de <xref:System.Object>).</span><span class="sxs-lookup"><span data-stu-id="a312f-291">Overrides to the `ToString` method (inherited from `Publication`) and the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> and <xref:System.Object.GetHashCode%2A> methods (inherited from <xref:System.Object>).</span></span>

  <span data-ttu-id="a312f-292">A menos que se invalide, el método <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> prueba la igualdad de referencia.</span><span class="sxs-lookup"><span data-stu-id="a312f-292">Unless it is overridden, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method tests for reference equality.</span></span> <span data-ttu-id="a312f-293">Es decir, dos variables de objeto se consideran iguales si hacen referencia al mismo objeto.</span><span class="sxs-lookup"><span data-stu-id="a312f-293">That is, two object variables are considered to be equal if they refer to the same object.</span></span> <span data-ttu-id="a312f-294">Por otro lado, en el caso de la clase `Book`, dos objetos `Book` deben ser iguales si tienen el mismo ISBN.</span><span class="sxs-lookup"><span data-stu-id="a312f-294">In the case of the `Book` class, on the other hand, two `Book` objects should be equal if they have the same ISBN.</span></span>

  <span data-ttu-id="a312f-295">Cuando invalide el método <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, también debe invalidar el método <xref:System.Object.GetHashCode%2A>, que devuelve un valor que se usa en el entorno de ejecución para almacenar elementos en colecciones con hash para una recuperación eficiente.</span><span class="sxs-lookup"><span data-stu-id="a312f-295">When you override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, you must also override the <xref:System.Object.GetHashCode%2A> method, which returns a value that the runtime uses to store items in hashed collections for efficient retrieval.</span></span> <span data-ttu-id="a312f-296">El código hash debe devolver un valor que sea coherente con la prueba de igualdad.</span><span class="sxs-lookup"><span data-stu-id="a312f-296">The hash code should return a value that's consistent with the test for equality.</span></span> <span data-ttu-id="a312f-297">Puesto que hemos invalidado <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> para devolver `true`, si las propiedades de ISBN de dos objetos `Book` son iguales, se devuelve el código hash calculado mediante la llamada al método <xref:System.String.GetHashCode%2A> de la cadena devuelta por la propiedad `ISBN`.</span><span class="sxs-lookup"><span data-stu-id="a312f-297">Since we've overridden <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to return `true` if the ISBN properties of two `Book` objects are equal, we return the hash code computed by calling the <xref:System.String.GetHashCode%2A> method of the string returned by the `ISBN` property.</span></span>

<span data-ttu-id="a312f-298">En la siguiente ilustración se muestra la relación entre la clase `Book` y `Publication`, su clase base.</span><span class="sxs-lookup"><span data-stu-id="a312f-298">The following figure illustrates the relationship between the `Book` class and `Publication`, its base class.</span></span>

![Clases de libro y publicación](media/book-class.jpg)

<span data-ttu-id="a312f-300">Ahora podemos crear una instancia de un objeto `Book`, invocar sus miembros únicos y heredados y pasarla como argumento a un método que espera un parámetro de tipo `Publication` o de tipo `Book`, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="a312f-300">We can now instantiate a `Book` object, invoke both its unique and inherited members, and pass it as an argument to a method that expects a parameter of type `Publication` or of type `Book`, as the following example shows.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/use-publication.cs#1)]

## <a name="designing-abstract-base-classes-and-their-derived-classes"></a><span data-ttu-id="a312f-301">Diseño de clases base abstractas y sus clases derivadas</span><span class="sxs-lookup"><span data-stu-id="a312f-301">Designing abstract base classes and their derived classes</span></span>
<a name="abstract"></a>

<span data-ttu-id="a312f-302">En el ejemplo anterior, hemos definido una clase base que proporciona una implementación para una serie de métodos para permitir que las clases derivadas compartan código.</span><span class="sxs-lookup"><span data-stu-id="a312f-302">In the previous example, we defined a base class that provided an implementation for a number of methods to allow derived classes to share code.</span></span> <span data-ttu-id="a312f-303">En muchos casos, sin embargo, no se espera que la clase base proporcione una implementación.</span><span class="sxs-lookup"><span data-stu-id="a312f-303">In many cases, however, the base class is not expected to provide an implementation.</span></span> <span data-ttu-id="a312f-304">En su lugar, la clase base es un *clase abstracta*; sirve como plantilla que define los miembros que debe implementar cada clase derivada.</span><span class="sxs-lookup"><span data-stu-id="a312f-304">Instead, the base class is an *abstract class*; it serves as a template that defines the members that each derived class must implement.</span></span> <span data-ttu-id="a312f-305">Normalmente, en el caso de una clase base abstracta, la implementación de cada tipo derivado es exclusiva de ese tipo.</span><span class="sxs-lookup"><span data-stu-id="a312f-305">Typically in the case of an abstract base class, the implementation of each derived type is unique to that type.</span></span>

<span data-ttu-id="a312f-306">Por ejemplo, cada forma geométrica bidimensional cerrada incluye dos propiedades: área, la extensión interna de la forma; y perímetro, o la distancia a lo largo de los bordes de la forma.</span><span class="sxs-lookup"><span data-stu-id="a312f-306">For example, each closed two-dimensional geometric shape includes two properties: area, the inner extent of the shape; and perimeter, or the distance along the edges of the shape.</span></span> <span data-ttu-id="a312f-307">La manera en que se calculan estas propiedades, sin embargo, depende completamente de la forma específica.</span><span class="sxs-lookup"><span data-stu-id="a312f-307">The way in which these properties are calculated, however, depends completely on the specific shape.</span></span> <span data-ttu-id="a312f-308">La fórmula para calcular el perímetro (o circunferencia) de un círculo, por ejemplo, es muy diferente a la de un triángulo.</span><span class="sxs-lookup"><span data-stu-id="a312f-308">The formula for calculating the perimeter (or circumference) of a circle, for example, is very different from that of a triangle.</span></span>

<span data-ttu-id="a312f-309">En el ejemplo siguiente se define una clase base abstracta denominada `Shape` que define dos propiedades: `Area` y `Perimeter`.</span><span class="sxs-lookup"><span data-stu-id="a312f-309">The following example defines an abstract base class named `Shape` that defines two properties: `Area` and `Perimeter`.</span></span> <span data-ttu-id="a312f-310">Tenga en cuenta que, además de marcar la clase con la palabra clave [abstract](../language-reference/keywords/abstract.md), cada miembro de instancia también se marca con esta palabra clave [abstract](../language-reference/keywords/abstract.md).</span><span class="sxs-lookup"><span data-stu-id="a312f-310">Note that, in addition to marking the class with the [abstract](../language-reference/keywords/abstract.md) keyword, each instance member is also marked with the [abstract](../language-reference/keywords/abstract.md) keyword.</span></span> <span data-ttu-id="a312f-311">En este caso, `Shape` también invalida el método <xref:System.Object.ToString%2A?displayProperty=nameWithType> para devolver el nombre del tipo, en lugar de su nombre completo.</span><span class="sxs-lookup"><span data-stu-id="a312f-311">In this case, `Shape` also overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the name of the type, rather than its fully qualified name.</span></span> <span data-ttu-id="a312f-312">Y define dos miembros estáticos, `GetArea` y `GetPerimeter`, que permiten que los llamadores recuperen fácilmente el área y el perímetro de una instancia de cualquier clase derivada.</span><span class="sxs-lookup"><span data-stu-id="a312f-312">And it defines two static members, `GetArea` and `GetPerimeter`, that allow callers to easily retrieve the area and perimeter of an instance of any derived class.</span></span> <span data-ttu-id="a312f-313">Cuando se pasa una instancia de una clase derivada a cualquiera de estos métodos, el tiempo de ejecución llama a la invalidación del método de la clase derivada.</span><span class="sxs-lookup"><span data-stu-id="a312f-313">When we pass an instance of a derived class to either of these methods, the runtime calls the method override of the derived class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#1)]

<span data-ttu-id="a312f-314">Luego podemos derivar algunas clases de `Shape` que representan formas concretas.</span><span class="sxs-lookup"><span data-stu-id="a312f-314">We can then derive some classes from `Shape` that represent specific shapes.</span></span> <span data-ttu-id="a312f-315">El ejemplo siguiente define tres clases `Triangle`, `Rectangle` y `Circle`.</span><span class="sxs-lookup"><span data-stu-id="a312f-315">The following example defines three classes, `Triangle`, `Rectangle`, and `Circle`.</span></span> <span data-ttu-id="a312f-316">Cada una usa una fórmula única para esa forma en particular para calcular el área y el perímetro.</span><span class="sxs-lookup"><span data-stu-id="a312f-316">Each uses a formula unique for that particular shape to compute the area and perimeter.</span></span> <span data-ttu-id="a312f-317">Algunas de las clases derivadas también definen propiedades, como `Rectangle.Diagonal` y `Circle.Diameter`, que son únicas para la forma que representan.</span><span class="sxs-lookup"><span data-stu-id="a312f-317">Some of the derived classes also define properties, such as `Rectangle.Diagonal` and `Circle.Diameter`, that are unique to the shape that they represent.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#2)]

<span data-ttu-id="a312f-318">En el ejemplo siguiente se usan objetos derivados de `Shape`.</span><span class="sxs-lookup"><span data-stu-id="a312f-318">The following example uses objects derived from `Shape`.</span></span> <span data-ttu-id="a312f-319">Se crea una instancia de una matriz de objetos derivados de `Shape` y se llama a los métodos estáticos de la clase `Shape`, que ajusta los valores de propiedad `Shape` devueltos.</span><span class="sxs-lookup"><span data-stu-id="a312f-319">It instantiates an array of objects derived from `Shape` and calls the static methods of the `Shape` class, which wraps return `Shape` property values.</span></span> <span data-ttu-id="a312f-320">Tenga en cuenta que el tiempo de ejecución recupera los valores de las propiedades invalidadas de los tipos derivados.</span><span class="sxs-lookup"><span data-stu-id="a312f-320">Note that the runtime retrieves values from the overridden properties of the derived types.</span></span> <span data-ttu-id="a312f-321">En el ejemplo también se convierte cada objeto `Shape` de la matriz a su tipo derivado y, si la conversión se realiza correctamente, recupera las propiedades de esa subclase específica de `Shape`.</span><span class="sxs-lookup"><span data-stu-id="a312f-321">The example also casts each `Shape` object in the array to its derived type and, if the cast succeeds, retrieves properties of that particular subclass of `Shape`.</span></span> 

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#3)]

## <a name="see-also"></a><span data-ttu-id="a312f-322">Vea también</span><span class="sxs-lookup"><span data-stu-id="a312f-322">See also</span></span>

<span data-ttu-id="a312f-323">[Clases y objetos](../tour-of-csharp/classes-and-objects.md) </span><span class="sxs-lookup"><span data-stu-id="a312f-323">[Classes and objects](../tour-of-csharp/classes-and-objects.md) </span></span>  
[<span data-ttu-id="a312f-324">Herencia (Guía de programación de C#)</span><span class="sxs-lookup"><span data-stu-id="a312f-324">Inheritance (C# Programming Guide)</span></span>](../programming-guide/classes-and-structs/inheritance.md)
