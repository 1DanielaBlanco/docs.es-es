---
title: Funciones locales frente a expresiones lambda
description: "Obtenga información sobre por qué las funciones locales pueden ser una opción mejor que las expresiones lambda."
keywords: "C#, .NET, .NET Core, Características más recientes, Novedades, funciones locales, expresiones lambda"
author: BillWagner
ms.author: wiwagn
ms.date: 06/27/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 368d1752-3659-489a-97b4-f15d87e49ae3
ms.openlocfilehash: 20312b58a24dc991791edad4bb92d3a8ca6d501a
ms.sourcegitcommit: 5fb6646b5ee3769ffb214e672041833ea4ceeb26
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 11/08/2017
---
# <a name="local-functions-compared-to-lambda-expressions"></a><span data-ttu-id="5234f-104">Funciones locales en comparación con las expresiones lambda</span><span class="sxs-lookup"><span data-stu-id="5234f-104">Local functions compared to lambda expressions</span></span>

<span data-ttu-id="5234f-105">A primera vista, las [funciones locales](programming-guide/classes-and-structs/local-functions.md) y las [expresiones lambda](lambda-expressions.md) son muy similares.</span><span class="sxs-lookup"><span data-stu-id="5234f-105">At first glance, [local functions](programming-guide/classes-and-structs/local-functions.md) and [lambda expressions](lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="5234f-106">En muchos casos, la elección entre usar expresiones lambda y funciones locales es una cuestión de estilo y preferencias personales.</span><span class="sxs-lookup"><span data-stu-id="5234f-106">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="5234f-107">Sin embargo, hay diferencias reales en donde puede usar uno de los dos que debe tener en cuenta.</span><span class="sxs-lookup"><span data-stu-id="5234f-107">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="5234f-108">Vamos a examinar las diferencias entre las implementaciones de la función local y la expresión lambda del algoritmo factorial.</span><span class="sxs-lookup"><span data-stu-id="5234f-108">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="5234f-109">Primero la versión que usa una función local:</span><span class="sxs-lookup"><span data-stu-id="5234f-109">First the version using a local function:</span></span>

[!code-csharp[LocalFunctionFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Recursive factorial using local function")]

<span data-ttu-id="5234f-110">Compare esa implementación con una versión que use expresiones lambda:</span><span class="sxs-lookup"><span data-stu-id="5234f-110">Contrast that implementation with a version that uses lambda expressions:</span></span>

[!code-csharp[26_LambdaFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Recursive factorial using lambda expressions")]

<span data-ttu-id="5234f-111">Las funciones locales tienen nombres.</span><span class="sxs-lookup"><span data-stu-id="5234f-111">The local functions have names.</span></span> <span data-ttu-id="5234f-112">Las expresiones lambda son métodos anónimos que se asignan a variables que están `Func` o `Action` tipos.</span><span class="sxs-lookup"><span data-stu-id="5234f-112">The lambda expressions are anonymous methods that are assigned to variables that are `Func` or `Action` types.</span></span> <span data-ttu-id="5234f-113">Cuando se declara una función local, los tipos de argumento y el tipo de valor devuelto forman parte de la declaración de función.</span><span class="sxs-lookup"><span data-stu-id="5234f-113">When you declare a local function, the argument types and return type are part of the function declaration.</span></span> <span data-ttu-id="5234f-114">En lugar de formar parte del cuerpo de la expresión lambda expresión, los tipos de argumento y el tipo de valor devuelto forman parte de la declaración de tipo de variable de la expresión lambda.</span><span class="sxs-lookup"><span data-stu-id="5234f-114">Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda expression's variable type declaration.</span></span> <span data-ttu-id="5234f-115">Esas dos diferencias pueden generar código más claro.</span><span class="sxs-lookup"><span data-stu-id="5234f-115">Those two differences may result in clearer code.</span></span>

<span data-ttu-id="5234f-116">Funciones locales tienen reglas diferentes para la asignación definitiva que las expresiones lambda.</span><span class="sxs-lookup"><span data-stu-id="5234f-116">Local functions have different rules for definite assignment than lambda expressions.</span></span> <span data-ttu-id="5234f-117">Puede hacer referencia a una declaración de función local desde cualquier lugar del código donde esté dentro del ámbito.</span><span class="sxs-lookup"><span data-stu-id="5234f-117">A local function declaration can be referenced from any code location where it is in scope.</span></span> <span data-ttu-id="5234f-118">Una expresión lambda debe asignarse a una variable de delegado antes de pueda obtener acceso a (o llamar a través de la delgate que hacen referencia a la expresión lambda.) Observe que la versión con la expresión lambda debe declarar e inicializar la expresión lambda, `nthFactorial`, antes de definirla.</span><span class="sxs-lookup"><span data-stu-id="5234f-118">A lambda expression must be assigned to a delegate variable before it can be accessed (or called through the delgate referencing the lambda expression.) Notice that the version using the lambda expression must declare and initialize the lambda expression, `nthFactorial` before defining it.</span></span> <span data-ttu-id="5234f-119">De no hacerlo, se produce un error en tiempo de compilación por hacer referencia a `nthFactorial` antes de asignarlo.</span><span class="sxs-lookup"><span data-stu-id="5234f-119">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span>
<span data-ttu-id="5234f-120">Estas diferencias significan que son más fáciles de crear mediante funciones locales algoritmos recursivos.</span><span class="sxs-lookup"><span data-stu-id="5234f-120">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="5234f-121">Puede declarar y definir una función local que llama a sí mismo.</span><span class="sxs-lookup"><span data-stu-id="5234f-121">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="5234f-122">Expresiones lambda deben declaradas y se asigna un valor predeterminado antes de que se pueden volver a asignarse a un cuerpo que hace referencia a la misma expresión lambda.</span><span class="sxs-lookup"><span data-stu-id="5234f-122">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

<span data-ttu-id="5234f-123">Reglas de asignación definitiva también afecta a las variables que se capturan por la epression de función o expresión lamdba local.</span><span class="sxs-lookup"><span data-stu-id="5234f-123">Definite assignment rules also affect any variables that are captured by the local function or lamdba epression.</span></span> <span data-ttu-id="5234f-124">Funciones locales y reglas de la expresión lambda exigen que las variables capturadas definitivamente se asignan en el momento cuando la expresión de función o expresión lambda local se convierte en un delegado.</span><span class="sxs-lookup"><span data-stu-id="5234f-124">Both local functions and lambda expression rules demand that any captured variables are definitely assigned at the point when the local function or lambda expression is converted to a delegate.</span></span> <span data-ttu-id="5234f-125">La diferencia es que las expresiones lambda se convierten en delegados cuando se declaran.</span><span class="sxs-lookup"><span data-stu-id="5234f-125">The difference is that lambda expressions are converted to delegates when they are declared.</span></span> <span data-ttu-id="5234f-126">Funciones locales se convierten en delegados solo cuando se usa como un delegado.</span><span class="sxs-lookup"><span data-stu-id="5234f-126">Local functions are converted to delegates only when used as a delegate.</span></span> <span data-ttu-id="5234f-127">Si se declara una función local y solo hacer referencia a él llamando al igual que un método, no se convertirán a un delegado.</span><span class="sxs-lookup"><span data-stu-id="5234f-127">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span> <span data-ttu-id="5234f-128">Esta regla permite declarar una función local en cualquier ubicación adecuada en su ámbito de inclusión.</span><span class="sxs-lookup"><span data-stu-id="5234f-128">That rule enables you to declare a local function at any convenient location in its enclosing scope.</span></span> <span data-ttu-id="5234f-129">Es común para declarar funciones locales al final del método principal, después de las instrucciones return.</span><span class="sxs-lookup"><span data-stu-id="5234f-129">It's common to declare local functions at the end of the parent method, after any return statements.</span></span>

<span data-ttu-id="5234f-130">En tercer lugar, el compilador puede realizar un análisis estático que permite funciones locales asignar definitivamente variables capturadas en el ámbito de inclusión.</span><span class="sxs-lookup"><span data-stu-id="5234f-130">Third, the compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="5234f-131">Considere este ejemplo:</span><span class="sxs-lookup"><span data-stu-id="5234f-131">Consider this example:</span></span>

```csharp
bool M()
{
    int y;
    Local();
    return y;

    void Local() => y = 0;
}
```

<span data-ttu-id="5234f-132">El compilador puede determinar que `Local` definitivamente asigna `y` cuando se llama.</span><span class="sxs-lookup"><span data-stu-id="5234f-132">The compiler can determine that `Local` definitely assigns `y` when called.</span></span> <span data-ttu-id="5234f-133">Dado que `Local` se llama antes de la `return` instrucción, `y` se asigna definitiely en el `return` instrucción.</span><span class="sxs-lookup"><span data-stu-id="5234f-133">Because `Local` is called before the `return` statement, `y` is definitiely assigned at the `return` statement.</span></span>

<span data-ttu-id="5234f-134">El análisis que permite que el análisis permite la diferencia cuarta.</span><span class="sxs-lookup"><span data-stu-id="5234f-134">The analysis that enables that analysis enables the fourth difference.</span></span>
<span data-ttu-id="5234f-135">Dependiendo de su uso, funciones locales pueden evitar las asignaciones del montón que siempre son necesarias para las expresiones lambda.</span><span class="sxs-lookup"><span data-stu-id="5234f-135">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="5234f-136">Si una función local nunca se convierte en un delegado, y ninguna de las variables capturadas por la función local se captura por otras expresiones lambda o funciones locales que se convierten en delegados, el compilador puede evitar las asignaciones del montón.</span><span class="sxs-lookup"><span data-stu-id="5234f-136">If a local function is never converted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span> 

<span data-ttu-id="5234f-137">Considere este ejemplo asincrónico:</span><span class="sxs-lookup"><span data-stu-id="5234f-137">Consider this async example:</span></span>

[!code-csharp[TaskLambdaExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Task returning method with lambda expression")]

<span data-ttu-id="5234f-138">La clausura de esta expresión lambda contiene las variables `address`, `index` y `name`.</span><span class="sxs-lookup"><span data-stu-id="5234f-138">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="5234f-139">En el caso de las funciones locales, el objeto que implementa el cierre puede ser un tipo `struct`.</span><span class="sxs-lookup"><span data-stu-id="5234f-139">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="5234f-140">Luego se pasarían ese tipo de estructura por referencia a la función local.</span><span class="sxs-lookup"><span data-stu-id="5234f-140">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="5234f-141">Esta diferencia de implementación se guarde en una asignación.</span><span class="sxs-lookup"><span data-stu-id="5234f-141">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="5234f-142">La creación de instancias es necesario para las expresiones lambda significa asignaciones de memoria adicional, lo que pueden ser un factor de rendimiento en las rutas de acceso del código crítico en el tiempo.</span><span class="sxs-lookup"><span data-stu-id="5234f-142">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span>
<span data-ttu-id="5234f-143">Las funciones locales no suponen esta sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="5234f-143">Local functions do not incur this overhead.</span></span> <span data-ttu-id="5234f-144">En el ejemplo anterior, la versión de las funciones locales tiene 2 asignaciones menos que la versión de la expresión lambda.</span><span class="sxs-lookup"><span data-stu-id="5234f-144">In the example above, the local functions version has 2 fewer allocations than the lambda expression version.</span></span>

> [!NOTE]
> <span data-ttu-id="5234f-145">La función local equivalente de este método también usa una clase para el cierre.</span><span class="sxs-lookup"><span data-stu-id="5234f-145">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="5234f-146">Si el cierre de una función local se implementa como `class` o `struct` es un detalle de implementación.</span><span class="sxs-lookup"><span data-stu-id="5234f-146">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="5234f-147">Una función local puede usar `struct` mientras una expresión lambda siempre usará `class`.</span><span class="sxs-lookup"><span data-stu-id="5234f-147">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

[!code-csharp[TaskLocalFunctionExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#29_TaskExample "Task returning method with local function")]

<span data-ttu-id="5234f-148">Una ventaja final que no se muestra en este ejemplo es que las funciones locales pueden implementarse como iteradores, con la sintaxis `yield return` para producir una secuencia de valores.</span><span class="sxs-lookup"><span data-stu-id="5234f-148">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span> <span data-ttu-id="5234f-149">El `yield return` instrucción no se permite en expresiones lambda.</span><span class="sxs-lookup"><span data-stu-id="5234f-149">The `yield return` statement is not allowed in lambda expressions.</span></span>

<span data-ttu-id="5234f-150">Aunque las funciones locales pueden parecer redundantes con respecto a las expresiones lambda, en realidad tienen finalidades y usos diferentes.</span><span class="sxs-lookup"><span data-stu-id="5234f-150">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span>
<span data-ttu-id="5234f-151">Las funciones locales son más eficaces si se quiere escribir una función a la que solo se llame desde el contexto de otro método.</span><span class="sxs-lookup"><span data-stu-id="5234f-151">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>
