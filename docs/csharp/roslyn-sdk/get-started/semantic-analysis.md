---
title: "Introducción al análisis semántico"
description: "En este tutorial, se proporciona una introducción sobre cómo trabajar con el análisis semántico mediante el SDK de .NET Compiler."
author: billwagner
ms.author: wiwagn
ms.date: 02/06/2018
ms.topic: conceptual
ms.prod: .net
ms.devlang: devlang-csharp
ms.custom: mvc
ms.openlocfilehash: 04bd57dfd32a51bf5d7e3a573e34140b0feec90f
ms.sourcegitcommit: 3a96c706e4dbb4667bf3bf37edac9e1666646f93
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 02/27/2018
---
# <a name="get-started-with-semantic-analysis"></a><span data-ttu-id="c04cb-103">Introducción al análisis semántico</span><span class="sxs-lookup"><span data-stu-id="c04cb-103">Get started with semantic analysis</span></span>

<span data-ttu-id="c04cb-104">En este tutorial, se asume que conoce la API de sintaxis.</span><span class="sxs-lookup"><span data-stu-id="c04cb-104">This tutorial assumes you're familiar with the Syntax API.</span></span> <span data-ttu-id="c04cb-105">En el artículo [Introducción al análisis de sintaxis](syntax-analysis.md) se proporciona una introducción suficiente.</span><span class="sxs-lookup"><span data-stu-id="c04cb-105">The [get started with syntax analysis](syntax-analysis.md) article provides sufficient introduction.</span></span>

<span data-ttu-id="c04cb-106">En este tutorial, explorará las **API de símbolo** y **enlace**.</span><span class="sxs-lookup"><span data-stu-id="c04cb-106">In this tutorial, you explore the **Symbol** and **Binding APIs**.</span></span> <span data-ttu-id="c04cb-107">Estas API ofrecen información sobre el _significado semántico_ de un programa.</span><span class="sxs-lookup"><span data-stu-id="c04cb-107">These APIs provide information about the _semantic meaning_ of a program.</span></span> <span data-ttu-id="c04cb-108">Le permiten formular y responder preguntas sobre los tipos representados por cualquier símbolo en el programa.</span><span class="sxs-lookup"><span data-stu-id="c04cb-108">They enable you to ask and answer questions about the types represented by any symbol in your program.</span></span>

## <a name="understanding-compilations-and-symbols"></a><span data-ttu-id="c04cb-109">Comprender las compilaciones y los símbolos</span><span class="sxs-lookup"><span data-stu-id="c04cb-109">Understanding Compilations and Symbols</span></span>

<span data-ttu-id="c04cb-110">Conforme trabaja más con el SDK de .NET Compiler, empieza a familiarizarse con las diferencias entre la API de sintaxis y la API semántica.</span><span class="sxs-lookup"><span data-stu-id="c04cb-110">As you work more with the .NET Compiler SDK, you become familiar with the distinctions between Syntax API and the Semantic API.</span></span> <span data-ttu-id="c04cb-111">La **API de sintaxis** le permite buscar en la _estructura_ de un programa.</span><span class="sxs-lookup"><span data-stu-id="c04cb-111">The **Syntax API** allows you to look at the _structure_ of a program.</span></span> <span data-ttu-id="c04cb-112">En cambio, a menudo quiere una información más completa sobre la semántica o el _significado_ de un programa.</span><span class="sxs-lookup"><span data-stu-id="c04cb-112">However, often you want richer information about the semantics or _meaning_ of a program.</span></span> <span data-ttu-id="c04cb-113">Aunque un fragmento de código o archivo de código dinámico de VB o C# se puede analizar sintácticamente de forma aislada, no tiene sentido formular preguntas como "¿cuál es el tipo de esta variable?" de manera aislada.</span><span class="sxs-lookup"><span data-stu-id="c04cb-113">While a loose code file or snippet of VB or C# code can be syntactically analyzed in isolation, it's not meaningful to ask questions such as "what's the type of this variable" in a vacuum.</span></span> <span data-ttu-id="c04cb-114">El significado de un nombre de tipo puede depender de las referencias de ensamblado, las importaciones de espacio de nombres u otros archivos de código.</span><span class="sxs-lookup"><span data-stu-id="c04cb-114">The meaning of a type name may be dependent on assembly references, namespace imports, or other code files.</span></span> <span data-ttu-id="c04cb-115">Esas preguntas se responden mediante la **API semántica**, concretamente la clase <xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c04cb-115">Those questions are answered using the **Semantic API**, specifically the <xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType> class.</span></span>

<span data-ttu-id="c04cb-116">Una instancia de <xref:Microsoft.CodeAnalysis.Compilation> es análoga a un único proyecto, tal como muestra el compilador y representa todo lo necesario para compilar un programa de Visual Basic o C#.</span><span class="sxs-lookup"><span data-stu-id="c04cb-116">An instance of <xref:Microsoft.CodeAnalysis.Compilation> is analogous to a single project as seen by the compiler and represents everything needed to compile a Visual Basic or C# program.</span></span> <span data-ttu-id="c04cb-117">La **compilación** incluye el conjunto de archivos de código fuente que se compilarán, las referencias de ensamblado y las opciones del compilador.</span><span class="sxs-lookup"><span data-stu-id="c04cb-117">The **compilation** includes the set of source files to be compiled, assembly references, compiler options.</span></span> <span data-ttu-id="c04cb-118">Puede analizar el significado del código con toda la demás información en este contexto.</span><span class="sxs-lookup"><span data-stu-id="c04cb-118">You can reason about the meaning of the code using all the other information in this context.</span></span> <span data-ttu-id="c04cb-119">Una <xref:Microsoft.CodeAnalysis.Compilation> permite buscar **símbolos** (entidades como tipos, espacios de nombres, miembros y variables a los que hacen referencia nombres y otras expresiones).</span><span class="sxs-lookup"><span data-stu-id="c04cb-119">A <xref:Microsoft.CodeAnalysis.Compilation> allows you to find **Symbols** - entities such as types, namespaces, members, and variables which names and other expressions refer to.</span></span> <span data-ttu-id="c04cb-120">El proceso de asociar los nombres y las expresiones con **símbolos** se denomina **enlace**.</span><span class="sxs-lookup"><span data-stu-id="c04cb-120">The process of associating names and expressions with **Symbols** is called **Binding**.</span></span>

<span data-ttu-id="c04cb-121">Como <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, <xref:Microsoft.CodeAnalysis.Compilation> es una clase abstracta con derivados específicos del lenguaje.</span><span class="sxs-lookup"><span data-stu-id="c04cb-121">Like <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, <xref:Microsoft.CodeAnalysis.Compilation> is an abstract class with language-specific derivatives.</span></span> <span data-ttu-id="c04cb-122">Al crear una instancia de la compilación, debe invocar un método de generador en la clase <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType> (o <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="c04cb-122">When creating an instance of Compilation, you must invoke a factory method on the <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType> (or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType>) class.</span></span>

## <a name="querying-symbols"></a><span data-ttu-id="c04cb-123">Consultar símbolos</span><span class="sxs-lookup"><span data-stu-id="c04cb-123">Querying symbols</span></span>

<span data-ttu-id="c04cb-124">En este tutorial, volverá a examinar el programa "Hola mundo".</span><span class="sxs-lookup"><span data-stu-id="c04cb-124">In this tutorial, you look at the "Hello World" program again.</span></span> <span data-ttu-id="c04cb-125">En esta ocasión, consultará los símbolos del programa para comprender qué tipos representan esos símbolos.</span><span class="sxs-lookup"><span data-stu-id="c04cb-125">This time, you query the symbols in the program to understand what types those symbols represent.</span></span> <span data-ttu-id="c04cb-126">Consultará los tipos en un espacio de nombres y aprenderá a buscar los métodos disponibles en un tipo.</span><span class="sxs-lookup"><span data-stu-id="c04cb-126">You query for the types in a namespace, and learn to find the methods available on a type.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="c04cb-127">Los siguientes ejemplos requieren tener instalado el **SDK de .NET Compiler** como parte de Visual Studio 2017.</span><span class="sxs-lookup"><span data-stu-id="c04cb-127">The following samples require the **.NET Compiler SDK** installed as part of Visual Studio 2017.</span></span> <span data-ttu-id="c04cb-128">Puede encontrar el SDK de .NET Compiler como el último componente opcional que aparece en la carga de trabajo **Desarrollo de extensiones de Visual Studio**.</span><span class="sxs-lookup"><span data-stu-id="c04cb-128">You can find the .NET Compiler SDK as the last optional component listed under the **Visual Studio extension development** workload.</span></span> <span data-ttu-id="c04cb-129">Las plantillas no se instalan sin este componente.</span><span class="sxs-lookup"><span data-stu-id="c04cb-129">The templates aren't installed without this component.</span></span>

<span data-ttu-id="c04cb-130">Puede ver el código terminado de este ejemplo en [nuestro repositorio de ejemplos de GitHub](https://github.com/dotnet/samples/csharp/roslyn-sdk/SemanticQuickStart).</span><span class="sxs-lookup"><span data-stu-id="c04cb-130">You can see the finished code for this sample in [our GitHub samples repository](https://github.com/dotnet/samples/csharp/roslyn-sdk/SemanticQuickStart).</span></span>

> [!NOTE]
> <span data-ttu-id="c04cb-131">Los tipos de árbol de sintaxis usan la herencia para describir los diferentes elementos de sintaxis que son válidos en diferentes ubicaciones del programa.</span><span class="sxs-lookup"><span data-stu-id="c04cb-131">The Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program.</span></span> <span data-ttu-id="c04cb-132">A menudo, usar estas API significa convertir propiedades o miembros de colección en tipos derivados concretos.</span><span class="sxs-lookup"><span data-stu-id="c04cb-132">Using these APIs often means casting properties or collection members to specific derived types.</span></span> <span data-ttu-id="c04cb-133">En los ejemplos siguientes, la asignación y las conversiones son instrucciones independientes, con variables con tipo explícito.</span><span class="sxs-lookup"><span data-stu-id="c04cb-133">In the following examples, the assignment and the casts are separate statements, using explicitly typed variables.</span></span> <span data-ttu-id="c04cb-134">Puede leer el código para ver los tipos de valor devuelto de la API y el tipo de motor de ejecución de los objetos devueltos.</span><span class="sxs-lookup"><span data-stu-id="c04cb-134">You can read the code to see the return types of the API and the runtime type of the objects returned.</span></span> <span data-ttu-id="c04cb-135">En la práctica, es más habitual usar variables con tipo implícito y basarse en nombres de API para describir el tipo de los objetos que se examinan.</span><span class="sxs-lookup"><span data-stu-id="c04cb-135">In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.</span></span>

<span data-ttu-id="c04cb-136">Cree un proyecto de **Stand-Alone Code Analysis Tool** (Herramienta de análisis de código independiente) de C#:</span><span class="sxs-lookup"><span data-stu-id="c04cb-136">Create a new C# **Stand-Alone Code Analysis Tool** project:</span></span>

* <span data-ttu-id="c04cb-137">En Visual Studio, elija **Archivo** > **Nuevo** > **Proyecto** para mostrar el cuadro de diálogo Nuevo proyecto.</span><span class="sxs-lookup"><span data-stu-id="c04cb-137">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span>
* <span data-ttu-id="c04cb-138">En **Visual C#** > **Extensibilidad**, elija **Stand-Alone Code Analysis Tool** (Herramienta de análisis de código independiente).</span><span class="sxs-lookup"><span data-stu-id="c04cb-138">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span>
* <span data-ttu-id="c04cb-139">Asigne al proyecto el nombre "**SemanticQuickStart**" y haga clic en Aceptar.</span><span class="sxs-lookup"><span data-stu-id="c04cb-139">Name your project "**SemanticQuickStart**" and click OK.</span></span>

<span data-ttu-id="c04cb-140">Va a analizar el programa básico "Hola mundo"</span><span class="sxs-lookup"><span data-stu-id="c04cb-140">You're going to analyze the basic "Hello World!"</span></span> <span data-ttu-id="c04cb-141">mostrado anteriormente.</span><span class="sxs-lookup"><span data-stu-id="c04cb-141">program shown earlier.</span></span>
<span data-ttu-id="c04cb-142">Agregue el texto para el programa Hola mundo como una constante en su clase `Program`:</span><span class="sxs-lookup"><span data-stu-id="c04cb-142">Add the text for the Hello World program as a constant in your `Program` class:</span></span>

[!code-csharp[Declare the program test](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#1 "Declare a constant string for the program text to analyze")]

<span data-ttu-id="c04cb-143">A continuación, agregue el código siguiente para crear el árbol de sintaxis para el texto del código de la constante `programText`.</span><span class="sxs-lookup"><span data-stu-id="c04cb-143">Next, add the following code to build the syntax tree for the code text in the `programText` constant.</span></span>  <span data-ttu-id="c04cb-144">Agregue la línea siguiente al método `Main`:</span><span class="sxs-lookup"><span data-stu-id="c04cb-144">Add the following line to your `Main` method:</span></span>

[!code-csharp[Create the tree](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#2 "Create the syntax tree")]

<span data-ttu-id="c04cb-145">A continuación, compile una <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation> del árbol que ya ha creado.</span><span class="sxs-lookup"><span data-stu-id="c04cb-145">Next, build a <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation> from the tree you already created.</span></span> <span data-ttu-id="c04cb-146">El ejemplo "Hola mundo" se basa en los tipos <xref:System.String> y <xref:System.Console>.</span><span class="sxs-lookup"><span data-stu-id="c04cb-146">The "Hello World" sample relies on the <xref:System.String> and <xref:System.Console> types.</span></span> <span data-ttu-id="c04cb-147">Debe hacer referencia al ensamblado que declara esos dos tipos en la compilación.</span><span class="sxs-lookup"><span data-stu-id="c04cb-147">You need to reference the assembly that declares those two types in your compilation.</span></span> <span data-ttu-id="c04cb-148">Agregue la siguiente línea a su método `Main` para crear una compilación de su árbol de sintaxis, incluida la referencia al ensamblado adecuado:</span><span class="sxs-lookup"><span data-stu-id="c04cb-148">Add the following line to your `Main` method to create a compilation of your syntax tree, including the reference to the appropriate assembly:</span></span>

[!code-csharp[Create the compilation](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#3 "Create the compilation for the semantic model")]

<span data-ttu-id="c04cb-149">El método <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType> agrega referencias a la compilación.</span><span class="sxs-lookup"><span data-stu-id="c04cb-149">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType> method adds references to the compilation.</span></span> <span data-ttu-id="c04cb-150">El método <xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile(System.String,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider)> carga un ensamblado como referencia.</span><span class="sxs-lookup"><span data-stu-id="c04cb-150">The <xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile(System.String,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider)> method loads an assembly as a reference.</span></span> 

## <a name="querying-the-semantic-model"></a><span data-ttu-id="c04cb-151">Consultar el modelo semántico</span><span class="sxs-lookup"><span data-stu-id="c04cb-151">Querying the semantic model</span></span>

<span data-ttu-id="c04cb-152">Una vez que tenga una <xref:Microsoft.CodeAnalysis.Compilation>, puede pedirle un <xref:Microsoft.CodeAnalysis.SemanticModel> para cualquier <xref:Microsoft.CodeAnalysis.SyntaxTree> incluido en esa <xref:Microsoft.CodeAnalysis.Compilation>.</span><span class="sxs-lookup"><span data-stu-id="c04cb-152">Once you have a <xref:Microsoft.CodeAnalysis.Compilation> you can ask it for a <xref:Microsoft.CodeAnalysis.SemanticModel> for any <xref:Microsoft.CodeAnalysis.SyntaxTree> contained in that <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="c04cb-153">Puede considerar el modelo semántico como el origen de toda la información que normalmente obtendría de IntelliSense.</span><span class="sxs-lookup"><span data-stu-id="c04cb-153">You can think of the semantic model as the source for all the information would normally get from intellisense.</span></span> <span data-ttu-id="c04cb-154">Un <xref:Microsoft.CodeAnalysis.SemanticModel> puede responder a preguntas como "¿qué nombres están en el ámbito en esta ubicación?",</span><span class="sxs-lookup"><span data-stu-id="c04cb-154">A <xref:Microsoft.CodeAnalysis.SemanticModel> can answer questions like "What names are in scope at this location?"</span></span> <span data-ttu-id="c04cb-155">"¿a qué miembros se puede acceder desde este método?",</span><span class="sxs-lookup"><span data-stu-id="c04cb-155">"What members are accessible from this method?"</span></span> <span data-ttu-id="c04cb-156">"¿qué variables se usan en este bloque de texto?"</span><span class="sxs-lookup"><span data-stu-id="c04cb-156">"What variables are used in this block of text?"</span></span> <span data-ttu-id="c04cb-157">y "¿a qué hace referencia esta expresión o este nombre?".</span><span class="sxs-lookup"><span data-stu-id="c04cb-157">and "What does this name/expression refer to?"</span></span> <span data-ttu-id="c04cb-158">Agregue esta instrucción para crear el modelo semántico:</span><span class="sxs-lookup"><span data-stu-id="c04cb-158">Add this statement to create the semantic model:</span></span>

[!code-csharp[Create the semantic model](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#4 "Create the semantic model")]

## <a name="binding-a-name"></a><span data-ttu-id="c04cb-159">Enlazar un nombre</span><span class="sxs-lookup"><span data-stu-id="c04cb-159">Binding a name</span></span>

<span data-ttu-id="c04cb-160">La <xref:Microsoft.CodeAnalysis.Compilation> crea el <xref:Microsoft.CodeAnalysis.SemanticModel> desde el <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span><span class="sxs-lookup"><span data-stu-id="c04cb-160">The <xref:Microsoft.CodeAnalysis.Compilation> creates the  <xref:Microsoft.CodeAnalysis.SemanticModel> from the <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span></span> <span data-ttu-id="c04cb-161">Después de crear el modelo, puede consultarlo para buscar la primera directiva `using` y recuperar la información de símbolo del espacio de nombres `System`.</span><span class="sxs-lookup"><span data-stu-id="c04cb-161">After creating the model, you can query it to find the first `using` directive, and retrieve the symbol information for the `System` namespace.</span></span> <span data-ttu-id="c04cb-162">Agregue estas dos líneas en su método `Main` para crear el modelo semántico y recuperar el símbolo de la primera instrucción using:</span><span class="sxs-lookup"><span data-stu-id="c04cb-162">Add these two lines to your `Main` method to create the semantic model and retrieve the symbol for the first using statement:</span></span>

[!code-csharp[Find the namespace symbol for the first using](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#5 "Find the namespace symbol for the first using")]

<span data-ttu-id="c04cb-163">El código anterior muestra cómo obtener un objeto <xref:Microsoft.CodeAnalysis.SemanticModel> para su <xref:Microsoft.CodeAnalysis.SyntaxTree> Hola mundo.</span><span class="sxs-lookup"><span data-stu-id="c04cb-163">The preceding code shows how to obtain a <xref:Microsoft.CodeAnalysis.SemanticModel> object for your HelloWorld <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span></span> <span data-ttu-id="c04cb-164">Una vez que se obtiene el modelo, el nombre de la primera directiva `using` está enlazado para recuperar una <xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType> para el espacio de nombres `System`.</span><span class="sxs-lookup"><span data-stu-id="c04cb-164">Once the model is obtained, the name in the first `using` directive is bound to retrieve a <xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType> for the `System` namespace.</span></span> <span data-ttu-id="c04cb-165">El código anterior también muestra que usa el **modelo de sintaxis** para buscar la estructura del código y usa el **modelo semántico** para entender su significado.</span><span class="sxs-lookup"><span data-stu-id="c04cb-165">The preceding code also illustrates that you use the **syntax model** to find the structure of the code; you use the **semantic model** to understand its meaning.</span></span> <span data-ttu-id="c04cb-166">El **modelo de sintaxis** busca la cadena `System` en la instrucción using.</span><span class="sxs-lookup"><span data-stu-id="c04cb-166">The **syntax model** finds the string `System` in the using statement.</span></span> <span data-ttu-id="c04cb-167">El **modelo semántico** tiene toda la información sobre los tipos definidos en el espacio de nombres `System`.</span><span class="sxs-lookup"><span data-stu-id="c04cb-167">The **semantic model** has all the information about the types defined in the `System` namespace.</span></span>

<span data-ttu-id="c04cb-168">Desde el objeto <xref:Microsoft.CodeAnalysis.SymbolInfo> puede obtener el <xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType> mediante la propiedad <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c04cb-168">From the <xref:Microsoft.CodeAnalysis.SymbolInfo> object you can obtain the <xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType> using the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="c04cb-169">Esta propiedad devuelve el símbolo al que hace referencia esta expresión.</span><span class="sxs-lookup"><span data-stu-id="c04cb-169">This property returns the symbol this expression refers to.</span></span> <span data-ttu-id="c04cb-170">Para las expresiones que no hacen referencia a ningún elemento (por ejemplo, los literales numéricos), esta propiedad es `null`.</span><span class="sxs-lookup"><span data-stu-id="c04cb-170">For expressions that don't refer to anything (such as numeric literals) this property is `null`.</span></span> <span data-ttu-id="c04cb-171">Cuando el <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> no es NULL, el <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> denota el tipo del símbolo.</span><span class="sxs-lookup"><span data-stu-id="c04cb-171">When the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> is not null, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> denotes the type of the symbol.</span></span> <span data-ttu-id="c04cb-172">En este ejemplo, la propiedad <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> es un <xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c04cb-172">In this example, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> property is a <xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c04cb-173">Agregue el código siguiente al método `Main`.</span><span class="sxs-lookup"><span data-stu-id="c04cb-173">Add the following code to your `Main` method.</span></span> <span data-ttu-id="c04cb-174">Recupera el símbolo del espacio de nombres `System` y, después, muestra todos los espacios de nombres secundarios que se declaran en el espacio de nombres `System`:</span><span class="sxs-lookup"><span data-stu-id="c04cb-174">It retrieves the symbol for the `System` namespace and then displays all the child namespaces declared in the `System` namespace:</span></span>

[!code-csharp[Display all the child namespaces](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#6 "Display all the child namespaces from this compilation")]

<span data-ttu-id="c04cb-175">Ejecute el programa y debería ver la siguiente salida:</span><span class="sxs-lookup"><span data-stu-id="c04cb-175">Run the program and you should see the following output:</span></span>

```
Collections
Configuration
Deployment
Diagnostics
Globalization
IO
Reflection
Resources
Runtime
Security
StubHelpers
Text
Threading
Press any key to continue . . .
```

> [!NOTE]
> <span data-ttu-id="c04cb-176">La salida no incluye todos los espacios de nombres que son secundarios del espacio de nombres `System`.</span><span class="sxs-lookup"><span data-stu-id="c04cb-176">The output does not include every namespace that is a child namespace of the `System` namespace.</span></span> <span data-ttu-id="c04cb-177">Muestra cada espacio de nombres que se encuentra en esta compilación, que solo hace referencia al ensamblado donde se declara `System.String`.</span><span class="sxs-lookup"><span data-stu-id="c04cb-177">It displays every namespace that is present in this compilation, which only references the assembly where `System.String` is declared.</span></span> <span data-ttu-id="c04cb-178">Esta compilación no conoce ningún espacio de nombres declarado en otros ensamblados.</span><span class="sxs-lookup"><span data-stu-id="c04cb-178">Any namespaces declared in other assemblies are not known to this compilation</span></span>

### <a name="binding-an-expression"></a><span data-ttu-id="c04cb-179">Enlazar una expresión</span><span class="sxs-lookup"><span data-stu-id="c04cb-179">Binding an expression</span></span>

<span data-ttu-id="c04cb-180">El código anterior muestra cómo buscar un símbolo al enlazarlo a un nombre.</span><span class="sxs-lookup"><span data-stu-id="c04cb-180">The preceding code shows how to find a symbol by binding to a name.</span></span> <span data-ttu-id="c04cb-181">Hay otras expresiones en un programa de C# que se pueden enlazar que no son nombres.</span><span class="sxs-lookup"><span data-stu-id="c04cb-181">There are other expressions in a C# program that can be bound that aren't names.</span></span> <span data-ttu-id="c04cb-182">Para demostrar esta funcionalidad, accederemos al enlace a un literal de cadena sencillo.</span><span class="sxs-lookup"><span data-stu-id="c04cb-182">To demonstrate this capability, let's access the binding to a simple string literal.</span></span>

<span data-ttu-id="c04cb-183">El programa "Hola mundo" contiene una <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType>, la cadena "Hello, World!"</span><span class="sxs-lookup"><span data-stu-id="c04cb-183">The "Hello World" program contains a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType>, the "Hello, World!"</span></span> <span data-ttu-id="c04cb-184">que se muestra en la consola.</span><span class="sxs-lookup"><span data-stu-id="c04cb-184">string displayed to the console.</span></span>

<span data-ttu-id="c04cb-185">Encontrará la cadena "Hello, World!"</span><span class="sxs-lookup"><span data-stu-id="c04cb-185">You find the "Hello, World!"</span></span> <span data-ttu-id="c04cb-186">si busca el literal de cadena único en el programa.</span><span class="sxs-lookup"><span data-stu-id="c04cb-186">string by locating the single string literal in the program.</span></span> <span data-ttu-id="c04cb-187">A continuación, una vez que haya encontrado el nodo de sintaxis, obtenga la información de tipo de ese nodo del modelo semántico.</span><span class="sxs-lookup"><span data-stu-id="c04cb-187">Then, once you've located the syntax node, get the type info for that node from the semantic model.</span></span> <span data-ttu-id="c04cb-188">Agregue el código siguiente al método `Main`:</span><span class="sxs-lookup"><span data-stu-id="c04cb-188">Add the following code to your `Main` method:</span></span>

[!code-csharp[Find the namespace symbol for the only using](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#7 "Find the namespace symbol for the only using")]

<span data-ttu-id="c04cb-189">La estructura <xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType> incluye una propiedad <xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType> que permite el acceso a la información semántica sobre el tipo del literal.</span><span class="sxs-lookup"><span data-stu-id="c04cb-189">The <xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType> struct includes a <xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType> property that enables access to the semantic information about the type of the literal.</span></span> <span data-ttu-id="c04cb-190">En este ejemplo, es el tipo `string`.</span><span class="sxs-lookup"><span data-stu-id="c04cb-190">In this example, that's the `string` type.</span></span> <span data-ttu-id="c04cb-191">Agregue una declaración que asigne esta propiedad a una variable local:</span><span class="sxs-lookup"><span data-stu-id="c04cb-191">Add a declaration that assigns this property to a local variable:</span></span>

[!code-csharp[Find the semantic information about the string type](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#8 "Use the string literal to access the semantic information in the string type.")]

<span data-ttu-id="c04cb-192">Para finalizar este tutorial, crearemos una consulta LINQ que crea una secuencia de todos los métodos públicos declarados en el tipo `string` que devuelven una `string`.</span><span class="sxs-lookup"><span data-stu-id="c04cb-192">To finish this tutorial, let's build a LINQ query that creates a sequence of all the public methods declared on the `string` type that return a `string`.</span></span> <span data-ttu-id="c04cb-193">Esta consulta es más compleja, así que la compilaremos línea a línea y, después, la volveremos a construir como una única consulta.</span><span class="sxs-lookup"><span data-stu-id="c04cb-193">This query gets complex, so let's build it line by line, then reconstruct it as a single query.</span></span> <span data-ttu-id="c04cb-194">El origen de esta consulta es la secuencia de todos los miembros declarados en el tipo `string`:</span><span class="sxs-lookup"><span data-stu-id="c04cb-194">The source for this query is the sequence of all members declared on the `string` type:</span></span>

[!code-csharp[Access the sequence of members on the string type](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#9 "Access the sequence of members on the string type.")]

<span data-ttu-id="c04cb-195">Esa secuencia de origen contiene todos los miembros, incluidas las propiedades y los campos, de modo que tiene que filtrarlos con el método <xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType> para buscar los elementos que son objetos <xref:Microsoft.CodeAnalysis.IMethodSymbol?diplayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="c04cb-195">That source sequence conatins all members, including properties and fields, so filter it using the <xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType> method to find elements that are <xref:Microsoft.CodeAnalysis.IMethodSymbol?diplayProperty=nameWithType> objects:</span></span>

[!code-csharp[Filter the sequence to only methods](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#10 "Find the subset of the collection that is the methods.")]

<span data-ttu-id="c04cb-196">A continuación, agregue otro filtro para devolver solo aquellos métodos que son públicos y devuelven una `string`:</span><span class="sxs-lookup"><span data-stu-id="c04cb-196">Next, add another filter to return only those methods that are public and return a `string`:</span></span>

[!code-csharp[Filter on return type and accessibility](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#11 "Find only the public methods that return a string.")]

<span data-ttu-id="c04cb-197">Seleccione solo la propiedad name y solo los nombres distintos; para ello, elimine las sobrecargas:</span><span class="sxs-lookup"><span data-stu-id="c04cb-197">Select only the name property, and only distinct names by removing any overloads:</span></span>

[!code-csharp[find the distinct names.](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#12 "Use the string literal to access the semantic information in the string type.")]

<span data-ttu-id="c04cb-198">También puede compilar la consulta completa con la sintaxis de consulta LINQ y, después, mostrar todos los nombres de método en la consola:</span><span class="sxs-lookup"><span data-stu-id="c04cb-198">You can also build the full query using the LINQ query syntax, and then display all the method names in  the console:</span></span>

[!code-csharp[build and display the results of this query.](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#12 "Build and display the results of the query.")]

<span data-ttu-id="c04cb-199">Compile y ejecute el programa.</span><span class="sxs-lookup"><span data-stu-id="c04cb-199">Build and run the program.</span></span> <span data-ttu-id="c04cb-200">Debería ver los siguientes resultados:</span><span class="sxs-lookup"><span data-stu-id="c04cb-200">You should see the following output:</span></span>

```
Join
Substring
Trim
TrimStart
TrimEnd
Normalize
PadLeft
PadRight
ToLower
ToLowerInvariant
ToUpper
ToUpperInvariant
ToString
Insert
Replace
Remove
Format
Copy
Concat
Intern
IsInterned
Press any key to continue . . .
```
<span data-ttu-id="c04cb-201">Ha usado la API semántica para buscar y mostrar información sobre los símbolos que forman parte de este programa.</span><span class="sxs-lookup"><span data-stu-id="c04cb-201">You've used the Semantic API to find and display information about the symbols that are part of this program.</span></span>
