---
title: Paseo por .NET
description: "Un paseo guiado a través de algunas de las características más importantes de .NET."
keywords: ".NET, .NET Core, Paseo, Lenguajes de programación, Unsafe, Administración de memoria, Seguridad de tipos, Asincrónico"
author: cartermp
ms.author: wiwagn
ms.date: 05/22/2017
ms.topic: article
ms.prod: .net
ms.technology: dotnet-standard
ms.devlang: dotnet
ms.assetid: bbfe6465-329d-4982-869d-472e7ef85d93
ms.openlocfilehash: 809f0eaddf298b0d6a57e217c2bcf5450675c3e9
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 10/18/2017
---
# <a name="tour-of-net"></a><span data-ttu-id="ee814-104">Paseo por .NET</span><span class="sxs-lookup"><span data-stu-id="ee814-104">Tour of .NET</span></span>

<span data-ttu-id="ee814-105">.NET es una plataforma de desarrollo de uso general.</span><span class="sxs-lookup"><span data-stu-id="ee814-105">.NET is a general purpose development platform.</span></span> <span data-ttu-id="ee814-106">Tiene varias características clave, como la compatibilidad con varios lenguajes de programación, modelos de programación asincrónica y simultánea e interoperabilidad nativa, que permiten una amplia variedad de escenarios en diversas plataformas.</span><span class="sxs-lookup"><span data-stu-id="ee814-106">It has several key features, such as support for multiple programming languages, asynchronous and concurrent programming models, and native interoperability, which enable a wide range of scenarios across multiple platforms.</span></span>

<span data-ttu-id="ee814-107">En este artículo, se ofrece un paseo guiado por algunas de las características clave de .NET.</span><span class="sxs-lookup"><span data-stu-id="ee814-107">This article offers a guided tour through some of the key features of the .NET.</span></span> <span data-ttu-id="ee814-108">Consulte el tema [Componentes de la arquitectura .NET](components.md) para obtener más información sobre las piezas de arquitectura de .NET y para qué se usan.</span><span class="sxs-lookup"><span data-stu-id="ee814-108">See the [.NET Architectural Components](components.md) topic to learn about the architectural pieces of .NET and what they're used for.</span></span>

## <a name="how-to-run-the-code-samples"></a><span data-ttu-id="ee814-109">Ejecución de ejemplos de código</span><span class="sxs-lookup"><span data-stu-id="ee814-109">How to run the code samples</span></span>

<span data-ttu-id="ee814-110">Para obtener más información sobre cómo configurar un entorno de desarrollo para ejecutar los ejemplos de código, consulte el tema [Introducción](get-started.md).</span><span class="sxs-lookup"><span data-stu-id="ee814-110">To learn how to set up a development environment to run the code samples, see the [Getting Started](get-started.md) topic.</span></span> <span data-ttu-id="ee814-111">Copie y pegue los ejemplos de código de esta página en su entorno para ejecutarlos.</span><span class="sxs-lookup"><span data-stu-id="ee814-111">Copy and paste code samples from this page into your environment to execute them.</span></span> 

## <a name="programming-languages"></a><span data-ttu-id="ee814-112">Lenguajes de programación</span><span class="sxs-lookup"><span data-stu-id="ee814-112">Programming languages</span></span>

<span data-ttu-id="ee814-113">.NET admite varios lenguajes de programación.</span><span class="sxs-lookup"><span data-stu-id="ee814-113">.NET supports multiple programming languages.</span></span> <span data-ttu-id="ee814-114">Las implementaciones de .NET implementan [Common Language Infrastructure (CLI)](https://www.visualstudio.com/license-terms/ecma-c-common-language-infrastructure-standards/), que, entre otras cosas, especifica un entorno de ejecución independiente del lenguaje y la interoperabilidad del lenguaje.</span><span class="sxs-lookup"><span data-stu-id="ee814-114">The .NET implementations implement the [Common Language Infrastructure (CLI)](https://www.visualstudio.com/license-terms/ecma-c-common-language-infrastructure-standards/), which among other things specifies a language-independent runtime and language interoperability.</span></span> <span data-ttu-id="ee814-115">Esto significa que elige cualquier lenguaje .NET para crear aplicaciones y servicios en .NET.</span><span class="sxs-lookup"><span data-stu-id="ee814-115">This means that you choose any .NET language to build apps and services on .NET.</span></span>

<span data-ttu-id="ee814-116">Microsoft desarrolla activamente y admite tres lenguajes .NET: C#, F# y Visual Basic (VB).</span><span class="sxs-lookup"><span data-stu-id="ee814-116">Microsoft actively develops and supports three .NET languages: C#, F#, and Visual Basic (VB).</span></span> 

* <span data-ttu-id="ee814-117">C# es simple, eficaz, incluye seguridad de tipos y está orientado a objetos, al mismo tiempo que mantiene la expresividad y elegancia de los lenguajes de estilo C.</span><span class="sxs-lookup"><span data-stu-id="ee814-117">C# is simple, powerful, type-safe, and object-oriented, while retaining the expressiveness and elegance of C-style languages.</span></span> <span data-ttu-id="ee814-118">Cualquiera que esté familiarizado con C y lenguajes similares, encuentra pocos problemas para adaptarse a C#.</span><span class="sxs-lookup"><span data-stu-id="ee814-118">Anyone familiar with C and similar languages finds few problems in adapting to C#.</span></span> <span data-ttu-id="ee814-119">Consulte la [Guía de C#](../csharp/index.md) para más información sobre C#.</span><span class="sxs-lookup"><span data-stu-id="ee814-119">Check out the [C# Guide](../csharp/index.md) to learn more about C#.</span></span>

* <span data-ttu-id="ee814-120">F # es un lenguaje de programación multiplataforma, principalmente funcional, que también admite la programación tradicional imperativa y orientada en objetos.</span><span class="sxs-lookup"><span data-stu-id="ee814-120">F# is a cross-platform, functional-first programming language that also supports traditional object-oriented and imperative programming.</span></span> <span data-ttu-id="ee814-121">Consulte la [Guía de F #](../fsharp/index.md) para más información sobre F #.</span><span class="sxs-lookup"><span data-stu-id="ee814-121">Check out the [F# Guide](../fsharp/index.md) to learn more about F#.</span></span>

* <span data-ttu-id="ee814-122">Visual Basic es un lenguaje fácil de aprender que se usa para crear una gran variedad de aplicaciones que se ejecutan en .NET.</span><span class="sxs-lookup"><span data-stu-id="ee814-122">Visual Basic is an easy language to learn that you use to build a variety of apps that run on .NET.</span></span> <span data-ttu-id="ee814-123">Entre los lenguajes .NET, la sintaxis de VB es la más cercana al idioma normal, lo que a menudo facilita el trabajo a las personas sin experiencia en desarrollo de software.</span><span class="sxs-lookup"><span data-stu-id="ee814-123">Among the .NET languages, the syntax of VB is the closest to ordinary human language, often making it easier for people new to software development.</span></span>

## <a name="automatic-memory-management"></a><span data-ttu-id="ee814-124">Administración de memoria automática</span><span class="sxs-lookup"><span data-stu-id="ee814-124">Automatic memory management</span></span>

<span data-ttu-id="ee814-125">.NET usa la [recolección de elementos no utilizados](garbagecollection/index.md) para proporcionar administración automática de memoria para los programas.</span><span class="sxs-lookup"><span data-stu-id="ee814-125">.NET uses [garbage collection (GC)](garbagecollection/index.md) to provide automatic memory management for programs.</span></span> <span data-ttu-id="ee814-126">La GC funciona con un enfoque diferido para la administración de memoria y prefiere el rendimiento de la aplicación sobre la recolección inmediata de la memoria.</span><span class="sxs-lookup"><span data-stu-id="ee814-126">The GC operates on a lazy approach to memory management, preferring app throughput to the immediate collection of memory.</span></span> <span data-ttu-id="ee814-127">Para más información sobre GC de .NET, consulte [Fundamentals of garbage collection (GC)](garbagecollection/fundamentals.md) (Fundamentos de la recolección de elementos no utilizados [GC]).</span><span class="sxs-lookup"><span data-stu-id="ee814-127">To learn more about the .NET GC, check out [Fundamentals of garbage collection (GC)](garbagecollection/fundamentals.md).</span></span>

<span data-ttu-id="ee814-128">Las dos líneas siguientes asignan memoria:</span><span class="sxs-lookup"><span data-stu-id="ee814-128">The following two lines both allocate memory:</span></span>

[!code-csharp[MemoryManagement](../../samples/csharp/snippets/tour/MemoryManagement.csx#L1-L2)]

<span data-ttu-id="ee814-129">No hay ninguna palabra clave análoga para anular la asignación de memoria, ya que la anulación de la asignación se realiza automáticamente cuando el recolector de elementos no utilizados reclama la memoria a través de su ejecución programada.</span><span class="sxs-lookup"><span data-stu-id="ee814-129">There's no analogous keyword to de-allocate memory, as de-allocation happens automatically when the garbage collector reclaims the memory through its scheduled run.</span></span>

<span data-ttu-id="ee814-130">El recolector de elementos no utilizados es uno de los servicios que ayudan a garantizar la *protección de la memoria*.</span><span class="sxs-lookup"><span data-stu-id="ee814-130">The garbage collector is one of the services that help ensure *memory safety*.</span></span> <span data-ttu-id="ee814-131">Un programa tiene protección de la memoria si tiene acceso solo a la memoria asignada.</span><span class="sxs-lookup"><span data-stu-id="ee814-131">A program is memory safe if it accesses only allocated memory.</span></span> <span data-ttu-id="ee814-132">Por ejemplo, el entorno de ejecución garantiza que una aplicación no accede a memoria sin asignar más allá de los límites de una matriz.</span><span class="sxs-lookup"><span data-stu-id="ee814-132">For instance, the runtime ensures that an app doesn't access unallocated memory beyond the bounds of an array.</span></span>

<span data-ttu-id="ee814-133">En el ejemplo siguiente, el entorno de ejecución devuelve una excepción `InvalidIndexException` para activar la protección de la memoria:</span><span class="sxs-lookup"><span data-stu-id="ee814-133">In the following example, the runtime throws an `InvalidIndexException` exception to enforce memory safety:</span></span>

[!code-csharp[MemoryManagement](../../samples/csharp/snippets/tour/MemoryManagement.csx#L4-L5)]

## <a name="working-with-unmanaged-resources"></a><span data-ttu-id="ee814-134">Trabajar con recursos no administrados</span><span class="sxs-lookup"><span data-stu-id="ee814-134">Working with unmanaged resources</span></span>

<span data-ttu-id="ee814-135">Algunos objetos hacen referencia a *recursos no administrados*.</span><span class="sxs-lookup"><span data-stu-id="ee814-135">Some objects reference *unmanaged resources*.</span></span> <span data-ttu-id="ee814-136">Los recursos no administrados son recursos que el entorno de ejecución .NET no mantiene de forma automática.</span><span class="sxs-lookup"><span data-stu-id="ee814-136">Unmanaged resources are resources that aren't automatically maintained by the .NET runtime.</span></span> <span data-ttu-id="ee814-137">Por ejemplo, un identificador de archivo es un recurso no administrado.</span><span class="sxs-lookup"><span data-stu-id="ee814-137">For example, a file handle is an unmanaged resource.</span></span> <span data-ttu-id="ee814-138">Un objeto <xref:System.IO.FileStream> es un objeto administrado, pero hace referencia a un identificador de archivo, que es uno no administrado.</span><span class="sxs-lookup"><span data-stu-id="ee814-138">A <xref:System.IO.FileStream> object is a managed object, but it references a file handle, which is unmanaged.</span></span> <span data-ttu-id="ee814-139">Cuando haya acabado de usar <xref:System.IO.FileStream>, deberá liberar el identificador de archivo.</span><span class="sxs-lookup"><span data-stu-id="ee814-139">When you're done using the <xref:System.IO.FileStream>, you need to release the file handle.</span></span>

<span data-ttu-id="ee814-140">En .NET, los objetos que hacen referencia a recursos no administrados implementan la interfaz de <xref:System.IDisposable>.</span><span class="sxs-lookup"><span data-stu-id="ee814-140">In .NET, objects that reference unmanaged resources implement the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="ee814-141">Cuando haya acabado de usar el objeto, deberá llamar al método <xref:System.IDisposable.Dispose> del objeto, que es el responsable de liberar cualquier recurso no administrado.</span><span class="sxs-lookup"><span data-stu-id="ee814-141">When you're done using the object, you call the object's <xref:System.IDisposable.Dispose> method, which is responsible for releasing any unmanaged resources.</span></span> <span data-ttu-id="ee814-142">Los lenguajes .NET ofrecen una sintaxis `using` muy útil para esos objetos, como se muestra en el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="ee814-142">.NET languages provide a convenient `using` syntax for such objects, as shown in the following example:</span></span>

[!code-csharp[UnmanagedResources](../../samples/csharp/snippets/tour/UnmanagedResources.csx#L1-L6)]

<span data-ttu-id="ee814-143">Cuando el bloque `using` se completa, el entorno de ejecución .NET llama automáticamente al método <xref:System.IDisposable.Dispose> del objeto `stream`, que libera el identificador de archivo.</span><span class="sxs-lookup"><span data-stu-id="ee814-143">Once the `using` block completes, the .NET runtime automatically calls the `stream` object's <xref:System.IDisposable.Dispose> method, which releases the file handle.</span></span> <span data-ttu-id="ee814-144">El entorno de ejecución también sigue el mismo procedimiento en caso de que una excepción provoque que el control abandone el bloque.</span><span class="sxs-lookup"><span data-stu-id="ee814-144">The runtime also does this if an exception causes control to leave the block.</span></span>

<span data-ttu-id="ee814-145">Para obtener más información, consulte los siguientes temas:</span><span class="sxs-lookup"><span data-stu-id="ee814-145">For more details, see the following topics:</span></span>

* <span data-ttu-id="ee814-146">Para C#, vea el tema [using (Instrucción, Referencia de C#)](../csharp/language-reference/keywords/using-statement.md).</span><span class="sxs-lookup"><span data-stu-id="ee814-146">For C#, see the [using Statement (C# Reference)](../csharp/language-reference/keywords/using-statement.md) topic.</span></span>
* <span data-ttu-id="ee814-147">Para F#, vea [Resource Management: The use Keyword](../fsharp/language-reference/resource-management-the-use-keyword.md) (Administración de recursos: palabra clave use).</span><span class="sxs-lookup"><span data-stu-id="ee814-147">For F#, see [Resource Management: The use Keyword](../fsharp/language-reference/resource-management-the-use-keyword.md).</span></span>
* <span data-ttu-id="ee814-148">Para VB, vea el tema [Using Statement (Visual Basic)](../visual-basic/language-reference/statements/using-statement.md) [using (Instrucción, Visual Basic)].</span><span class="sxs-lookup"><span data-stu-id="ee814-148">For VB, see the [Using Statement (Visual Basic)](../visual-basic/language-reference/statements/using-statement.md) topic.</span></span>

## <a name="type-safety"></a><span data-ttu-id="ee814-149">Seguridad de tipos</span><span class="sxs-lookup"><span data-stu-id="ee814-149">Type safety</span></span>

<span data-ttu-id="ee814-150">Un objeto es una instancia de un tipo específico.</span><span class="sxs-lookup"><span data-stu-id="ee814-150">An object is an instance of a specific type.</span></span> <span data-ttu-id="ee814-151">Las únicas operaciones permitidas para un objeto determinado son las de su tipo.</span><span class="sxs-lookup"><span data-stu-id="ee814-151">The only operations allowed for a given object are those of its type.</span></span> <span data-ttu-id="ee814-152">Un tipo `Dog` puede tener métodos `Jump` y `WagTail`, pero no un método `SumTotal`.</span><span class="sxs-lookup"><span data-stu-id="ee814-152">A `Dog` type may have `Jump` and `WagTail` methods but not a `SumTotal` method.</span></span> <span data-ttu-id="ee814-153">Un programa solo llama a los métodos que pertenecen a un tipo determinado.</span><span class="sxs-lookup"><span data-stu-id="ee814-153">A program only calls the methods belonging to a given type.</span></span> <span data-ttu-id="ee814-154">Todas las demás llamadas producirán un error en tiempo de compilación o una excepción en tiempo de ejecución (en el caso de usar características dinámicas o `object`).</span><span class="sxs-lookup"><span data-stu-id="ee814-154">All other calls result in either a compile-time error or a run-time exception (in case of using dynamic features or `object`).</span></span>

<span data-ttu-id="ee814-155">Los lenguajes .NET están orientados a objetos, con las jerarquías de clases base y derivadas.</span><span class="sxs-lookup"><span data-stu-id="ee814-155">.NET languages are object-oriented with hierarchies of base and derived classes.</span></span> <span data-ttu-id="ee814-156">El entorno de ejecución .NET solo permite llamadas y conversiones de objetos que se alineen con la jerarquía de objetos.</span><span class="sxs-lookup"><span data-stu-id="ee814-156">The .NET runtime only allows object casts and calls that align with the object hierarchy.</span></span> <span data-ttu-id="ee814-157">Recuerde que cada tipo definido en cualquier lenguaje .NET se deriva del tipo <xref:System.Object> base.</span><span class="sxs-lookup"><span data-stu-id="ee814-157">Remember that every type defined in any .NET language derives from the base <xref:System.Object> type.</span></span>

[!code-csharp[TypeSafety](../../samples/csharp/snippets/tour/TypeSafety.csx#L19-L23)]

<span data-ttu-id="ee814-158">La seguridad de tipos también se usa para ayudar a aplicar la encapsulación a través de la garantía de la fidelidad de las palabras clave del descriptor de acceso.</span><span class="sxs-lookup"><span data-stu-id="ee814-158">Type safety is also used to help enforce encapsulation by guaranteeing the fidelity of the accessor keywords.</span></span> <span data-ttu-id="ee814-159">Las palabras clave del descriptor de acceso son artefactos que controlan el acceso a los miembros de un tipo determinado a través de otro código.</span><span class="sxs-lookup"><span data-stu-id="ee814-159">Accessor keywords are artifacts which control access to members of a given type by other code.</span></span> <span data-ttu-id="ee814-160">Normalmente se usan para distintos tipos de datos dentro de un tipo, que se usan para administrar su comportamiento.</span><span class="sxs-lookup"><span data-stu-id="ee814-160">These are usually used for various kinds of data within a type that are used to manage its behavior.</span></span>

[!code-csharp[TypeSafety](../../samples/csharp/snippets/tour/TypeSafety.csx#L3-L3)]

<span data-ttu-id="ee814-161">C#, VB y F# admiten la *inferencia de tipo* de variable local.</span><span class="sxs-lookup"><span data-stu-id="ee814-161">C#, VB, and F# support local *type inference*.</span></span> <span data-ttu-id="ee814-162">La inferencia de tipos significa que el compilador deduce el tipo de la expresión en el lado izquierdo a partir de la expresión en el lado derecho.</span><span class="sxs-lookup"><span data-stu-id="ee814-162">Type inference means that the compiler deduces the type of the expression on the left-hand side from the expression on the right-hand side.</span></span> <span data-ttu-id="ee814-163">Esto no significa que la seguridad de tipos se divida o evite.</span><span class="sxs-lookup"><span data-stu-id="ee814-163">This doesn't mean that the type safety is broken or avoided.</span></span> <span data-ttu-id="ee814-164">El tipo resultante tiene un tipo seguro con todo lo que ello implica.</span><span class="sxs-lookup"><span data-stu-id="ee814-164">The resulting type does have a strong type with everything that implies.</span></span> <span data-ttu-id="ee814-165">En el ejemplo anterior, `dog` y `cat` se vuelven a escribir para introducir la inferencia de tipos, y el resto del ejemplo no se ha modificado:</span><span class="sxs-lookup"><span data-stu-id="ee814-165">From the previous example, `dog` and `cat` are rewritten to introduce type inference, and the remainder of the example is unchanged:</span></span>

[!code-csharp[TypeSafety](../../samples/csharp/snippets/tour/TypeSafety.csx#L28-L34)]

<span data-ttu-id="ee814-166">F# tiene incluso más funcionalidades de inferencia de tipos que la inferencia de tipo de variable local o método encontrada en C# y VB.</span><span class="sxs-lookup"><span data-stu-id="ee814-166">F# has even further type inference capabilities than the method-local type inference found in C# and VB.</span></span> <span data-ttu-id="ee814-167">Para obtener más información, consulte [Type Inference](../fsharp/language-reference/type-inference.md) (Inferencia de tipos).</span><span class="sxs-lookup"><span data-stu-id="ee814-167">To learn more, see [Type Inference](../fsharp/language-reference/type-inference.md).</span></span>

## <a name="delegates-and-lambdas"></a><span data-ttu-id="ee814-168">Delegados y expresiones lambda</span><span class="sxs-lookup"><span data-stu-id="ee814-168">Delegates and lambdas</span></span>

<span data-ttu-id="ee814-169">Un delegado se representa mediante una firma de método.</span><span class="sxs-lookup"><span data-stu-id="ee814-169">A delegate is represented by a method signature.</span></span> <span data-ttu-id="ee814-170">Cualquier método con esa firma puede asignarse al delegado y se ejecuta cuando se invoca el delegado.</span><span class="sxs-lookup"><span data-stu-id="ee814-170">Any method with that signature can be assigned to the delegate and is executed when the delegate is invoked.</span></span>

<span data-ttu-id="ee814-171">Los delegados son como los punteros de función de C++, pero tienen seguridad de tipos.</span><span class="sxs-lookup"><span data-stu-id="ee814-171">Delegates are like C++ function pointers except that they're type safe.</span></span> <span data-ttu-id="ee814-172">Son un tipo de método sin conexión en el sistema de tipos de CLR.</span><span class="sxs-lookup"><span data-stu-id="ee814-172">They're a kind of disconnected method within the CLR type system.</span></span> <span data-ttu-id="ee814-173">Los métodos regulares están conectados a una clase y solo se pueden llamar a través de convenciones de llamadas estáticas o de instancias.</span><span class="sxs-lookup"><span data-stu-id="ee814-173">Regular methods are attached to a class and are only directly callable through static or instance calling conventions.</span></span>

<span data-ttu-id="ee814-174">En .NET, los delegados se usan habitualmente en controladores de eventos, en la definición de operaciones asincrónicas y en las expresiones lambda, que son los pilares de LINQ.</span><span class="sxs-lookup"><span data-stu-id="ee814-174">In .NET, delegates are commonly used in event handlers, in defining asynchronous operations, and in lambda expressions, which are a cornerstone of LINQ.</span></span> <span data-ttu-id="ee814-175">Obtenga más información en el tema [Delegados y expresiones lambda](delegates-lambdas.md).</span><span class="sxs-lookup"><span data-stu-id="ee814-175">Learn more in the [Delegates and lambdas](delegates-lambdas.md) topic.</span></span>

## <a name="generics"></a><span data-ttu-id="ee814-176">Genéricos</span><span class="sxs-lookup"><span data-stu-id="ee814-176">Generics</span></span>

<span data-ttu-id="ee814-177">Los genéricos permiten al programador introducir un *parámetro de tipo* al diseñar sus clases, que permite al código de cliente (los usuarios del tipo) especificar el tipo exacto que se debe usar en lugar del parámetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="ee814-177">Generics allow the programmer to introduce a *type parameter* when designing their classes that allows the client code (the users of the type) to specify the exact type to use in place of the type parameter.</span></span>

<span data-ttu-id="ee814-178">Los genéricos se agregaron para ayudar a los programadores a implementar estructuras de datos genéricos.</span><span class="sxs-lookup"><span data-stu-id="ee814-178">Generics were added to help programmers implement generic data structures.</span></span> <span data-ttu-id="ee814-179">Antes de que se agregasen, para que un tipo como `List` fuera genérico, tendría que trabajar con elementos que fueran de tipo `object`.</span><span class="sxs-lookup"><span data-stu-id="ee814-179">Before their arrival in order for a type such as the `List` type to be generic, it would have to work with elements that were of type `object`.</span></span> <span data-ttu-id="ee814-180">Esto tenía varios problemas de rendimiento y semántica, junto con los posibles errores sutiles en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="ee814-180">This had various performance and semantic problems, along with possible subtle runtime errors.</span></span> <span data-ttu-id="ee814-181">Lo más destacado de esto último se produciría cuando una estructura de datos contiene, por ejemplo, enteros y cadenas, y se inicia la excepción `InvalidCastException` al trabajar con los miembros de la lista.</span><span class="sxs-lookup"><span data-stu-id="ee814-181">The most notorious of the latter is when a data structure contains, for instance, both integers and strings, and an `InvalidCastException` is thrown on working with the list's members.</span></span>

<span data-ttu-id="ee814-182">En el siguiente ejemplo, se muestra una ejecución básica de programa mediante una instancia de tipos <xref:System.Collections.Generic.List%601>:</span><span class="sxs-lookup"><span data-stu-id="ee814-182">The following sample shows a basic program running using an instance of <xref:System.Collections.Generic.List%601> types:</span></span>

[!code-csharp[GenericsShort](../../samples/csharp/snippets/tour/GenericsShort.csx)]

<span data-ttu-id="ee814-183">Para obtener más información, consulte el tema [Información general (genéricos) de tipos genéricos](generics.md).</span><span class="sxs-lookup"><span data-stu-id="ee814-183">For more information, see the [Generic types (Generics) overview](generics.md) topic.</span></span>

## <a name="async-programming"></a><span data-ttu-id="ee814-184">Programación asincrónica</span><span class="sxs-lookup"><span data-stu-id="ee814-184">Async programming</span></span>

<span data-ttu-id="ee814-185">La programación asincrónica es un concepto de primera clase en .NET, con compatibilidad asincrónica en el entorno de ejecución, las bibliotecas del marco y las construcciones de lenguaje .NET.</span><span class="sxs-lookup"><span data-stu-id="ee814-185">Async programming is a first-class concept within .NET with async support in the runtime, framework libraries, and .NET language constructs.</span></span> <span data-ttu-id="ee814-186">Internamente, se basa en objetos (como `Task`) que sacan partido del sistema operativo para realizar trabajos dependientes de E/S de la forma más eficaz posible.</span><span class="sxs-lookup"><span data-stu-id="ee814-186">Internally, they're based on objects (such as `Task`), which take advantage of the operating system to perform I/O-bound jobs as efficiently as possible.</span></span>

<span data-ttu-id="ee814-187">Para obtener más información sobre la programación asincrónica en .NET, comience con el tema [Async en profundidad](async.md).</span><span class="sxs-lookup"><span data-stu-id="ee814-187">To learn more about async programming in .NET, start with the [Async overview](async.md) topic.</span></span>

## <a name="language-integrated-query-linq"></a><span data-ttu-id="ee814-188">Language-Integrated Query (LINQ)</span><span class="sxs-lookup"><span data-stu-id="ee814-188">Language Integrated Query (LINQ)</span></span>

<span data-ttu-id="ee814-189">LINQ es un conjunto eficaz de características para C# y VB que permiten escribir código simple y declarativo para operar en los datos.</span><span class="sxs-lookup"><span data-stu-id="ee814-189">LINQ is a powerful set of features for C# and VB that allow you to write simple, declarative code for operating on data.</span></span> <span data-ttu-id="ee814-190">Los datos pueden estar en muchos formatos (como objetos en memoria, una base de datos SQL o un documento XML), pero el código LINQ que escriba normalmente no es diferente según el origen de datos.</span><span class="sxs-lookup"><span data-stu-id="ee814-190">The data can be in many forms (such as in-memory objects, a SQL database, or an XML document), but the LINQ code you write typically doesn't differ by data source.</span></span>

<span data-ttu-id="ee814-191">Para obtener más información y ver algunos ejemplos, consulte el tema [LINQ (Language Integrated Query)](using-linq.md).</span><span class="sxs-lookup"><span data-stu-id="ee814-191">To learn more and see some samples, see the [LINQ (Language Integrated Query)](using-linq.md) topic.</span></span>

## <a name="native-interoperability"></a><span data-ttu-id="ee814-192">Interoperabilidad nativa</span><span class="sxs-lookup"><span data-stu-id="ee814-192">Native interoperability</span></span>

<span data-ttu-id="ee814-193">Cada sistema operativo incluye una interfaz de programación de aplicaciones (API) que proporciona servicios del sistema.</span><span class="sxs-lookup"><span data-stu-id="ee814-193">Every operating system includes an application programming interface (API) that provides system services.</span></span> <span data-ttu-id="ee814-194">.NET proporciona varias maneras de llamar a esas API.</span><span class="sxs-lookup"><span data-stu-id="ee814-194">.NET provides several ways to call those APIs.</span></span>

<span data-ttu-id="ee814-195">La manera principal de crear interoperabilidad nativa es a través de la "invocación de plataforma" o P/Invoke para abreviar, que se admite en las plataformas Linux y Windows.</span><span class="sxs-lookup"><span data-stu-id="ee814-195">The main way to do native interoperability is via "platform invoke" or P/Invoke for short, which is supported across Linux and Windows platforms.</span></span> <span data-ttu-id="ee814-196">Una manera de crear interoperabilidad nativa exclusiva de Windows se conoce como "Interoperabilidad COM", que se usa para trabajar con [componentes COM](https://msdn.microsoft.com/library/bwa2bx93.aspx) en código administrado.</span><span class="sxs-lookup"><span data-stu-id="ee814-196">A Windows-only way of doing native interoperability is known as "COM interop," which is used to work with [COM components](https://msdn.microsoft.com/library/bwa2bx93.aspx) in managed code.</span></span> <span data-ttu-id="ee814-197">Se basa en la infraestructura de P/Invoke, pero funciona de forma ligeramente diferente.</span><span class="sxs-lookup"><span data-stu-id="ee814-197">It's built on top of the P/Invoke infrastructure, but it works in subtly different ways.</span></span>

<span data-ttu-id="ee814-198">La mayoría de la compatibilidad de interoperabilidad de Mono (y, por tanto, de Xamarin) para Java y Objective-C se compila de forma similar, es decir, usan los mismos principios.</span><span class="sxs-lookup"><span data-stu-id="ee814-198">Most of Mono's (and thus Xamarin's) interoperability support for Java and Objective-C are built similarly, that is, they use the same principles.</span></span>

<span data-ttu-id="ee814-199">Obtenga más información sobre la interoperabilidad nativa en el tema [Interoperabilidad nativa](native-interop.md).</span><span class="sxs-lookup"><span data-stu-id="ee814-199">Read more about it native interoperability in the [Native interoperability](native-interop.md) topic.</span></span>

## <a name="unsafe-code"></a><span data-ttu-id="ee814-200">Código no seguro</span><span class="sxs-lookup"><span data-stu-id="ee814-200">Unsafe code</span></span>

<span data-ttu-id="ee814-201">Según la compatibilidad con el lenguaje, CLR le permite tener acceso a memoria nativa y usar la aritmética de punteros a través de código `unsafe`.</span><span class="sxs-lookup"><span data-stu-id="ee814-201">Depending on language support, the CLR lets you access native memory and do pointer arithmetic via `unsafe` code.</span></span> <span data-ttu-id="ee814-202">Estas operaciones son necesarias para determinados algoritmos y para la interoperabilidad del sistema.</span><span class="sxs-lookup"><span data-stu-id="ee814-202">These operations are needed for certain algorithms and system interoperability.</span></span> <span data-ttu-id="ee814-203">Aunque es eficaz, se desaconseja el uso de código no seguro a menos que sea necesario para la interoperabilidad con las API del sistema o para implementar el algoritmo más eficaz.</span><span class="sxs-lookup"><span data-stu-id="ee814-203">Although powerful, use of unsafe code is discouraged unless it's necessary to interop with system APIs or implement the most efficient algorithm.</span></span> <span data-ttu-id="ee814-204">Es posible que el código no seguro no se ejecute del mismo modo en entornos diferentes y que también pierda las ventajas de un recolector de elementos no utilizados y de la seguridad de tipos.</span><span class="sxs-lookup"><span data-stu-id="ee814-204">Unsafe code may not execute the same way in different environments and also loses the benefits of a garbage collector and type safety.</span></span> <span data-ttu-id="ee814-205">Se recomienda limitar y centralizar el código no seguro lo máximo posible, y probar el código a conciencia.</span><span class="sxs-lookup"><span data-stu-id="ee814-205">It's recommended to confine and centralize unsafe code as much as possible and test that code thoroughly.</span></span>

<span data-ttu-id="ee814-206">El ejemplo siguiente es una versión modificada del método `ToString()` desde la clase `StringBuilder`.</span><span class="sxs-lookup"><span data-stu-id="ee814-206">The following example is a modified version of the `ToString()` method from the `StringBuilder` class.</span></span> <span data-ttu-id="ee814-207">Ilustra cómo mediante el código `unsafe` se puede implementar de forma eficiente un algoritmo desplazándose por los fragmentos de memoria directamente:</span><span class="sxs-lookup"><span data-stu-id="ee814-207">It illustrates how using `unsafe` code can efficiently implement an algorithm by moving around chunks of memory directly:</span></span>

[!code-csharp[Unsafe](../../samples/csharp/snippets/tour/Unsafe.csx)]

## <a name="next-steps"></a><span data-ttu-id="ee814-208">Pasos siguientes</span><span class="sxs-lookup"><span data-stu-id="ee814-208">Next steps</span></span>

<span data-ttu-id="ee814-209">Si está interesado en un paseo por las características de C#, consulte [Paseo por C#](../csharp/tour-of-csharp/index.md).</span><span class="sxs-lookup"><span data-stu-id="ee814-209">If you're interested in a tour of C# features, check out [Tour of C#](../csharp/tour-of-csharp/index.md).</span></span>

<span data-ttu-id="ee814-210">Si está interesado en un paseo por las características de F#, consulte [Tour of F#](../fsharp/tour.md) (Paseo por F#).</span><span class="sxs-lookup"><span data-stu-id="ee814-210">If you're interested in a tour of F# features, see [Tour of F#](../fsharp/tour.md).</span></span>

<span data-ttu-id="ee814-211">Si quiere empezar a escribir su propio código, consulte [Introducción](get-started.md).</span><span class="sxs-lookup"><span data-stu-id="ee814-211">If you want to get started with writing code of your own, visit [Getting Started](get-started.md).</span></span>

<span data-ttu-id="ee814-212">Para más información sobre los principales componentes de. NET, consulte [Componentes de la arquitectura .NET](components.md).</span><span class="sxs-lookup"><span data-stu-id="ee814-212">To learn about important components of .NET, check out [.NET Architectural Components](components.md).</span></span>
