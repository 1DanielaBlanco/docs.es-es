---
title: Operaciones de bloqueo
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
- cpp
helpviewer_keywords:
- Interlocked class, about Interlocked class
- threading [.NET Framework], Interlocked class
ms.assetid: cbda7114-c752-4f3e-ada1-b1e8dd262f2b
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 361e618578e836e10cf8655f027bed42eac7affd
ms.sourcegitcommit: efff8f331fd9467f093f8ab8d23a203d6ecb5b60
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 09/01/2018
ms.locfileid: "43393144"
---
# <a name="interlocked-operations"></a><span data-ttu-id="f1ff7-102">Operaciones de bloqueo</span><span class="sxs-lookup"><span data-stu-id="f1ff7-102">Interlocked Operations</span></span>
<span data-ttu-id="f1ff7-103">La clase <xref:System.Threading.Interlocked> proporciona métodos que sincronizan el acceso a una variable que comparten varios subprocesos.</span><span class="sxs-lookup"><span data-stu-id="f1ff7-103">The <xref:System.Threading.Interlocked> class provides methods that synchronize access to a variable that is shared by multiple threads.</span></span> <span data-ttu-id="f1ff7-104">Los subprocesos de distintos procesos pueden usar este mecanismo si la variable está en una memoria compartida.</span><span class="sxs-lookup"><span data-stu-id="f1ff7-104">The threads of different processes can use this mechanism if the variable is in shared memory.</span></span> <span data-ttu-id="f1ff7-105">Las operaciones de bloqueo son atómicas, es decir, toda la operación es una unidad que no se puede interrumpir por otra operación de bloqueo en la misma variable.</span><span class="sxs-lookup"><span data-stu-id="f1ff7-105">Interlocked operations are atomic — that is, the entire operation is a unit that cannot be interrupted by another interlocked operation on the same variable.</span></span> <span data-ttu-id="f1ff7-106">Esto es importante en los sistemas operativos con multithreading preferente, donde se puede suspender un subproceso después de cargar un valor desde una dirección de memoria, pero antes de tener la oportunidad de alterarlo y almacenarlo.</span><span class="sxs-lookup"><span data-stu-id="f1ff7-106">This is important in operating systems with preemptive multithreading, where a thread can be suspended after loading a value from a memory address, but before having the chance to alter it and store it.</span></span>  
  
 <span data-ttu-id="f1ff7-107">La clase <xref:System.Threading.Interlocked> proporciona las siguientes operaciones:</span><span class="sxs-lookup"><span data-stu-id="f1ff7-107">The <xref:System.Threading.Interlocked> class provides the following operations:</span></span>  
  
-   <span data-ttu-id="f1ff7-108">En la versión 2.0 de .NET Framework, el método <xref:System.Threading.Interlocked.Add%2A> agrega un valor entero a una variable y devuelve el valor nuevo de la variable.</span><span class="sxs-lookup"><span data-stu-id="f1ff7-108">In the .NET Framework version 2.0, the <xref:System.Threading.Interlocked.Add%2A> method adds an integer value to a variable and returns the new value of the variable.</span></span>  
  
-   <span data-ttu-id="f1ff7-109">En la versión 2.0 de .NET Framework, el método <xref:System.Threading.Interlocked.Read%2A> lee un valor entero de 64 bits como una operación atómica.</span><span class="sxs-lookup"><span data-stu-id="f1ff7-109">In the .NET Framework version 2.0, the <xref:System.Threading.Interlocked.Read%2A> method reads a 64-bit integer value as an atomic operation.</span></span> <span data-ttu-id="f1ff7-110">Esto resulta útil en los sistemas operativos de 32 bits, en los que leer un entero de 64 bits no es habitualmente una operación atómica.</span><span class="sxs-lookup"><span data-stu-id="f1ff7-110">This is useful on 32-bit operating systems, where reading a 64-bit integer is not ordinarily an atomic operation.</span></span>  
  
-   <span data-ttu-id="f1ff7-111">Los métodos <xref:System.Threading.Interlocked.Increment%2A> y <xref:System.Threading.Interlocked.Decrement%2A> incrementan o disminuyen una variable y devuelven el valor resultante.</span><span class="sxs-lookup"><span data-stu-id="f1ff7-111">The <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A> methods increment or decrement a variable and return the resulting value.</span></span>  
  
-   <span data-ttu-id="f1ff7-112">El método <xref:System.Threading.Interlocked.Exchange%2A> realiza un intercambio atómico del valor en una variable especificada, devolviendo ese valor y reemplazándolo por un valor nuevo.</span><span class="sxs-lookup"><span data-stu-id="f1ff7-112">The <xref:System.Threading.Interlocked.Exchange%2A> method performs an atomic exchange of the value in a specified variable, returning that value and replacing it with a new value.</span></span> <span data-ttu-id="f1ff7-113">En la versión 2.0 de .NET Framework, se puede usar una sobrecarga genérica de este método para realizar este intercambio en una variable de cualquier tipo de referencia.</span><span class="sxs-lookup"><span data-stu-id="f1ff7-113">In the .NET Framework version 2.0, a generic overload of this method can be used to perform this exchange on a variable of any reference type.</span></span> <span data-ttu-id="f1ff7-114">Vea <xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29>.</span><span class="sxs-lookup"><span data-stu-id="f1ff7-114">See <xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29>.</span></span>  
  
-   <span data-ttu-id="f1ff7-115">El método <xref:System.Threading.Interlocked.CompareExchange%2A> también intercambia dos valores, pero en función del resultado de una comparación.</span><span class="sxs-lookup"><span data-stu-id="f1ff7-115">The <xref:System.Threading.Interlocked.CompareExchange%2A> method also exchanges two values, but contingent on the result of a comparison.</span></span> <span data-ttu-id="f1ff7-116">En la versión 2.0 de .NET Framework, se puede usar una sobrecarga genérica de este método para realizar este intercambio en una variable de cualquier tipo de referencia.</span><span class="sxs-lookup"><span data-stu-id="f1ff7-116">In the .NET Framework version 2.0, a generic overload of this method can be used to perform this exchange on a variable of any reference type.</span></span> <span data-ttu-id="f1ff7-117">Vea <xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29>.</span><span class="sxs-lookup"><span data-stu-id="f1ff7-117">See <xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29>.</span></span>  
  
 <span data-ttu-id="f1ff7-118">En los procesadores modernos, los métodos de la clase <xref:System.Threading.Interlocked> habitualmente se pueden implementar con una sola instrucción.</span><span class="sxs-lookup"><span data-stu-id="f1ff7-118">On modern processors, the methods of the <xref:System.Threading.Interlocked> class can often be implemented by a single instruction.</span></span> <span data-ttu-id="f1ff7-119">De este modo, proporcionan una sincronización de rendimiento muy elevado y se pueden usar para crear mecanismos de sincronización de nivel superior, como bloqueos de giro.</span><span class="sxs-lookup"><span data-stu-id="f1ff7-119">Thus, they provide very high-performance synchronization and can be used to build higher-level synchronization mechanisms, like spin locks.</span></span>  
  
 <span data-ttu-id="f1ff7-120">Para consultar un ejemplo que usa las clases <xref:System.Threading.Monitor> y <xref:System.Threading.Interlocked> de forma combinada, vea [Monitors](https://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).</span><span class="sxs-lookup"><span data-stu-id="f1ff7-120">For an example that uses the <xref:System.Threading.Monitor> and <xref:System.Threading.Interlocked> classes in combination, see [Monitors](https://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).</span></span>  
  
## <a name="compareexchange-example"></a><span data-ttu-id="f1ff7-121">Ejemplo de CompareExchange</span><span class="sxs-lookup"><span data-stu-id="f1ff7-121">CompareExchange Example</span></span>  
 <span data-ttu-id="f1ff7-122">El método <xref:System.Threading.Interlocked.CompareExchange%2A> se puede usar para proteger cálculos más complicados que un simple incremento y decremento.</span><span class="sxs-lookup"><span data-stu-id="f1ff7-122">The <xref:System.Threading.Interlocked.CompareExchange%2A> method can be used to protect computations that are more complicated than simple increment and decrement.</span></span> <span data-ttu-id="f1ff7-123">El ejemplo siguiente muestra un método seguro para subprocesos que se agrega a un total acumulado almacenado como número de punto flotante.</span><span class="sxs-lookup"><span data-stu-id="f1ff7-123">The following example demonstrates a thread-safe method that adds to a running total stored as a floating point number.</span></span> <span data-ttu-id="f1ff7-124">(Para números enteros, el método <xref:System.Threading.Interlocked.Add%2A> es una solución más sencilla). Para obtener ejemplos de código completos, vea las sobrecargas de <xref:System.Threading.Interlocked.CompareExchange%2A> que adoptan argumentos de punto flotante de precisión simple y doble precisión (<xref:System.Threading.Interlocked.CompareExchange%28System.Single%40%2CSystem.Single%2CSystem.Single%29> y <xref:System.Threading.Interlocked.CompareExchange%28System.Double%40%2CSystem.Double%2CSystem.Double%29>).</span><span class="sxs-lookup"><span data-stu-id="f1ff7-124">(For integers, the <xref:System.Threading.Interlocked.Add%2A> method is a simpler solution.) For complete code examples, see the overloads of <xref:System.Threading.Interlocked.CompareExchange%2A> that take single-precision and double-precision floating-point arguments (<xref:System.Threading.Interlocked.CompareExchange%28System.Single%40%2CSystem.Single%2CSystem.Single%29> and <xref:System.Threading.Interlocked.CompareExchange%28System.Double%40%2CSystem.Double%2CSystem.Double%29>).</span></span>  
  
 [!code-cpp[Conceptual.Interlocked#1](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.interlocked/cpp/source1.cpp#1)]
 [!code-csharp[Conceptual.Interlocked#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.interlocked/cs/source1.cs#1)]
 [!code-vb[Conceptual.Interlocked#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.interlocked/vb/source1.vb#1)]  
  
## <a name="untyped-overloads-of-exchange-and-compareexchange"></a><span data-ttu-id="f1ff7-125">Sobrecargas de Exchange y CompareExchange sin tipo</span><span class="sxs-lookup"><span data-stu-id="f1ff7-125">Untyped Overloads of Exchange and CompareExchange</span></span>  
 <span data-ttu-id="f1ff7-126">Los métodos <xref:System.Threading.Interlocked.Exchange%2A> y <xref:System.Threading.Interlocked.CompareExchange%2A> tienen sobrecargas que adoptan argumentos de tipo <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="f1ff7-126">The <xref:System.Threading.Interlocked.Exchange%2A> and <xref:System.Threading.Interlocked.CompareExchange%2A> methods have overloads that take arguments of type <xref:System.Object>.</span></span> <span data-ttu-id="f1ff7-127">El primer argumento de cada una de estas sobrecargas es `ref Object` (`ByRef … As Object` en Visual Basic) y la seguridad de tipos requiere que la variable que se transmite a este argumento tenga estrictamente el tipo <xref:System.Object>; no puede simplemente transformar el primer argumento al tipo <xref:System.Object> cuando se llama a estos métodos.</span><span class="sxs-lookup"><span data-stu-id="f1ff7-127">The first argument of each of these overloads is `ref Object` (`ByRef … As Object` in Visual Basic), and type safety requires the variable passed to this argument to be typed strictly as <xref:System.Object>; you cannot simply cast the first argument to type <xref:System.Object> when calling these methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f1ff7-128">En la versión 2.0 de .NET Framework, use las sobrecargas genéricas de los métodos <xref:System.Threading.Interlocked.Exchange%2A> y <xref:System.Threading.Interlocked.CompareExchange%2A> para intercambiar variables fuertemente tipadas.</span><span class="sxs-lookup"><span data-stu-id="f1ff7-128">In the .NET Framework version 2.0, use the generic overloads of the <xref:System.Threading.Interlocked.Exchange%2A> and <xref:System.Threading.Interlocked.CompareExchange%2A> methods to exchange strongly typed variables.</span></span>  
  
 <span data-ttu-id="f1ff7-129">El ejemplo de código siguiente muestra una propiedad de tipo`ClassA` que solo se puede establecer una vez, tal como se podría implementar en la versión 1.0 o 1.1 de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="f1ff7-129">The following code example shows a property of type `ClassA` that can be set only once, as it might be implemented in the .NET Framework version 1.0 or 1.1.</span></span>  
  
 [!code-cpp[Conceptual.Interlocked#2](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.interlocked/cpp/source2.cpp#2)]
 [!code-csharp[Conceptual.Interlocked#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.interlocked/cs/source2.cs#2)]
 [!code-vb[Conceptual.Interlocked#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.interlocked/vb/source2.vb#2)]  
  
## <a name="see-also"></a><span data-ttu-id="f1ff7-130">Vea también</span><span class="sxs-lookup"><span data-stu-id="f1ff7-130">See Also</span></span>  
 <xref:System.Threading.Interlocked>  
 <xref:System.Threading.Monitor>  
 [<span data-ttu-id="f1ff7-131">Subprocesamiento</span><span class="sxs-lookup"><span data-stu-id="f1ff7-131">Threading</span></span>](../../../docs/standard/threading/index.md)  
 [<span data-ttu-id="f1ff7-132">Objetos y características de subprocesos</span><span class="sxs-lookup"><span data-stu-id="f1ff7-132">Threading Objects and Features</span></span>](../../../docs/standard/threading/threading-objects-and-features.md)
