---
title: Información general sobre los primitivos de sincronización
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- synchronization, threads
- threading [.NET Framework],synchronizing threads
- managed threading
ms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 37abcb6b3a8fdf4ef91d5e946a97db7ca1428ce8
ms.sourcegitcommit: 4b6490b2529707627ad77c3a43fbe64120397175
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 09/10/2018
ms.locfileid: "44271304"
---
# <a name="overview-of-synchronization-primitives"></a><span data-ttu-id="d88e6-102">Información general sobre los primitivos de sincronización</span><span class="sxs-lookup"><span data-stu-id="d88e6-102">Overview of Synchronization Primitives</span></span>
<a name="top"></a> <span data-ttu-id="d88e6-103">.NET Framework proporciona un intervalo de primitivas de sincronización para controlar las interacciones de subprocesos y evitar las condiciones de carrera.</span><span class="sxs-lookup"><span data-stu-id="d88e6-103">The .NET Framework provides a range of synchronization primitives for controlling the interactions of threads and avoiding race conditions.</span></span> <span data-ttu-id="d88e6-104">En líneas generales, estas pueden dividirse en tres categorías: operaciones de bloqueos, de señalización y de interbloqueos.</span><span class="sxs-lookup"><span data-stu-id="d88e6-104">These can be roughly divided into three categories: locking, signaling, and interlocked operations.</span></span>  
  
 <span data-ttu-id="d88e6-105">Las categorías no están bien organizadas ni claramente definidas: algunos mecanismos de sincronización tienen características de varias categorías; los eventos que liberan un solo subproceso de cada vez son funcionalmente como bloqueos; la liberación de cualquier bloqueo puede considerarse una señal; y las operaciones de interbloqueos pueden usarse para construir bloqueos.</span><span class="sxs-lookup"><span data-stu-id="d88e6-105">The categories are not tidy nor clearly defined: Some synchronization mechanisms have characteristics of multiple categories; events that release a single thread at a time are functionally like locks; the release of any lock can be thought of as a signal; and interlocked operations can be used to construct locks.</span></span> <span data-ttu-id="d88e6-106">Sin embargo, las categorías siguen siendo útiles.</span><span class="sxs-lookup"><span data-stu-id="d88e6-106">However, the categories are still useful.</span></span>  
  
 <span data-ttu-id="d88e6-107">Es importante recordar que la sincronización de subprocesos es cooperativa.</span><span class="sxs-lookup"><span data-stu-id="d88e6-107">It is important to remember that thread synchronization is cooperative.</span></span> <span data-ttu-id="d88e6-108">Si un solo subproceso omite un mecanismo de sincronización y accede directamente al recurso protegido, ese mecanismo de sincronización no puede ser eficaz.</span><span class="sxs-lookup"><span data-stu-id="d88e6-108">If even one thread bypasses a synchronization mechanism and accesses the protected resource directly, that synchronization mechanism cannot be effective.</span></span>  
  
 <span data-ttu-id="d88e6-109">Esta información general contiene las siguientes secciones:</span><span class="sxs-lookup"><span data-stu-id="d88e6-109">This overview contains the following sections:</span></span>  
  
-   [<span data-ttu-id="d88e6-110">Bloqueo</span><span class="sxs-lookup"><span data-stu-id="d88e6-110">Locking</span></span>](#locking)  
  
-   [<span data-ttu-id="d88e6-111">Señalización</span><span class="sxs-lookup"><span data-stu-id="d88e6-111">Signaling</span></span>](#signaling)  
  
-   [<span data-ttu-id="d88e6-112">Tipos de sincronización ligeros</span><span class="sxs-lookup"><span data-stu-id="d88e6-112">Lightweight Synchronization Types</span></span>](#lightweight_synchronization_types)  
  
-   [<span data-ttu-id="d88e6-113">SpinWait</span><span class="sxs-lookup"><span data-stu-id="d88e6-113">SpinWait</span></span>](#spinwait)  
  
-   [<span data-ttu-id="d88e6-114">Operaciones de bloqueo</span><span class="sxs-lookup"><span data-stu-id="d88e6-114">Interlocked Operations</span></span>](#interlocked_operations)  
  
<a name="locking"></a>   
## <a name="locking"></a><span data-ttu-id="d88e6-115">Bloqueo</span><span class="sxs-lookup"><span data-stu-id="d88e6-115">Locking</span></span>  
 <span data-ttu-id="d88e6-116">Los bloqueos proporcionan el control de un recurso a un subproceso a la vez o a un número especificado de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="d88e6-116">Locks give control of a resource to one thread at a time, or to a specified number of threads.</span></span> <span data-ttu-id="d88e6-117">Un subproceso que solicita un bloqueo exclusivo cuando el bloqueo está en uso se bloquea hasta que el bloqueo esté disponible.</span><span class="sxs-lookup"><span data-stu-id="d88e6-117">A thread that requests an exclusive lock when the lock is in use blocks until the lock becomes available.</span></span>  
  
### <a name="exclusive-locks"></a><span data-ttu-id="d88e6-118">Bloqueos exclusivos</span><span class="sxs-lookup"><span data-stu-id="d88e6-118">Exclusive Locks</span></span>  
 <span data-ttu-id="d88e6-119">La forma más sencilla de bloqueo es la instrucción `lock` en C# y la instrucción `SyncLock` en Visual Basic, que controlan el acceso a un bloque de código.</span><span class="sxs-lookup"><span data-stu-id="d88e6-119">The simplest form of locking is the `lock` statement in C# and the `SyncLock` statement in Visual Basic, which controls access to a block of code.</span></span> <span data-ttu-id="d88e6-120">Con frecuencia, estos bloques se conocen como una sección crítica.</span><span class="sxs-lookup"><span data-stu-id="d88e6-120">Such a block is frequently referred to as a critical section.</span></span> <span data-ttu-id="d88e6-121">La instrucción `lock` se implementa mediante los métodos <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> y <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>, y usa un bloqueo `try…finally` para asegurarse de que se libere el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d88e6-121">The `lock` statement is implemented by using the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> and <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> methods, and it uses a `try…finally` block to ensure that the lock is released.</span></span>  
  
 <span data-ttu-id="d88e6-122">En general, la mejor forma de usar la clase <xref:System.Threading.Monitor> consiste en usar la instrucción `lock` o `SyncLock` para proteger pequeños bloques de código, sin abarcar más de un método.</span><span class="sxs-lookup"><span data-stu-id="d88e6-122">In general, using the `lock` or `SyncLock` statement to protect small blocks of code, never spanning more than a single method, is the best way to use the <xref:System.Threading.Monitor> class.</span></span> <span data-ttu-id="d88e6-123">Aunque eficaz, la clase <xref:System.Threading.Monitor> es propensa a bloqueos huérfanos e interbloqueos.</span><span class="sxs-lookup"><span data-stu-id="d88e6-123">Although powerful, the <xref:System.Threading.Monitor> class is prone to orphan locks and deadlocks.</span></span>  
  
#### <a name="monitor-class"></a><span data-ttu-id="d88e6-124">Clase Monitor</span><span class="sxs-lookup"><span data-stu-id="d88e6-124">Monitor Class</span></span>  
 <span data-ttu-id="d88e6-125">La clase <xref:System.Threading.Monitor> proporciona funcionalidad adicional, que se puede usar junto con la instrucción `lock`:</span><span class="sxs-lookup"><span data-stu-id="d88e6-125">The <xref:System.Threading.Monitor> class provides additional functionality, which can be used in conjunction with the `lock` statement:</span></span>  
  
-   <span data-ttu-id="d88e6-126">El método <xref:System.Threading.Monitor.TryEnter%2A> permite que un subproceso bloqueado en espera del recurso se interrumpa una vez transcurrido un intervalo especificado.</span><span class="sxs-lookup"><span data-stu-id="d88e6-126">The <xref:System.Threading.Monitor.TryEnter%2A> method allows a thread that is blocked waiting for the resource to give up after a specified interval.</span></span> <span data-ttu-id="d88e6-127">Devuelve un valor booleano que indica si la operación se ha realizado correctamente o no, que se puede usar para detectar y evitar posibles interbloqueos.</span><span class="sxs-lookup"><span data-stu-id="d88e6-127">It returns a Boolean value indicating success or failure, which can be used to detect and avoid potential deadlocks.</span></span>  
  
-   <span data-ttu-id="d88e6-128">Un subproceso de una sección crítica llama al método <xref:System.Threading.Monitor.Wait%2A>.</span><span class="sxs-lookup"><span data-stu-id="d88e6-128">The <xref:System.Threading.Monitor.Wait%2A> method is called by a thread in a critical section.</span></span> <span data-ttu-id="d88e6-129">Interrumpe el control del recurso y se bloquea hasta que el recurso esté disponible de nuevo.</span><span class="sxs-lookup"><span data-stu-id="d88e6-129">It gives up control of the resource and blocks until the resource is available again.</span></span>  
  
-   <span data-ttu-id="d88e6-130">Los métodos <xref:System.Threading.Monitor.Pulse%2A> y <xref:System.Threading.Monitor.PulseAll%2A> permiten que un subproceso que está a punto de liberar el bloqueo o de llamar a <xref:System.Threading.Monitor.Wait%2A> ponga uno o varios subprocesos en la cola de subprocesos listos, de modo que puedan adquirir el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d88e6-130">The <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.PulseAll%2A> methods allow a thread that is about to release the lock or to call <xref:System.Threading.Monitor.Wait%2A> to put one or more threads into the ready queue, so that they can acquire the lock.</span></span>  
  
 <span data-ttu-id="d88e6-131">Los tiempos de espera de las sobrecargas del método <xref:System.Threading.Monitor.Wait%2A> permiten a los subprocesos en espera situarse en la cola de subprocesos listos.</span><span class="sxs-lookup"><span data-stu-id="d88e6-131">Timeouts on <xref:System.Threading.Monitor.Wait%2A> method overloads allow waiting threads to escape to the ready queue.</span></span>  
  
 <span data-ttu-id="d88e6-132">La clase <xref:System.Threading.Monitor> puede proporcionar el bloqueo en varios dominios de aplicación si el objeto usado para el bloqueo deriva de <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="d88e6-132">The <xref:System.Threading.Monitor> class can provide locking in multiple application domains if the object used for the lock derives from <xref:System.MarshalByRefObject>.</span></span>  
  
 <span data-ttu-id="d88e6-133"><xref:System.Threading.Monitor> tiene afinidad de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="d88e6-133"><xref:System.Threading.Monitor> has thread affinity.</span></span> <span data-ttu-id="d88e6-134">Es decir, un subproceso que entró el monitor debe salir llamando a <xref:System.Threading.Monitor.Exit%2A> o <xref:System.Threading.Monitor.Wait%2A>.</span><span class="sxs-lookup"><span data-stu-id="d88e6-134">That is, a thread that entered the monitor must exit by calling <xref:System.Threading.Monitor.Exit%2A> or <xref:System.Threading.Monitor.Wait%2A>.</span></span>  
  
 <span data-ttu-id="d88e6-135">La clase <xref:System.Threading.Monitor> no es instanciable.</span><span class="sxs-lookup"><span data-stu-id="d88e6-135">The <xref:System.Threading.Monitor> class is not instantiable.</span></span> <span data-ttu-id="d88e6-136">Sus métodos son estáticos (`Shared` en Visual Basic) y actúan sobre un objeto de bloqueo instanciable.</span><span class="sxs-lookup"><span data-stu-id="d88e6-136">Its methods are static (`Shared` in Visual Basic), and act on an instantiable lock object.</span></span>  
  
 <span data-ttu-id="d88e6-137">Para información conceptual, consulte [Monitores](https://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).</span><span class="sxs-lookup"><span data-stu-id="d88e6-137">For a conceptual overview, see [Monitors](https://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).</span></span>  
  
#### <a name="mutex-class"></a><span data-ttu-id="d88e6-138">Mutex (Clase)</span><span class="sxs-lookup"><span data-stu-id="d88e6-138">Mutex Class</span></span>  
 <span data-ttu-id="d88e6-139">Los subprocesos solicitan <xref:System.Threading.Mutex> llamando a una sobrecarga de su método <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="d88e6-139">Threads request a <xref:System.Threading.Mutex> by calling an overload of its <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="d88e6-140">Se proporcionan sobrecargas con tiempos de espera, para permitir que los subprocesos renuncien a la espera.</span><span class="sxs-lookup"><span data-stu-id="d88e6-140">Overloads with timeouts are provided, to allow threads to give up the wait.</span></span> <span data-ttu-id="d88e6-141">A diferencia de la clase <xref:System.Threading.Monitor>, una exclusión mutua puede ser local o global.</span><span class="sxs-lookup"><span data-stu-id="d88e6-141">Unlike the <xref:System.Threading.Monitor> class, a mutex can be either local or global.</span></span> <span data-ttu-id="d88e6-142">Las exclusiones mutuas globales, también denominadas exclusiones mutuas, son visibles en todo el sistema operativo y se pueden usar para sincronizar subprocesos en varios procesos o dominios de aplicación.</span><span class="sxs-lookup"><span data-stu-id="d88e6-142">Global mutexes, also called named mutexes, are visible throughout the operating system, and can be used to synchronize threads in multiple application domains or processes.</span></span> <span data-ttu-id="d88e6-143">Las exclusiones mutuas locales derivan de <xref:System.MarshalByRefObject> y se pueden usar en los límites del dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="d88e6-143">Local mutexes derive from <xref:System.MarshalByRefObject>, and can be used across application domain boundaries.</span></span>  
  
 <span data-ttu-id="d88e6-144">Además, <xref:System.Threading.Mutex> deriva de <xref:System.Threading.WaitHandle>, lo que significa que se puede usar con los mecanismos de señalización proporcionados por <xref:System.Threading.WaitHandle>, como los métodos <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A> y <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="d88e6-144">In addition, <xref:System.Threading.Mutex> derives from <xref:System.Threading.WaitHandle>, which means that it can be used with the signaling mechanisms provided by <xref:System.Threading.WaitHandle>, such as the <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, and <xref:System.Threading.WaitHandle.SignalAndWait%2A> methods.</span></span>  
  
 <span data-ttu-id="d88e6-145">Al igual que <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> tiene afinidad de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="d88e6-145">Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity.</span></span> <span data-ttu-id="d88e6-146">A diferencia de <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> es un objeto instanciable.</span><span class="sxs-lookup"><span data-stu-id="d88e6-146">Unlike <xref:System.Threading.Monitor>, a <xref:System.Threading.Mutex> is an instantiable object.</span></span>  
  
 <span data-ttu-id="d88e6-147">Para información conceptual, consulte [Exclusiones mutuas](../../../docs/standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="d88e6-147">For a conceptual overview, see [Mutexes](../../../docs/standard/threading/mutexes.md).</span></span>  
  
#### <a name="spinlock-class"></a><span data-ttu-id="d88e6-148">Clase SpinLock</span><span class="sxs-lookup"><span data-stu-id="d88e6-148">SpinLock Class</span></span>  
 <span data-ttu-id="d88e6-149">A partir de [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], puede usar la clase <xref:System.Threading.SpinLock> cuando la sobrecarga requerida por <xref:System.Threading.Monitor> degrade el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="d88e6-149">Starting with the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], you can use the <xref:System.Threading.SpinLock> class when the overhead required by <xref:System.Threading.Monitor> degrades performance.</span></span> <span data-ttu-id="d88e6-150">Cuando <xref:System.Threading.SpinLock> encuentra una sección crítica bloqueada, simplemente gira en un bucle hasta que el bloqueo esté disponible.</span><span class="sxs-lookup"><span data-stu-id="d88e6-150">When <xref:System.Threading.SpinLock> encounters a locked critical section, it simply spins in a loop until the lock becomes available.</span></span> <span data-ttu-id="d88e6-151">Si el bloqueo se mantiene durante un tiempo muy breve, el giro puede proporcionar un mejor rendimiento que el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d88e6-151">If the lock is held for a very short time, spinning can provide better performance than blocking.</span></span> <span data-ttu-id="d88e6-152">Sin embargo, si el bloqueo se mantiene durante más de unas decenas de ciclos, <xref:System.Threading.SpinLock> tiene el mismo rendimiento que <xref:System.Threading.Monitor>, pero usará más ciclos de CPU y, por lo tanto, puede degradar el rendimiento de otros subprocesos o procesos.</span><span class="sxs-lookup"><span data-stu-id="d88e6-152">However, if the lock is held for more than a few tens of cycles, <xref:System.Threading.SpinLock> performs just as well as <xref:System.Threading.Monitor>, but will use more CPU cycles and thus can degrade the performance of other threads or processes.</span></span>  
  
### <a name="other-locks"></a><span data-ttu-id="d88e6-153">Otros bloqueos</span><span class="sxs-lookup"><span data-stu-id="d88e6-153">Other Locks</span></span>  
 <span data-ttu-id="d88e6-154">No hace falta que los bloqueos sean exclusivos.</span><span class="sxs-lookup"><span data-stu-id="d88e6-154">Locks need not be exclusive.</span></span> <span data-ttu-id="d88e6-155">A menudo resulta útil permitir que un número limitado de subprocesos tengan acceso simultáneo a un recurso.</span><span class="sxs-lookup"><span data-stu-id="d88e6-155">It is often useful to allow a limited number of threads concurrent access to a resource.</span></span> <span data-ttu-id="d88e6-156">Los semáforos y los bloqueos de lector y escritor están diseñados para controlar este tipo de acceso a los recursos agrupados.</span><span class="sxs-lookup"><span data-stu-id="d88e6-156">Semaphores and reader-writer locks are designed to control this kind of pooled resource access.</span></span>  
  
#### <a name="readerwriterlock-class"></a><span data-ttu-id="d88e6-157">Clase ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="d88e6-157">ReaderWriterLock Class</span></span>  
 <span data-ttu-id="d88e6-158">La clase <xref:System.Threading.ReaderWriterLockSlim> está pensada para los casos en que un subproceso que cambia los datos (el escritor) debe tener acceso exclusivo a un recurso.</span><span class="sxs-lookup"><span data-stu-id="d88e6-158">The <xref:System.Threading.ReaderWriterLockSlim> class addresses the case where a thread that changes data, the writer, must have exclusive access to a resource.</span></span> <span data-ttu-id="d88e6-159">Cuando el escritor no está activo, cualquier número de lectores puede acceder al recurso (por ejemplo, llamando al método <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>).</span><span class="sxs-lookup"><span data-stu-id="d88e6-159">When the writer is not active, any number of readers can access the resource (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method).</span></span> <span data-ttu-id="d88e6-160">Cuando un subproceso solicita acceso exclusivo (por ejemplo, llamando al método <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>), las solicitudes posteriores del lector se bloquean hasta que todos los lectores existentes salgan del bloqueo y el escritor entre y salga del bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d88e6-160">When a thread requests exclusive access, (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method), subsequent reader requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.</span></span>  
  
 <span data-ttu-id="d88e6-161"><xref:System.Threading.ReaderWriterLockSlim> tiene afinidad de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="d88e6-161"><xref:System.Threading.ReaderWriterLockSlim> has thread affinity.</span></span>  
  
 <span data-ttu-id="d88e6-162">Para información conceptual, consulte [Bloqueos de lector y escritor](../../../docs/standard/threading/reader-writer-locks.md).</span><span class="sxs-lookup"><span data-stu-id="d88e6-162">For a conceptual overview, see [Reader-Writer Locks](../../../docs/standard/threading/reader-writer-locks.md).</span></span>  
  
#### <a name="semaphore-class"></a><span data-ttu-id="d88e6-163">Semaphore (Clase)</span><span class="sxs-lookup"><span data-stu-id="d88e6-163">Semaphore Class</span></span>  
 <span data-ttu-id="d88e6-164">La clase <xref:System.Threading.Semaphore> permite que un número especificado de subprocesos acceda a un recurso.</span><span class="sxs-lookup"><span data-stu-id="d88e6-164">The <xref:System.Threading.Semaphore> class allows a specified number of threads to access a resource.</span></span> <span data-ttu-id="d88e6-165">Los demás subprocesos que soliciten el recurso se bloquearán hasta que un subproceso libere el semáforo.</span><span class="sxs-lookup"><span data-stu-id="d88e6-165">Additional threads requesting the resource block until a thread releases the semaphore.</span></span>  
  
 <span data-ttu-id="d88e6-166">Al igual que la clase <xref:System.Threading.Mutex>, <xref:System.Threading.Semaphore> deriva de <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="d88e6-166">Like the <xref:System.Threading.Mutex> class, <xref:System.Threading.Semaphore> derives from <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="d88e6-167">Asimismo, al igual que <xref:System.Threading.Mutex>, un <xref:System.Threading.Semaphore> puede ser local o global.</span><span class="sxs-lookup"><span data-stu-id="d88e6-167">Also like <xref:System.Threading.Mutex>, a <xref:System.Threading.Semaphore> can be either local or global.</span></span> <span data-ttu-id="d88e6-168">También se puede usar en los límites del dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="d88e6-168">It can be used across application domain boundaries.</span></span>  
  
 <span data-ttu-id="d88e6-169">A diferencia de <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> y <xref:System.Threading.ReaderWriterLock>, <xref:System.Threading.Semaphore> no tiene afinidad de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="d88e6-169">Unlike <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex>, and <xref:System.Threading.ReaderWriterLock>, <xref:System.Threading.Semaphore> does not have thread affinity.</span></span> <span data-ttu-id="d88e6-170">Esto significa que se puede usar en escenarios en los que un subproceso adquiere el semáforo y otro lo libera.</span><span class="sxs-lookup"><span data-stu-id="d88e6-170">This means it can be used in scenarios where one thread acquires the semaphore and another releases it.</span></span>  
  
 <span data-ttu-id="d88e6-171">Para información conceptual, consulte [Semaphore y SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="d88e6-171">For a conceptual overview, see [Semaphore and SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="d88e6-172"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> es un semáforo ligero para la sincronización dentro del límite de un único proceso.</span><span class="sxs-lookup"><span data-stu-id="d88e6-172"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> is a lightweight semaphore for synchronization within a single process boundary.</span></span>  
  
 [<span data-ttu-id="d88e6-173">Volver al principio</span><span class="sxs-lookup"><span data-stu-id="d88e6-173">Back to top</span></span>](#top)  
  
<a name="signaling"></a>   
## <a name="signaling"></a><span data-ttu-id="d88e6-174">Signaling</span><span class="sxs-lookup"><span data-stu-id="d88e6-174">Signaling</span></span>  
 <span data-ttu-id="d88e6-175">La manera más sencilla de esperar una señal de otro subproceso consiste en llamar al método <xref:System.Threading.Thread.Join%2A>, que se bloquea hasta que finaliza el otro subproceso.</span><span class="sxs-lookup"><span data-stu-id="d88e6-175">The simplest way to wait for a signal from another thread is to call the <xref:System.Threading.Thread.Join%2A> method, which blocks until the other thread completes.</span></span> <span data-ttu-id="d88e6-176"><xref:System.Threading.Thread.Join%2A> tiene dos sobrecargas que permiten que el subproceso bloqueado salga de la espera una vez transcurrido un intervalo especificado.</span><span class="sxs-lookup"><span data-stu-id="d88e6-176"><xref:System.Threading.Thread.Join%2A> has two overloads that allow the blocked thread to break out of the wait after a specified interval has elapsed.</span></span>  
  
 <span data-ttu-id="d88e6-177">Los identificadores de espera proporcionan un conjunto mucho más completo de capacidades espera y señalización.</span><span class="sxs-lookup"><span data-stu-id="d88e6-177">Wait handles provide a much richer set of waiting and signaling capabilities.</span></span>  
  
### <a name="wait-handles"></a><span data-ttu-id="d88e6-178">Controladores de espera</span><span class="sxs-lookup"><span data-stu-id="d88e6-178">Wait Handles</span></span>  
 <span data-ttu-id="d88e6-179">Los identificadores de espera derivan de la clase <xref:System.Threading.WaitHandle>, que a su vez deriva de <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="d88e6-179">Wait handles derive from the <xref:System.Threading.WaitHandle> class, which in turn derives from <xref:System.MarshalByRefObject>.</span></span> <span data-ttu-id="d88e6-180">Por lo tanto, los identificadores de espera se pueden usar para sincronizar las actividades de subprocesos en los límites del dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="d88e6-180">Thus, wait handles can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="d88e6-181">Los subprocesos se bloquean en los identificadores de espera llamando al método de instancia <xref:System.Threading.WaitHandle.WaitOne%2A> o a uno de los métodos estáticos <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A> o <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="d88e6-181">Threads block on wait handles by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A> or one of the static methods <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span></span> <span data-ttu-id="d88e6-182">La manera en que se liberan depende del método que se llamase y del tipo de identificadores de espera.</span><span class="sxs-lookup"><span data-stu-id="d88e6-182">How they are released depends on which method was called, and on the kind of wait handles.</span></span>  
  
 <span data-ttu-id="d88e6-183">Para información conceptual, consulte [Identificadores de espera](https://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489).</span><span class="sxs-lookup"><span data-stu-id="d88e6-183">For a conceptual overview, see [Wait Handles](https://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489).</span></span>  
  
#### <a name="event-wait-handles"></a><span data-ttu-id="d88e6-184">Identificadores de espera de evento</span><span class="sxs-lookup"><span data-stu-id="d88e6-184">Event Wait Handles</span></span>  
 <span data-ttu-id="d88e6-185">Los identificadores de espera de evento incluyen la clase <xref:System.Threading.EventWaitHandle> y sus clases derivadas, <xref:System.Threading.AutoResetEvent> y <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="d88e6-185">Event wait handles include the <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="d88e6-186">Los subprocesos se liberan desde un identificador de espera de evento cuando este se señaliza llamando a su método <xref:System.Threading.EventWaitHandle.Set%2A> o mediante el método <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="d88e6-186">Threads are released from an event wait handle when the event wait handle is signaled by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method or by using the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span>  
  
 <span data-ttu-id="d88e6-187">Los identificadores de espera de evento pueden restablecerse automáticamente, como un torniquete que permite el paso de un solo subproceso cada vez que se señala, o bien deben restablecerse manualmente, como una puerta que está cerrada hasta que se señala y, a continuación, queda abierta hasta que alguien la cierra.</span><span class="sxs-lookup"><span data-stu-id="d88e6-187">Event wait handles either reset themselves automatically, like a turnstile that allows only one thread through each time it is signaled, or must be reset manually, like a gate that is closed until signaled and then open until someone closes it.</span></span> <span data-ttu-id="d88e6-188">Tal como indican sus nombres, <xref:System.Threading.AutoResetEvent> y <xref:System.Threading.ManualResetEvent> representan lo primer y lo segundo respectivamente.</span><span class="sxs-lookup"><span data-stu-id="d88e6-188">As their names imply, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> represent the former and latter, respectively.</span></span> <span data-ttu-id="d88e6-189"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> es un evento ligero para la sincronización dentro del límite de un único proceso.</span><span class="sxs-lookup"><span data-stu-id="d88e6-189"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> is a lightweight event for synchronization within a single process boundary.</span></span>  
  
 <span data-ttu-id="d88e6-190"><xref:System.Threading.EventWaitHandle> puede representar cualquier tipo de evento, y puede ser local o global.</span><span class="sxs-lookup"><span data-stu-id="d88e6-190">An <xref:System.Threading.EventWaitHandle> can represent either type of event, and can be either local or global.</span></span> <span data-ttu-id="d88e6-191">Las clases derivadas <xref:System.Threading.AutoResetEvent> y <xref:System.Threading.ManualResetEvent> siempre son locales.</span><span class="sxs-lookup"><span data-stu-id="d88e6-191">The derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> are always local.</span></span>  
  
 <span data-ttu-id="d88e6-192">Los identificadores de espera de evento no tienen afinidad de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="d88e6-192">Event wait handles do not have thread affinity.</span></span> <span data-ttu-id="d88e6-193">Cualquier subproceso puede señalar un identificador de espera de evento.</span><span class="sxs-lookup"><span data-stu-id="d88e6-193">Any thread can signal an event wait handle.</span></span>  
  
 <span data-ttu-id="d88e6-194">Para información conceptual, consulte [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span><span class="sxs-lookup"><span data-stu-id="d88e6-194">For a conceptual overview, see [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
#### <a name="mutex-and-semaphore-classes"></a><span data-ttu-id="d88e6-195">Clases Mutex y Semaphore</span><span class="sxs-lookup"><span data-stu-id="d88e6-195">Mutex and Semaphore Classes</span></span>  
 <span data-ttu-id="d88e6-196">Dado que las clases <xref:System.Threading.Mutex> y <xref:System.Threading.Semaphore> derivan de <xref:System.Threading.WaitHandle>, se pueden usar con los métodos estáticos de <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="d88e6-196">Because the <xref:System.Threading.Mutex> and <xref:System.Threading.Semaphore> classes derive from <xref:System.Threading.WaitHandle>, they can be used with the static methods of <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="d88e6-197">Por ejemplo, un subproceso puede usar el método <xref:System.Threading.WaitHandle.WaitAll%2A> para esperar hasta que las tres circunstancias siguientes sean verdaderas: se señala <xref:System.Threading.EventWaitHandle>, se libera <xref:System.Threading.Mutex> y se libera <xref:System.Threading.Semaphore>.</span><span class="sxs-lookup"><span data-stu-id="d88e6-197">For example, a thread can use the <xref:System.Threading.WaitHandle.WaitAll%2A> method to wait until all three of the following are true: an <xref:System.Threading.EventWaitHandle> is signaled, a <xref:System.Threading.Mutex> is released, and a <xref:System.Threading.Semaphore> is released.</span></span> <span data-ttu-id="d88e6-198">De forma similar, un subproceso puede usar el método <xref:System.Threading.WaitHandle.WaitAny%2A> para esperar hasta que se cumpla alguna de esas condiciones.</span><span class="sxs-lookup"><span data-stu-id="d88e6-198">Similarly, a thread can use the <xref:System.Threading.WaitHandle.WaitAny%2A> method to wait until any one of those conditions is true.</span></span>  
  
 <span data-ttu-id="d88e6-199">En el caso de <xref:System.Threading.Mutex> o <xref:System.Threading.Semaphore>, el hecho de que los señalen significa que los liberan.</span><span class="sxs-lookup"><span data-stu-id="d88e6-199">For a <xref:System.Threading.Mutex> or a <xref:System.Threading.Semaphore>, being signaled means being released.</span></span> <span data-ttu-id="d88e6-200">Si cualquiera de estos tipos se usa como el primer argumento del método <xref:System.Threading.WaitHandle.SignalAndWait%2A>, se libera.</span><span class="sxs-lookup"><span data-stu-id="d88e6-200">If either type is used as the first argument of the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method, it is released.</span></span> <span data-ttu-id="d88e6-201">En el caso de <xref:System.Threading.Mutex>, que tiene afinidad de subprocesos, se produce una excepción si el subproceso que realiza la llamada no posee la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="d88e6-201">In the case of a <xref:System.Threading.Mutex>, which has thread affinity, an exception is thrown if the calling thread does not own the mutex.</span></span> <span data-ttu-id="d88e6-202">Como se indicó anteriormente, los semáforos no tienen afinidad de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="d88e6-202">As noted previously, semaphores do not have thread affinity.</span></span>  
  
#### <a name="barrier"></a><span data-ttu-id="d88e6-203">Barrier</span><span class="sxs-lookup"><span data-stu-id="d88e6-203">Barrier</span></span>  
 <span data-ttu-id="d88e6-204">La clase <xref:System.Threading.Barrier> proporciona una manera de sincronizar cíclicamente varios subprocesos de modo que todos se bloqueen en el mismo punto y esperen a que los demás subprocesos se completen.</span><span class="sxs-lookup"><span data-stu-id="d88e6-204">The <xref:System.Threading.Barrier> class provides a way to cyclically synchronize multiple threads so that they all block at the same point and wait for all other threads to complete.</span></span> <span data-ttu-id="d88e6-205">Una barrera es útil cuando uno o más subprocesos requieren los resultados de otro subproceso antes de continuar con la siguiente fase de un algoritmo.</span><span class="sxs-lookup"><span data-stu-id="d88e6-205">A barrier is useful when one or more threads require the results of another thread before continuing to the next phase of an algorithm.</span></span> <span data-ttu-id="d88e6-206">Para más información, consulte [Barrier](../../../docs/standard/threading/barrier.md).</span><span class="sxs-lookup"><span data-stu-id="d88e6-206">For more information, see [Barrier](../../../docs/standard/threading/barrier.md).</span></span>  
  
 [<span data-ttu-id="d88e6-207">Volver al principio</span><span class="sxs-lookup"><span data-stu-id="d88e6-207">Back to top</span></span>](#top)  
  
<a name="lightweight_synchronization_types"></a>   
## <a name="lightweight-synchronization-types"></a><span data-ttu-id="d88e6-208">Tipos de sincronización ligeros</span><span class="sxs-lookup"><span data-stu-id="d88e6-208">Lightweight Synchronization Types</span></span>  
 <span data-ttu-id="d88e6-209">A partir de [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], puede usar primitivas de sincronización que proporcionan un rendimiento rápido al evitar el costoso uso de objetos de kernel Win32, como los identificadores de espera, siempre que sea posible.</span><span class="sxs-lookup"><span data-stu-id="d88e6-209">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use synchronization primitives that provide fast performance by avoiding expensive reliance on Win32 kernel objects such as wait handles whenever possible.</span></span> <span data-ttu-id="d88e6-210">En general, debe usar estos tipos cuando los tiempos de espera son cortos y solo cuando los tipos de sincronización originales se probaron y no resultaron satisfactorios.</span><span class="sxs-lookup"><span data-stu-id="d88e6-210">In general, you should use these types when wait times are short and only when the original synchronization types have been tried and found to be unsatisfactory.</span></span> <span data-ttu-id="d88e6-211">Los tipos ligeros no se puede usar en escenarios que requieren comunicación entre procesos.</span><span class="sxs-lookup"><span data-stu-id="d88e6-211">The lightweight types cannot be used in scenarios that require cross-process communication.</span></span>  
  
-   <span data-ttu-id="d88e6-212"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> es una versión ligera de <xref:System.Threading.Semaphore?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d88e6-212"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> is a lightweight version of <xref:System.Threading.Semaphore?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="d88e6-213"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> es una versión ligera de <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d88e6-213"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> is a lightweight version of <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="d88e6-214"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType> representa un evento que se señaliza cuando su recuento es cero.</span><span class="sxs-lookup"><span data-stu-id="d88e6-214"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType> represents an event that becomes signaled when its count is zero.</span></span>  
  
-   <span data-ttu-id="d88e6-215"><xref:System.Threading.Barrier?displayProperty=nameWithType> permite que varios subprocesos se sincronicen entre sí sin necesidad de control por parte un subproceso principal.</span><span class="sxs-lookup"><span data-stu-id="d88e6-215"><xref:System.Threading.Barrier?displayProperty=nameWithType> enables multiple threads to synchronize with one another without requiring control by a master thread.</span></span> <span data-ttu-id="d88e6-216">Una barrera impide que un subproceso continúe hasta que todos los subprocesos hayan alcanzado un punto especificado.</span><span class="sxs-lookup"><span data-stu-id="d88e6-216">A barrier prevents each thread from continuing until all threads have reached a specified point.</span></span>  
  
 [<span data-ttu-id="d88e6-217">Volver al principio</span><span class="sxs-lookup"><span data-stu-id="d88e6-217">Back to top</span></span>](#top)  
  
<a name="spinwait"></a>   
## <a name="spinwait"></a><span data-ttu-id="d88e6-218">SpinWait</span><span class="sxs-lookup"><span data-stu-id="d88e6-218">SpinWait</span></span>  
 <span data-ttu-id="d88e6-219">A partir de [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], se puede usar la estructura <xref:System.Threading.SpinWait?displayProperty=nameWithType> cuando un subproceso tiene que esperar a que se señalice un evento o se cumpla una condición, pero cuando el tiempo de espera real deba ser menor que el tiempo de espera necesario usando un identificador de espera o bloqueando de otro modo el subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="d88e6-219">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use the <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the current thread.</span></span> <span data-ttu-id="d88e6-220">Si usa <xref:System.Threading.SpinWait>, puede especificar un breve período de tiempo para girar durante la espera y después ceder (por ejemplo, esperando o entrando en modo de suspensión) solo si la condición no se cumplió en el tiempo especificado.</span><span class="sxs-lookup"><span data-stu-id="d88e6-220">By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.</span></span>  
  
 [<span data-ttu-id="d88e6-221">Volver al principio</span><span class="sxs-lookup"><span data-stu-id="d88e6-221">Back to top</span></span>](#top)  
  
<a name="interlocked_operations"></a>   
## <a name="interlocked-operations"></a><span data-ttu-id="d88e6-222">Operaciones de bloqueo</span><span class="sxs-lookup"><span data-stu-id="d88e6-222">Interlocked Operations</span></span>  
 <span data-ttu-id="d88e6-223">Las operaciones de interbloqueos son operaciones atómicas simples realizadas en una ubicación de memoria por métodos estáticos de la clase <xref:System.Threading.Interlocked>.</span><span class="sxs-lookup"><span data-stu-id="d88e6-223">Interlocked operations are simple atomic operations performed on a memory location by static methods of the <xref:System.Threading.Interlocked> class.</span></span> <span data-ttu-id="d88e6-224">Esas operaciones atómicas incluyen la adición, el incremento y el decremento, el intercambio, el intercambio condicional en función de una comparación y las operaciones de lectura para los valores de 64 bits en plataformas de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="d88e6-224">Those atomic operations include addition, increment and decrement, exchange, conditional exchange depending on a comparison, and read operations for 64-bit values on 32-bit platforms.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d88e6-225">La garantía de atomicidad está limitada a operaciones individuales; cuando deben realizarse varias operaciones como una unidad, se debe usar un mecanismo de sincronización más general.</span><span class="sxs-lookup"><span data-stu-id="d88e6-225">The guarantee of atomicity is limited to individual operations; when multiple operations must be performed as a unit, a more coarse-grained synchronization mechanism must be used.</span></span>  
  
 <span data-ttu-id="d88e6-226">Aunque ninguna de estas operaciones son bloqueos o señales, se pueden usar para construir bloqueos y señales.</span><span class="sxs-lookup"><span data-stu-id="d88e6-226">Although none of these operations are locks or signals, they can be used to construct locks and signals.</span></span> <span data-ttu-id="d88e6-227">Dado que son nativas para el sistema operativo Windows, las operaciones de interbloqueos son sumamente rápidas.</span><span class="sxs-lookup"><span data-stu-id="d88e6-227">Because they are native to the Windows operating system, interlocked operations are extremely fast.</span></span>  
  
 <span data-ttu-id="d88e6-228">Las operaciones de interbloqueos se pueden usar con garantías de memoria volátil para escribir aplicaciones que poseen una simultaneidad sin bloqueo eficaz.</span><span class="sxs-lookup"><span data-stu-id="d88e6-228">Interlocked operations can be used with volatile memory guarantees to write applications that exhibit powerful non-blocking concurrency.</span></span> <span data-ttu-id="d88e6-229">Sin embargo, requieren una programación de bajo nivel sofisticada, por lo que los bloqueos simples son una mejor opción para la mayoría de los casos.</span><span class="sxs-lookup"><span data-stu-id="d88e6-229">However, they require sophisticated, low-level programming, so for most purposes, simple locks are a better choice.</span></span>  
  
 <span data-ttu-id="d88e6-230">Para información conceptual, consulte [Operaciones de bloqueo](../../../docs/standard/threading/interlocked-operations.md).</span><span class="sxs-lookup"><span data-stu-id="d88e6-230">For a conceptual overview, see [Interlocked Operations](../../../docs/standard/threading/interlocked-operations.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d88e6-231">Vea también</span><span class="sxs-lookup"><span data-stu-id="d88e6-231">See also</span></span>

- [<span data-ttu-id="d88e6-232">Sincronizar datos para subprocesamiento múltiple</span><span class="sxs-lookup"><span data-stu-id="d88e6-232">Synchronizing Data for Multithreading</span></span>](../../../docs/standard/threading/synchronizing-data-for-multithreading.md)  
- <span data-ttu-id="d88e6-233">[Monitors](https://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db) (Clases Monitor)</span><span class="sxs-lookup"><span data-stu-id="d88e6-233">[Monitors](https://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db)</span></span>  
- <span data-ttu-id="d88e6-234">[Mutexes](../../../docs/standard/threading/mutexes.md) (Clases Mutex)</span><span class="sxs-lookup"><span data-stu-id="d88e6-234">[Mutexes](../../../docs/standard/threading/mutexes.md)</span></span>  
- <span data-ttu-id="d88e6-235">[Semaphore and SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md) (Clases Semaphore y SemaphoreSlim)</span><span class="sxs-lookup"><span data-stu-id="d88e6-235">[Semaphore and SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md)</span></span>  
- [<span data-ttu-id="d88e6-236">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="d88e6-236">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span></span>](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)  
- <span data-ttu-id="d88e6-237">[Wait Handles](https://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489) (Clases WaitHandle)</span><span class="sxs-lookup"><span data-stu-id="d88e6-237">[Wait Handles](https://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489)</span></span>  
- <span data-ttu-id="d88e6-238">[Interlocked Operations](../../../docs/standard/threading/interlocked-operations.md) (Operaciones Interlocked)</span><span class="sxs-lookup"><span data-stu-id="d88e6-238">[Interlocked Operations](../../../docs/standard/threading/interlocked-operations.md)</span></span>  
- <span data-ttu-id="d88e6-239">[Reader-Writer Locks](../../../docs/standard/threading/reader-writer-locks.md) (Clase ReaderWriterLockSlim)</span><span class="sxs-lookup"><span data-stu-id="d88e6-239">[Reader-Writer Locks](../../../docs/standard/threading/reader-writer-locks.md)</span></span>  
- <span data-ttu-id="d88e6-240">[Barrier](../../../docs/standard/threading/barrier.md) (Barrera)</span><span class="sxs-lookup"><span data-stu-id="d88e6-240">[Barrier](../../../docs/standard/threading/barrier.md)</span></span>  
- [<span data-ttu-id="d88e6-241">SpinWait</span><span class="sxs-lookup"><span data-stu-id="d88e6-241">SpinWait</span></span>](../../../docs/standard/threading/spinwait.md)  
- [<span data-ttu-id="d88e6-242">SpinLock</span><span class="sxs-lookup"><span data-stu-id="d88e6-242">SpinLock</span></span>](../../../docs/standard/threading/spinlock.md)
