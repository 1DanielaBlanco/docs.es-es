---
title: "Almacenamiento local para el subproceso: Campos estáticos relacionados con subproceso y ranuras de datos"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- threading [.NET Framework], local storage
- threading [.NET Framework], thread-relative static fields
- local thread storage
- TLS
ms.assetid: c633a4dc-a790-4ed1-96b5-f72bd968b284
caps.latest.revision: "13"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 39dd80d378171563f2aadadaa146278e8a417d32
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 11/21/2017
---
# <a name="thread-local-storage-thread-relative-static-fields-and-data-slots"></a><span data-ttu-id="08625-102">Almacenamiento local para el subproceso: Campos estáticos relacionados con subproceso y ranuras de datos</span><span class="sxs-lookup"><span data-stu-id="08625-102">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span>
<span data-ttu-id="08625-103">Puede usar el almacenamiento local de subprocesos administrados (TLS) para almacenar los datos que sea único en un subproceso y dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="08625-103">You can use managed thread local storage (TLS) to store data that is unique to a thread and application domain.</span></span> <span data-ttu-id="08625-104">.NET Framework proporciona dos maneras de utilizar TLS administrado: relacionados con subprocesos estáticas campos y ranuras de datos.</span><span class="sxs-lookup"><span data-stu-id="08625-104">The .NET Framework provides two ways to use managed TLS: thread-relative static fields and data slots.</span></span>  
  
-   <span data-ttu-id="08625-105">Usar campos estáticos relacionados con subprocesos (relacionados con subprocesos `Shared` campos en Visual Basic) si puede anticipar sus necesidades exactas en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="08625-105">Use thread-relative static fields (thread-relative `Shared` fields in Visual Basic) if you can anticipate your exact needs at compile time.</span></span> <span data-ttu-id="08625-106">Campos estáticos relacionados con subprocesos proporcionan el mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="08625-106">Thread-relative static fields provide the best performance.</span></span> <span data-ttu-id="08625-107">También proporcionan las ventajas de la comprobación de tipos en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="08625-107">They also give you the benefits of compile-time type checking.</span></span>  
  
-   <span data-ttu-id="08625-108">Use las ranuras de datos cuando los requisitos reales pueden detectarse en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="08625-108">Use data slots when your actual requirements might be discovered only at run time.</span></span> <span data-ttu-id="08625-109">Las ranuras de datos son más lento y más difícil de usar que los campos estáticos relacionados con subprocesos y datos se almacenan como tipo <xref:System.Object>, por lo que debe convertir al tipo correcto antes de utilizarla.</span><span class="sxs-lookup"><span data-stu-id="08625-109">Data slots are slower and more awkward to use than thread-relative static fields, and data is stored as type <xref:System.Object>, so you must cast it to the correct type before you use it.</span></span>  
  
 <span data-ttu-id="08625-110">En C++ no administrado, use `TlsAlloc` para asignar ranuras de forma dinámica y `__declspec(thread)` para declarar que una variable debería asignarse en almacenamiento de información relacionados con subprocesos.</span><span class="sxs-lookup"><span data-stu-id="08625-110">In unmanaged C++, you use `TlsAlloc` to allocate slots dynamically and `__declspec(thread)` to declare that a variable should be allocated in thread-relative storage.</span></span> <span data-ttu-id="08625-111">Las ranuras estáticas de campos y los datos relacionados con subprocesos proporcionan la versión administrada de este comportamiento.</span><span class="sxs-lookup"><span data-stu-id="08625-111">Thread-relative static fields and data slots provide the managed version of this behavior.</span></span>  
  
 <span data-ttu-id="08625-112">En el [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], puede usar el <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> clase para crear objetos de subprocesos locales que se inicializan de forma diferida cuando primero se consume el objeto.</span><span class="sxs-lookup"><span data-stu-id="08625-112">In the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> class to create thread-local objects that are initialized lazily when the object is first consumed.</span></span> <span data-ttu-id="08625-113">Para obtener más información, vea [Inicialización diferida](../../../docs/framework/performance/lazy-initialization.md).</span><span class="sxs-lookup"><span data-stu-id="08625-113">For more information, see [Lazy Initialization](../../../docs/framework/performance/lazy-initialization.md).</span></span>  
  
## <a name="uniqueness-of-data-in-managed-tls"></a><span data-ttu-id="08625-114">Unicidad de los datos en TLS administrado</span><span class="sxs-lookup"><span data-stu-id="08625-114">Uniqueness of Data in Managed TLS</span></span>  
 <span data-ttu-id="08625-115">Si usas los campos estáticos relacionados con subprocesos y ranuras de datos, datos en TLS administrado sean únicos para la combinación de subproceso y dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="08625-115">Whether you use thread-relative static fields or data slots, data in managed TLS is unique to the combination of thread and application domain.</span></span>  
  
-   <span data-ttu-id="08625-116">Dentro de un dominio de aplicación, un subproceso no puede modificar datos desde otro subproceso, aunque ambos subprocesos utilicen el mismo campo o ranura.</span><span class="sxs-lookup"><span data-stu-id="08625-116">Within an application domain, one thread cannot modify data from another thread, even when both threads use the same field or slot.</span></span>  
  
-   <span data-ttu-id="08625-117">Cuando un subproceso tiene acceso el mismo campo o ranura desde varios dominios de aplicación, se mantiene un valor independiente en cada dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="08625-117">When a thread accesses the same field or slot from multiple application domains, a separate value is maintained in each application domain.</span></span>  
  
 <span data-ttu-id="08625-118">Por ejemplo, si un subproceso establece el valor de un campo estático relacionados con subprocesos, entra en otro dominio de aplicación y, a continuación, recupera el valor del campo, el valor recuperado en el segundo dominio de aplicación difiere del valor en el primer dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="08625-118">For example, if a thread sets the value of a thread-relative static field, enters another application domain, and then retrieves the value of the field, the value retrieved in the second application domain differs from the value in the first application domain.</span></span> <span data-ttu-id="08625-119">Establecer un nuevo valor para el campo en el segundo dominio de aplicación no influye en el valor del campo en el primer dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="08625-119">Setting a new value for the field in the second application domain does not affect the field's value in the first application domain.</span></span>  
  
 <span data-ttu-id="08625-120">De forma similar, cuando un subproceso obtiene la misma ranura de datos con nombre en dos dominios de aplicación diferentes, los datos en el primer dominio de aplicación permanecen independientes de los datos en el segundo dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="08625-120">Similarly, when a thread gets the same named data slot in two different application domains, the data in the first application domain remains independent of the data in the second application domain.</span></span>  
  
## <a name="thread-relative-static-fields"></a><span data-ttu-id="08625-121">Campos estáticos relacionados con subprocesos</span><span class="sxs-lookup"><span data-stu-id="08625-121">Thread-Relative Static Fields</span></span>  
 <span data-ttu-id="08625-122">Si sabe que un elemento de datos siempre es único para una combinación de dominio de aplicación y un subproceso, aplique el <xref:System.ThreadStaticAttribute> de atributo en el campo estático.</span><span class="sxs-lookup"><span data-stu-id="08625-122">If you know that a piece of data is always unique to a thread and application-domain combination, apply the <xref:System.ThreadStaticAttribute> attribute to the static field.</span></span> <span data-ttu-id="08625-123">Utilice el campo como utilizaría cualquier otro campo estático.</span><span class="sxs-lookup"><span data-stu-id="08625-123">Use the field as you would use any other static field.</span></span> <span data-ttu-id="08625-124">Los datos en el campo son únicos para cada subproceso que lo utilice.</span><span class="sxs-lookup"><span data-stu-id="08625-124">The data in the field is unique to each thread that uses it.</span></span>  
  
 <span data-ttu-id="08625-125">Campos estáticos relacionados con subprocesos proporcionan un rendimiento mejor que las ranuras de datos y tienen la ventaja de comprobación de tipos en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="08625-125">Thread-relative static fields provide better performance than data slots and have the benefit of compile-time type checking.</span></span>  
  
 <span data-ttu-id="08625-126">Tenga en cuenta que cualquier código del constructor de clase se ejecutará en el primer subproceso del primer contexto que tenga acceso al campo.</span><span class="sxs-lookup"><span data-stu-id="08625-126">Be aware that any class constructor code will run on the first thread in the first context that accesses the field.</span></span> <span data-ttu-id="08625-127">En todos los demás subprocesos o contextos en el mismo dominio de aplicación, los campos se inicializarán en `null` (`Nothing` en Visual Basic) si son tipos de referencia, o en su valor predeterminado valores si son tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="08625-127">In all other threads or contexts in the same application domain, the fields will be initialized to `null` (`Nothing` in Visual Basic) if they are reference types, or to their default values if they are value types.</span></span> <span data-ttu-id="08625-128">Por lo tanto, no debe confiar en los constructores de clases para inicializar campos estáticos relacionados con subprocesos.</span><span class="sxs-lookup"><span data-stu-id="08625-128">Therefore, you should not rely on class constructors to initialize thread-relative static fields.</span></span> <span data-ttu-id="08625-129">En su lugar, evite inicializar los campos estáticos relacionados con subprocesos y suponga que se hayan inicializado con `null` (`Nothing`) o con sus valores predeterminados.</span><span class="sxs-lookup"><span data-stu-id="08625-129">Instead, avoid initializing thread-relative static fields and assume that they are initialized to `null` (`Nothing`) or to their default values.</span></span>  
  
## <a name="data-slots"></a><span data-ttu-id="08625-130">Ranuras de datos</span><span class="sxs-lookup"><span data-stu-id="08625-130">Data Slots</span></span>  
 <span data-ttu-id="08625-131">.NET Framework proporciona las ranuras de datos dinámicos que son únicas en una combinación de subproceso y dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="08625-131">The .NET Framework provides dynamic data slots that are unique to a combination of thread and application-domain.</span></span> <span data-ttu-id="08625-132">Hay dos tipos de ranuras de datos: con nombre y sin nombre.</span><span class="sxs-lookup"><span data-stu-id="08625-132">There are two types of data slots: named slots and unnamed slots.</span></span> <span data-ttu-id="08625-133">Ambos se implementan utilizando la <xref:System.LocalDataStoreSlot> estructura.</span><span class="sxs-lookup"><span data-stu-id="08625-133">Both are implemented by using the <xref:System.LocalDataStoreSlot> structure.</span></span>  
  
-   <span data-ttu-id="08625-134">Para crear una ranura de datos con nombre, use la <xref:System.Threading.Thread.AllocateNamedDataSlot%2A?displayProperty=nameWithType> o <xref:System.Threading.Thread.GetNamedDataSlot%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="08625-134">To create a named data slot, use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A?displayProperty=nameWithType> or <xref:System.Threading.Thread.GetNamedDataSlot%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="08625-135">Para obtener una referencia a una ranura con nombre existente, pase su nombre a la <xref:System.Threading.Thread.GetNamedDataSlot%2A> método.</span><span class="sxs-lookup"><span data-stu-id="08625-135">To get a reference to an existing named slot, pass its name to the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method.</span></span>  
  
-   <span data-ttu-id="08625-136">Para crear una ranura de datos sin nombre, use la <xref:System.Threading.Thread.AllocateDataSlot%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="08625-136">To create an unnamed data slot, use the <xref:System.Threading.Thread.AllocateDataSlot%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="08625-137">Para ambos con y sin nombre ranuras, use la <xref:System.Threading.Thread.SetData%2A?displayProperty=nameWithType> y <xref:System.Threading.Thread.GetData%2A?displayProperty=nameWithType> métodos para establecer y recuperar la información de la ranura.</span><span class="sxs-lookup"><span data-stu-id="08625-137">For both named and unnamed slots, use the <xref:System.Threading.Thread.SetData%2A?displayProperty=nameWithType> and <xref:System.Threading.Thread.GetData%2A?displayProperty=nameWithType> methods to set and retrieve the information in the slot.</span></span> <span data-ttu-id="08625-138">Se trata de métodos estáticos que siempre actúan en los datos para el subproceso que está ejecutando actualmente en ellos.</span><span class="sxs-lookup"><span data-stu-id="08625-138">These are static methods that always act on the data for the thread that is currently executing them.</span></span>  
  
 <span data-ttu-id="08625-139">Las ranuras con nombre pueden ser conveniente, porque puede recuperar la ranura cuando lo necesite pasando su nombre a la <xref:System.Threading.Thread.GetNamedDataSlot%2A> método, en lugar de mantener una referencia a una ranura sin nombre.</span><span class="sxs-lookup"><span data-stu-id="08625-139">Named slots can be convenient, because you can retrieve the slot when you need it by passing its name to the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method, instead of maintaining a reference to an unnamed slot.</span></span> <span data-ttu-id="08625-140">Sin embargo, si otro componente usa el mismo nombre para su almacenamiento relacionados con subprocesos y un subproceso ejecuta código desde el componente y el otro componente, los dos componentes podrían dañar los datos de todas las demás.</span><span class="sxs-lookup"><span data-stu-id="08625-140">However, if another component uses the same name for its thread-relative storage and a thread executes code from both your component and the other component, the two components might corrupt each other's data.</span></span> <span data-ttu-id="08625-141">(Este escenario se supone que ambos componentes se ejecutan en el mismo dominio de aplicación y que no están diseñados para compartir los mismos datos).</span><span class="sxs-lookup"><span data-stu-id="08625-141">(This scenario assumes that both components are running in the same application domain, and that they are not designed to share the same data.)</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="08625-142">Vea también</span><span class="sxs-lookup"><span data-stu-id="08625-142">See Also</span></span>  
 <xref:System.ContextStaticAttribute>  
 <xref:System.Threading.Thread.GetNamedDataSlot%2A?displayProperty=nameWithType>  
 <xref:System.ThreadStaticAttribute>  
 <xref:System.Runtime.Remoting.Messaging.CallContext>  
 [<span data-ttu-id="08625-143">Subprocesamiento</span><span class="sxs-lookup"><span data-stu-id="08625-143">Threading</span></span>](../../../docs/standard/threading/index.md)
