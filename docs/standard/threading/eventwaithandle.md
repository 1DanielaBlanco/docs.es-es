---
title: EventWaitHandle
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- threading [.NET Framework], EventWaitHandle class
- EventWaitHandle class
- event wait handles [.NET Framework]
- threading [.NET Framework], cross-process synchronization
ms.assetid: 11ee0b38-d663-4617-b793-35eb6c64e9fc
caps.latest.revision: "9"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 1bd248133bd95ff05246eb36a8e250247fd7ed61
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 11/21/2017
---
# <a name="eventwaithandle"></a><span data-ttu-id="48ed5-102">EventWaitHandle</span><span class="sxs-lookup"><span data-stu-id="48ed5-102">EventWaitHandle</span></span>
<span data-ttu-id="48ed5-103">La <xref:System.Threading.EventWaitHandle> clase permite que los subprocesos se comuniquen entre sí mediante señalización y señales de espera.</span><span class="sxs-lookup"><span data-stu-id="48ed5-103">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling and by waiting for signals.</span></span> <span data-ttu-id="48ed5-104">Identificadores de espera de evento (también denominados simplemente como eventos) son controladores de espera que se pueden señalar con el fin de liberar uno o varios subprocesos en espera.</span><span class="sxs-lookup"><span data-stu-id="48ed5-104">Event wait handles (also referred to simply as events) are wait handles that can be signaled in order to release one or more waiting threads.</span></span> <span data-ttu-id="48ed5-105">Cuando se envía una señal, se restablece un identificador de espera de evento manual o automáticamente.</span><span class="sxs-lookup"><span data-stu-id="48ed5-105">After it is signaled, an event wait handle is reset either manually or automatically.</span></span> <span data-ttu-id="48ed5-106">La <xref:System.Threading.EventWaitHandle> clase puede representar cualquier un evento local identificador de espera (evento local) o identificador (denominado el evento o eventos del sistema, visible para todos los procesos) de espera de un evento del sistema con nombre.</span><span class="sxs-lookup"><span data-stu-id="48ed5-106">The <xref:System.Threading.EventWaitHandle> class can represent either a local event wait handle (local event) or a named system event wait handle (named event or system event, visible to all processes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48ed5-107">Identificadores de espera de eventos no son eventos en el sentido en esa palabra en .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="48ed5-107">Event wait handles are not events in the sense usually meant by that word in the .NET Framework.</span></span> <span data-ttu-id="48ed5-108">No existen los delegados ni controladores de eventos implicados.</span><span class="sxs-lookup"><span data-stu-id="48ed5-108">There are no delegates or event handlers involved.</span></span> <span data-ttu-id="48ed5-109">Se utiliza el término "evento" para describirlos porque ha tradicionalmente se conocía como eventos de sistema operativo y que el acto de señalizar el identificador de espera indica a los subprocesos en espera que se ha producido un evento.</span><span class="sxs-lookup"><span data-stu-id="48ed5-109">The word "event" is used to describe them because they have traditionally been referred to as operating-system events, and because the act of signaling the wait handle indicates to waiting threads that an event has occurred.</span></span>  
  
 <span data-ttu-id="48ed5-110">Ambos identificadores de espera de evento local y con nombre use objetos de sincronización del sistema, que están protegidos por <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> contenedores para asegurarse de que se liberan los recursos.</span><span class="sxs-lookup"><span data-stu-id="48ed5-110">Both local and named event wait handles use system synchronization objects, which are protected by <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> wrappers to ensure that the resources are released.</span></span> <span data-ttu-id="48ed5-111">Puede usar el <xref:System.Threading.WaitHandle.Dispose%2A> método para liberar los recursos inmediatamente cuando haya terminado de utilizar el objeto.</span><span class="sxs-lookup"><span data-stu-id="48ed5-111">You can use the <xref:System.Threading.WaitHandle.Dispose%2A> method to free the resources immediately when you have finished using the object.</span></span>  
  
## <a name="event-wait-handles-that-reset-automatically"></a><span data-ttu-id="48ed5-112">Identificadores de espera de evento que se restablecen automáticamente</span><span class="sxs-lookup"><span data-stu-id="48ed5-112">Event Wait Handles That Reset Automatically</span></span>  
 <span data-ttu-id="48ed5-113">Crear un evento de restablecimiento automático especificando <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> cuando se crea el <xref:System.Threading.EventWaitHandle> objeto.</span><span class="sxs-lookup"><span data-stu-id="48ed5-113">You create an automatic reset event by specifying <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="48ed5-114">Como su nombre implica, este evento de sincronización se restablece automáticamente cuando se señala, después de liberar un único subproceso en espera.</span><span class="sxs-lookup"><span data-stu-id="48ed5-114">As its name implies, this synchronization event resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="48ed5-115">Señalar el evento mediante una llamada a su <xref:System.Threading.EventWaitHandle.Set%2A> método.</span><span class="sxs-lookup"><span data-stu-id="48ed5-115">Signal the event by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method.</span></span>  
  
 <span data-ttu-id="48ed5-116">Eventos de restablecimiento automático se utilizan normalmente para proporcionar acceso exclusivo a un recurso a un único subproceso cada vez.</span><span class="sxs-lookup"><span data-stu-id="48ed5-116">Automatic reset events are usually used to provide exclusive access to a resource for a single thread at a time.</span></span> <span data-ttu-id="48ed5-117">Un subproceso solicita el recurso mediante una llamada a la <xref:System.Threading.WaitHandle.WaitOne%2A> método.</span><span class="sxs-lookup"><span data-stu-id="48ed5-117">A thread requests the resource by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="48ed5-118">Si ningún otro subproceso que contenga el identificador de espera, el método devuelve `true` y el subproceso que realiza la llamada tenga el control del recurso.</span><span class="sxs-lookup"><span data-stu-id="48ed5-118">If no other thread is holding the wait handle, the method returns `true` and the calling thread has control of the resource.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="48ed5-119">Al igual que con todos los mecanismos de sincronización, debe asegurarse de que todas las rutas de acceso de código esperen al identificador de espera adecuado antes de obtener acceso a un recurso protegido.</span><span class="sxs-lookup"><span data-stu-id="48ed5-119">As with all synchronization mechanisms, you must ensure that all code paths wait on the appropriate wait handle before accessing a protected resource.</span></span> <span data-ttu-id="48ed5-120">Sincronización de subprocesos es cooperativa.</span><span class="sxs-lookup"><span data-stu-id="48ed5-120">Thread synchronization is cooperative.</span></span>  
  
 <span data-ttu-id="48ed5-121">Si un evento de restablecimiento automático se señaliza cuando no hay ningún subproceso en espera, permanece señalado hasta que un subproceso intente esperar en él.</span><span class="sxs-lookup"><span data-stu-id="48ed5-121">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="48ed5-122">El evento liberará el subproceso y restablecimiento inmediatamente, bloqueando los subprocesos subsiguientes.</span><span class="sxs-lookup"><span data-stu-id="48ed5-122">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
## <a name="event-wait-handles-that-reset-manually"></a><span data-ttu-id="48ed5-123">Identificadores de espera de evento de restablecimiento manual</span><span class="sxs-lookup"><span data-stu-id="48ed5-123">Event Wait Handles That Reset Manually</span></span>  
 <span data-ttu-id="48ed5-124">Crear un evento de restablecimiento manual especificando <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> cuando se crea el <xref:System.Threading.EventWaitHandle> objeto.</span><span class="sxs-lookup"><span data-stu-id="48ed5-124">You create a manual reset event by specifying <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="48ed5-125">Como su nombre implica, este evento de sincronización debe restablecerse manualmente después de que se ha señalado.</span><span class="sxs-lookup"><span data-stu-id="48ed5-125">As its name implies, this synchronization event must be reset manually after it has been signaled.</span></span> <span data-ttu-id="48ed5-126">Hasta que se restablezca, mediante una llamada a su <xref:System.Threading.EventWaitHandle.Reset%2A> método, subprocesos que esperan en el controlador de eventos se ejecutarán inmediatamente, sin bloquearse.</span><span class="sxs-lookup"><span data-stu-id="48ed5-126">Until it is reset, by calling its <xref:System.Threading.EventWaitHandle.Reset%2A> method, threads that wait on the event handle proceed immediately without blocking.</span></span>  
  
 <span data-ttu-id="48ed5-127">Un reinicio manual eventos actúa como la puerta de un establo.</span><span class="sxs-lookup"><span data-stu-id="48ed5-127">A manual reset event acts like the gate of a corral.</span></span> <span data-ttu-id="48ed5-128">Cuando no se señala el evento, bloquean de subprocesos que esperan en él, como los caballos de un establo.</span><span class="sxs-lookup"><span data-stu-id="48ed5-128">When the event is not signaled, threads that wait on it block, like horses in a corral.</span></span> <span data-ttu-id="48ed5-129">Cuando se señala el evento, mediante una llamada a su <xref:System.Threading.EventWaitHandle.Set%2A> método, todos los subprocesos en espera son gratuitas continuar.</span><span class="sxs-lookup"><span data-stu-id="48ed5-129">When the event is signaled, by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, all waiting threads are free to proceed.</span></span> <span data-ttu-id="48ed5-130">El evento permanece señalado hasta que su <xref:System.Threading.EventWaitHandle.Reset%2A> se llama al método.</span><span class="sxs-lookup"><span data-stu-id="48ed5-130">The event remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="48ed5-131">Esto hace que el evento de restablecimiento manual una forma ideal de retener subprocesos que tenga que esperar hasta que un subproceso finaliza una tarea.</span><span class="sxs-lookup"><span data-stu-id="48ed5-131">This makes the manual reset event an ideal way to hold up threads that need to wait until one thread finishes a task.</span></span>  
  
 <span data-ttu-id="48ed5-132">Al igual que los caballos de dejar un establo, consume tiempo de los subprocesos liberados programarse por el sistema operativo y para reanudar la ejecución.</span><span class="sxs-lookup"><span data-stu-id="48ed5-132">Like horses leaving a corral, it takes time for the released threads to be scheduled by the operating system and to resume execution.</span></span> <span data-ttu-id="48ed5-133">Si el <xref:System.Threading.EventWaitHandle.Reset%2A> método se llama antes de que todos los subprocesos han reanudado la ejecución, los subprocesos restantes volverán a bloquearse.</span><span class="sxs-lookup"><span data-stu-id="48ed5-133">If the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called before all the threads have resumed execution, the remaining threads once again block.</span></span> <span data-ttu-id="48ed5-134">Qué reanudar subprocesos y qué subprocesos se bloquean depende de factores aleatorios, como la carga del sistema, el número de subprocesos en espera para el programador y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="48ed5-134">Which threads resume and which threads block depends on random factors like the load on the system, the number of threads waiting for the scheduler, and so on.</span></span> <span data-ttu-id="48ed5-135">Esto no es un problema si el subproceso que señala el evento finaliza tras la señalización, que es el patrón de uso más comunes.</span><span class="sxs-lookup"><span data-stu-id="48ed5-135">This is not a problem if the thread that signals the event ends after signaling, which is the most common usage pattern.</span></span> <span data-ttu-id="48ed5-136">Si desea que el subproceso que señala el evento para iniciar una nueva tarea después de que todos los subprocesos se reanudación en espera, deben bloquear hasta que se reanudación todos los subprocesos en espera.</span><span class="sxs-lookup"><span data-stu-id="48ed5-136">If you want the thread that signaled the event to begin a new task after all the waiting threads have resumed, you must block it until all the waiting threads have resumed.</span></span> <span data-ttu-id="48ed5-137">En caso contrario, se producirá una condición de carrera y el comportamiento del código es imprevisible.</span><span class="sxs-lookup"><span data-stu-id="48ed5-137">Otherwise, you have a race condition, and the behavior of your code is unpredictable.</span></span>  
  
## <a name="features-common-to-automatic-and-manual-events"></a><span data-ttu-id="48ed5-138">Características comunes de eventos automáticos y manuales</span><span class="sxs-lookup"><span data-stu-id="48ed5-138">Features Common to Automatic and Manual Events</span></span>  
 <span data-ttu-id="48ed5-139">Normalmente, uno o varios subprocesos se bloquean en un <xref:System.Threading.EventWaitHandle> hasta que un subproceso desbloqueado llama el <xref:System.Threading.EventWaitHandle.Set%2A> método, lo que libera uno de los subprocesos en espera (en el caso de los eventos de restablecimiento automático) o todos ellos (en el caso de manual eventos de restablecimiento).</span><span class="sxs-lookup"><span data-stu-id="48ed5-139">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, which releases one of the waiting threads (in the case of automatic reset events) or all of them (in the case of manual reset events).</span></span> <span data-ttu-id="48ed5-140">Un subproceso puede señalar un <xref:System.Threading.EventWaitHandle> y, a continuación, bloquearse en ella, como una operación atómica, mediante una llamada a estático <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="48ed5-140">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, as an atomic operation, by calling the static <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="48ed5-141"><xref:System.Threading.EventWaitHandle>objetos que se puedan usar con el método estático <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> y <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> métodos.</span><span class="sxs-lookup"><span data-stu-id="48ed5-141"><xref:System.Threading.EventWaitHandle> objects can be used with the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="48ed5-142">Dado que la <xref:System.Threading.EventWaitHandle> y <xref:System.Threading.Mutex> clases derivan de <xref:System.Threading.WaitHandle>, puede usar ambas clases con estos métodos.</span><span class="sxs-lookup"><span data-stu-id="48ed5-142">Because the <xref:System.Threading.EventWaitHandle> and <xref:System.Threading.Mutex> classes both derive from <xref:System.Threading.WaitHandle>, you can use both classes with these methods.</span></span>  
  
### <a name="named-events"></a><span data-ttu-id="48ed5-143">Eventos con nombre</span><span class="sxs-lookup"><span data-stu-id="48ed5-143">Named Events</span></span>  
 <span data-ttu-id="48ed5-144">El sistema operativo Windows permite que los identificadores de espera de eventos tengan nombres.</span><span class="sxs-lookup"><span data-stu-id="48ed5-144">The Windows operating system allows event wait handles to have names.</span></span> <span data-ttu-id="48ed5-145">Un evento con nombre es todo el sistema.</span><span class="sxs-lookup"><span data-stu-id="48ed5-145">A named event is system wide.</span></span> <span data-ttu-id="48ed5-146">Es decir, una vez que se crea el evento con nombre, es visible para todos los subprocesos de todos los procesos.</span><span class="sxs-lookup"><span data-stu-id="48ed5-146">That is, once the named event is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="48ed5-147">Por lo tanto, los eventos con nombre se pueden utilizar para sincronizar las actividades de procesos, así como de los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="48ed5-147">Thus, named events can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="48ed5-148">Puede crear un <xref:System.Threading.EventWaitHandle> objeto que representa un evento del sistema con nombre mediante el uso de uno de los constructores que especifica un nombre de evento.</span><span class="sxs-lookup"><span data-stu-id="48ed5-148">You can create an <xref:System.Threading.EventWaitHandle> object that represents a named system event by using one of the constructors that specifies an event name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48ed5-149">Dado que los eventos con nombre son todo el sistema, es posible tener varios <xref:System.Threading.EventWaitHandle> evento con nombre en objetos que representan la misma.</span><span class="sxs-lookup"><span data-stu-id="48ed5-149">Because named events are system wide, it is possible to have multiple <xref:System.Threading.EventWaitHandle> objects that represent the same named event.</span></span> <span data-ttu-id="48ed5-150">Cada vez que se llama a un constructor, o la <xref:System.Threading.EventWaitHandle.OpenExisting%2A> /método siguiente, un nuevo <xref:System.Threading.EventWaitHandle> se crea el objeto.</span><span class="sxs-lookup"><span data-stu-id="48ed5-150">Each time you call a constructor, or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, a new <xref:System.Threading.EventWaitHandle> object is created.</span></span> <span data-ttu-id="48ed5-151">Especificar el mismo nombre repetidamente crea varios objetos que representan el mismo evento con nombre.</span><span class="sxs-lookup"><span data-stu-id="48ed5-151">Specifying the same name repeatedly creates multiple objects that represent the same named event.</span></span>  
  
 <span data-ttu-id="48ed5-152">Se recomienda precaución con nombre eventos.</span><span class="sxs-lookup"><span data-stu-id="48ed5-152">Caution is advised in using named events.</span></span> <span data-ttu-id="48ed5-153">Dado que son todo el sistema, otro proceso que usa el mismo nombre puede bloquearse inesperadamente los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="48ed5-153">Because they are system wide, another process that uses the same name can block your threads unexpectedly.</span></span> <span data-ttu-id="48ed5-154">Si hubiera código malintencionado ejecutándose en el mismo equipo, dicho código podría utilizar esto como base de un ataque de denegación de servicio.</span><span class="sxs-lookup"><span data-stu-id="48ed5-154">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="48ed5-155">Utilice la seguridad de control de acceso para proteger un <xref:System.Threading.EventWaitHandle> objeto que representa un evento con nombre, preferiblemente mediante un constructor que especifica un <xref:System.Security.AccessControl.EventWaitHandleSecurity> objeto.</span><span class="sxs-lookup"><span data-stu-id="48ed5-155">Use access control security to protect an <xref:System.Threading.EventWaitHandle> object that represents a named event, preferably by using a constructor that specifies an <xref:System.Security.AccessControl.EventWaitHandleSecurity> object.</span></span> <span data-ttu-id="48ed5-156">También puede aplicar la seguridad de control de acceso mediante el <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> (método), pero esto deja una ventana de vulnerabilidad entre el momento de crea el identificador de espera de evento y la hora en que está protegido.</span><span class="sxs-lookup"><span data-stu-id="48ed5-156">You can also apply access control security using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, but this leaves a window of vulnerability between the time the event wait handle is created and the time it is protected.</span></span> <span data-ttu-id="48ed5-157">La protección de eventos con el control de acceso seguridad ayuda a evitar ataques malintencionados, pero no soluciona el problema de conflictos involuntarios de nombres.</span><span class="sxs-lookup"><span data-stu-id="48ed5-157">Protecting events with access control security helps prevent malicious attacks, but it does not solve the problem of unintentional name collisions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48ed5-158">A diferencia de la <xref:System.Threading.EventWaitHandle> (clase), las clases derivadas <xref:System.Threading.AutoResetEvent> y <xref:System.Threading.ManualResetEvent> puede representar solo local identificadores de espera.</span><span class="sxs-lookup"><span data-stu-id="48ed5-158">Unlike the <xref:System.Threading.EventWaitHandle> class, the derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> can represent only local wait handles.</span></span> <span data-ttu-id="48ed5-159">No se representan eventos del sistema con nombre.</span><span class="sxs-lookup"><span data-stu-id="48ed5-159">They cannot represent named system events.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="48ed5-160">Vea también</span><span class="sxs-lookup"><span data-stu-id="48ed5-160">See Also</span></span>  
 <xref:System.Threading.EventWaitHandle>  
 <xref:System.Threading.WaitHandle>  
 <xref:System.Threading.AutoResetEvent>  
 <xref:System.Threading.ManualResetEvent>  
 [<span data-ttu-id="48ed5-161">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="48ed5-161">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span></span>](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)
