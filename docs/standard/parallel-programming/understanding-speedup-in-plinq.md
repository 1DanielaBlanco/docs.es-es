---
title: "Introducción a la velocidad en PLINQ"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords: PLINQ queries, performance tuning
ms.assetid: 53706c7e-397d-467a-98cd-c0d1fd63ba5e
caps.latest.revision: "14"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: c3373cb6a2c535bd7d42eb062e1f9727952f7cfb
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 10/18/2017
---
# <a name="understanding-speedup-in-plinq"></a><span data-ttu-id="73c3d-102">Introducción a la velocidad en PLINQ</span><span class="sxs-lookup"><span data-stu-id="73c3d-102">Understanding Speedup in PLINQ</span></span>
<span data-ttu-id="73c3d-103">El objetivo principal de PLINQ es acelerar la ejecución de LINQ a consultas de objetos mediante la ejecución de los delegados de consulta en paralelo en equipos de varios núcleos.</span><span class="sxs-lookup"><span data-stu-id="73c3d-103">The primary purpose of PLINQ is to speed up the execution of LINQ to Objects queries by executing the query delegates in parallel on multi-core computers.</span></span> <span data-ttu-id="73c3d-104">PLINQ funciona mejor cuando el procesamiento de cada elemento de una colección de origen es independiente, sin ningún estado compartido implicado entre los delegados individuales.</span><span class="sxs-lookup"><span data-stu-id="73c3d-104">PLINQ performs best when the processing of each element in a source collection is independent, with no shared state involved among the individual delegates.</span></span> <span data-ttu-id="73c3d-105">Estas operaciones son comunes en LINQ to Objects y PLINQ y a menudo se denominan "*perfectamente paralelas*" porque prestan fácilmente a la programación en varios subprocesos.</span><span class="sxs-lookup"><span data-stu-id="73c3d-105">Such operations are common in LINQ to Objects and PLINQ, and are often called "*delightfully parallel*" because they lend themselves easily to scheduling on multiple threads.</span></span> <span data-ttu-id="73c3d-106">Sin embargo, no todas las consultas constan únicamente de operaciones paralelas perfectas; en la mayoría de los casos, una consulta incluye a operadores que no se puede paralelizar cualquiera o que ralentizan la ejecución en paralelo.</span><span class="sxs-lookup"><span data-stu-id="73c3d-106">However, not all queries consist entirely of delightfully parallel operations; in most cases, a query involves some operators that either cannot be parallelized, or that slow down parallel execution.</span></span> <span data-ttu-id="73c3d-107">E incluso con las consultas que son perfectamente paralelas, PLINQ debe crear particiones del origen de datos y programar el trabajo en los subprocesos y generalmente tiene que combinar los resultados cuando finaliza la consulta.</span><span class="sxs-lookup"><span data-stu-id="73c3d-107">And even with queries that are entirely delightfully parallel, PLINQ must still partition the data source and schedule the work on the threads, and usually merge the results when the query completes.</span></span> <span data-ttu-id="73c3d-108">Todas estas operaciones aumentan el costo computacional de la paralelización; se llaman a estos costos de agregar paralelización *sobrecarga*.</span><span class="sxs-lookup"><span data-stu-id="73c3d-108">All these operations add to the computational cost of parallelization; these costs of adding parallelization are called *overhead*.</span></span> <span data-ttu-id="73c3d-109">Para lograr un rendimiento óptimo en una consulta PLINQ, el objetivo es maximizar las partes que son perfectamente paralelas y minimizar las partes que producir una sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="73c3d-109">To achieve optimum performance in a PLINQ query, the goal is to maximize the parts that are delightfully parallel and minimize the parts that require overhead.</span></span> <span data-ttu-id="73c3d-110">Este artículo proporciona información que le ayudará a escribir consultas PLINQ que son tan eficaces como sea posible mientras se sigue produciendo resultados correctos.</span><span class="sxs-lookup"><span data-stu-id="73c3d-110">This article provides information that will help you write PLINQ queries that are as efficient as possible while still yielding correct results.</span></span>  
  
## <a name="factors-that-impact-plinq-query-performance"></a><span data-ttu-id="73c3d-111">Factores que afectan el rendimiento de las consultas PLINQ</span><span class="sxs-lookup"><span data-stu-id="73c3d-111">Factors that Impact PLINQ Query Performance</span></span>  
 <span data-ttu-id="73c3d-112">En las siguientes secciones se enumeran algunos de los factores más importantes que afectan al rendimiento consultas en paralelo.</span><span class="sxs-lookup"><span data-stu-id="73c3d-112">The following sections lists some of the most important factors that impact parallel query performance.</span></span> <span data-ttu-id="73c3d-113">Estas son las instrucciones generales que por sí mismos no son suficientes para predecir el rendimiento de las consultas en todos los casos.</span><span class="sxs-lookup"><span data-stu-id="73c3d-113">These are general statements that by themselves are not sufficient to predict query performance in all cases.</span></span> <span data-ttu-id="73c3d-114">Como siempre, es importante medir el rendimiento real de consultas específicas en equipos con una variedad de cargas y configuraciones representativas.</span><span class="sxs-lookup"><span data-stu-id="73c3d-114">As always, it is important to measure actual performance of specific queries on computers with a range of representative configurations and loads.</span></span>  
  
1.  <span data-ttu-id="73c3d-115">Costo computacional del trabajo total.</span><span class="sxs-lookup"><span data-stu-id="73c3d-115">Computational cost of the overall work.</span></span>  
  
     <span data-ttu-id="73c3d-116">Para lograr una velocidad, una consulta PLINQ debe tener suficiente trabajo perfectamente en paralelo para compensar la sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="73c3d-116">To achieve speedup, a PLINQ query must have enough delightfully parallel work to offset the overhead.</span></span> <span data-ttu-id="73c3d-117">El trabajo se puede expresar como el costo computacional de cada delegado multiplicado por el número de elementos de la colección de origen.</span><span class="sxs-lookup"><span data-stu-id="73c3d-117">The work can be expressed as the computational cost of each delegate multiplied by the number of elements in the source collection.</span></span> <span data-ttu-id="73c3d-118">Suponiendo que una operación puede paralelizar, cuanto más procesamiento costoso es, mayor será la posibilidad de aumentar la velocidad.</span><span class="sxs-lookup"><span data-stu-id="73c3d-118">Assuming that an operation can be parallelized, the more computationally expensive it is, the greater the opportunity for speedup.</span></span> <span data-ttu-id="73c3d-119">Por ejemplo, si una función tarda un milisegundo en ejecutarse, una consulta secuencial de más de 1000 elementos tardará un segundo para realizar esa operación, mientras que una consulta paralela en un equipo con cuatro núcleos puede tardar sólo 250 milisegundos.</span><span class="sxs-lookup"><span data-stu-id="73c3d-119">For example, if a function takes one millisecond to execute, a sequential query over 1000 elements will take one second to perform that operation, whereas a parallel query on a computer with four cores might take only 250 milliseconds.</span></span> <span data-ttu-id="73c3d-120">Esto da como resultado una velocidad de 750 milisegundos.</span><span class="sxs-lookup"><span data-stu-id="73c3d-120">This yields a speedup of 750 milliseconds.</span></span> <span data-ttu-id="73c3d-121">Si la función requiere un segundo ejecutar para cada elemento, la velocidad sería 750 segundos.</span><span class="sxs-lookup"><span data-stu-id="73c3d-121">If the function required one second to execute for each element, then the speedup would be 750 seconds.</span></span> <span data-ttu-id="73c3d-122">Si el delegado es muy caro, PLINQ podría proporcionar un aumento significativo con solo unos pocos elementos de la colección de origen.</span><span class="sxs-lookup"><span data-stu-id="73c3d-122">If the delegate is very expensive, then PLINQ might offer significant speedup with only a few items in the source collection.</span></span> <span data-ttu-id="73c3d-123">Por el contrario, las colecciones de origen pequeñas con delegados triviales generalmente no son buenas candidatas para PLINQ.</span><span class="sxs-lookup"><span data-stu-id="73c3d-123">Conversely, small source collections with trivial delegates are generally not good candidates for PLINQ.</span></span>  
  
     <span data-ttu-id="73c3d-124">En el ejemplo siguiente, queryA es probablemente una buena candidata para PLINQ, suponiendo que su función Select implica mucho trabajo.</span><span class="sxs-lookup"><span data-stu-id="73c3d-124">In the following example, queryA is probably a good candidate for PLINQ, assuming that its Select function involves a lot of work.</span></span> <span data-ttu-id="73c3d-125">queryB no es probablemente una buena candidata porque no hay suficiente trabajo en la instrucción Select y la sobrecarga de la paralelización compensará la mayoría o la totalidad de la velocidad.</span><span class="sxs-lookup"><span data-stu-id="73c3d-125">queryB is probably not a good candidate because there is not enough work in the Select statement, and the overhead of parallelization will offset most or all of the speedup.</span></span>  
  
    ```vb  
    Dim queryA = From num In numberList.AsParallel()  
                 Select ExpensiveFunction(num); 'good for PLINQ  
  
    Dim queryB = From num In numberList.AsParallel()  
                 Where num Mod 2 > 0  
                 Select num; 'not as good for PLINQ  
    ```  
  
    ```csharp  
    var queryA = from num in numberList.AsParallel()  
                 select ExpensiveFunction(num); //good for PLINQ  
  
    var queryB = from num in numberList.AsParallel()  
                 where num % 2 > 0  
                 select num; //not as good for PLINQ  
    ```  
  
2.  <span data-ttu-id="73c3d-126">El número de núcleos lógicos del sistema (grado de paralelismo).</span><span class="sxs-lookup"><span data-stu-id="73c3d-126">The number of logical cores on the system (degree of parallelism).</span></span>  
  
     <span data-ttu-id="73c3d-127">Este punto es un corolario obvio a la sección anterior, las consultas que son perfectamente paralelas ejecutan más rápido en equipos con varios núcleos porque se puede dividir el trabajo entre más subprocesos simultáneos.</span><span class="sxs-lookup"><span data-stu-id="73c3d-127">This point is an obvious corollary to the previous section, queries that are delightfully parallel run faster on machines with more cores because the work can be divided among more concurrent threads.</span></span> <span data-ttu-id="73c3d-128">La cantidad total de velocidad depende de en qué porcentaje del trabajo total de la consulta puede paralelizar.</span><span class="sxs-lookup"><span data-stu-id="73c3d-128">The overall amount of speedup depends on what percentage of the overall work of the query is parallelizable.</span></span> <span data-ttu-id="73c3d-129">Sin embargo, no se da por supuesto que todas las consultas se ejecutarán dos veces más rápido en un equipo de ocho núcleos como un equipo de cuatro núcleos.</span><span class="sxs-lookup"><span data-stu-id="73c3d-129">However, do not assume that all queries will run twice as fast on an eight core computer as a four core computer.</span></span> <span data-ttu-id="73c3d-130">Al optimizar las consultas para un rendimiento óptimo, es importante medir los resultados reales en equipos con varios números de núcleos.</span><span class="sxs-lookup"><span data-stu-id="73c3d-130">When tuning queries for optimal performance, it is important to measure actual results on computers with various numbers of cores.</span></span> <span data-ttu-id="73c3d-131">Este punto se relaciona con el punto #1: conjuntos de datos grandes deben aprovechar las ventajas de la mayor cantidad de recursos informáticos.</span><span class="sxs-lookup"><span data-stu-id="73c3d-131">This point is related to point #1: larger datasets are required to take advantage of greater computing resources.</span></span>  
  
3.  <span data-ttu-id="73c3d-132">El número y tipo de operaciones.</span><span class="sxs-lookup"><span data-stu-id="73c3d-132">The number and kind of operations.</span></span>  
  
     <span data-ttu-id="73c3d-133">PLINQ proporciona el operador AsOrdered para situaciones en las que es necesario mantener el orden de los elementos de la secuencia de origen.</span><span class="sxs-lookup"><span data-stu-id="73c3d-133">PLINQ provides the AsOrdered operator for situations in which it is necessary to maintain the order of elements in the source sequence.</span></span> <span data-ttu-id="73c3d-134">Hay un costo asociado con la ordenación, pero este costo es normalmente moderado.</span><span class="sxs-lookup"><span data-stu-id="73c3d-134">There is a cost associated with ordering, but this cost is usually modest.</span></span> <span data-ttu-id="73c3d-135">Operaciones GroupBy y Join también incurren en sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="73c3d-135">GroupBy and Join operations likewise incur overhead.</span></span> <span data-ttu-id="73c3d-136">PLINQ se comporta mejor si se permite para procesar elementos en la colección de origen en cualquier orden y pasarlos al operador siguiente en cuanto estén listas.</span><span class="sxs-lookup"><span data-stu-id="73c3d-136">PLINQ performs best when it is allowed to process elements in the source collection in any order, and pass them to the next operator as soon as they are ready.</span></span> <span data-ttu-id="73c3d-137">Para más información, consulte cómo [conservar el orden en PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="73c3d-137">For more information, see [Order Preservation in PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span></span>  
  
4.  <span data-ttu-id="73c3d-138">La forma de ejecución de la consulta.</span><span class="sxs-lookup"><span data-stu-id="73c3d-138">The form of query execution.</span></span>  
  
     <span data-ttu-id="73c3d-139">Si va a almacenar los resultados de una consulta llamando a ToArray o ToList, los resultados de todos los subprocesos paralelos deben combinarse en la estructura de datos único.</span><span class="sxs-lookup"><span data-stu-id="73c3d-139">If you are storing the results of a query by calling ToArray or ToList, then the results from all parallel threads must be merged into the single data structure.</span></span> <span data-ttu-id="73c3d-140">Esto implica un costo computacional inevitable.</span><span class="sxs-lookup"><span data-stu-id="73c3d-140">This involves an unavoidable computational cost.</span></span> <span data-ttu-id="73c3d-141">Asimismo, si recorrer en iteración los resultados mediante el uso de un bucle foreach (For Each en Visual Basic), los resultados de los subprocesos de trabajo deben serializarse en el subproceso del enumerador.</span><span class="sxs-lookup"><span data-stu-id="73c3d-141">Likewise, if you iterate the results by using a foreach (For Each in Visual Basic) loop, the results from the worker threads need to be serialized onto the enumerator thread.</span></span> <span data-ttu-id="73c3d-142">Pero si desea realizar alguna acción en función del resultado de cada subproceso, puede utilizar el método ForAll para realizar este trabajo en varios subprocesos.</span><span class="sxs-lookup"><span data-stu-id="73c3d-142">But if you just want to perform some action based on the result from each thread, you can use the ForAll method to perform this work on multiple threads.</span></span>  
  
5.  <span data-ttu-id="73c3d-143">El tipo de opciones de combinación.</span><span class="sxs-lookup"><span data-stu-id="73c3d-143">The type of merge options.</span></span>  
  
     <span data-ttu-id="73c3d-144">PLINQ puede configurarse para ser almacenan en búfer su salida y generar en fragmentos o a la vez después de que el conjunto de resultados completo se genera, o bien en secuencias los resultados individuales se generan.</span><span class="sxs-lookup"><span data-stu-id="73c3d-144">PLINQ can be configured to either buffer its output, and produce it in chunks or all at once after the entire result set is produced, or else to stream individual results as they are produced.</span></span> <span data-ttu-id="73c3d-145">El primer resultado es un menor tiempo de ejecución total y el segundo disminuye la latencia entre los elementos producidos.</span><span class="sxs-lookup"><span data-stu-id="73c3d-145">The former result is decreased overall execution time and the latter results in decreased latency between yielded elements.</span></span>  <span data-ttu-id="73c3d-146">Mientras que las opciones de combinación no siempre tienen una repercusión importante en el rendimiento general de las consultas, pueden afectar al rendimiento percibido porque controlan el tiempo que un usuario debe esperar a ver los resultados.</span><span class="sxs-lookup"><span data-stu-id="73c3d-146">While the merge options do not always have a major impact on overall query performance, they can impact perceived performance because they control how long a user must wait to see results.</span></span> <span data-ttu-id="73c3d-147">Para más información, consulte las [opciones de combinación en PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="73c3d-147">For more information, see [Merge Options in PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span></span>  
  
6.  <span data-ttu-id="73c3d-148">El tipo de partición.</span><span class="sxs-lookup"><span data-stu-id="73c3d-148">The kind of partitioning.</span></span>  
  
     <span data-ttu-id="73c3d-149">En algunos casos, una consulta PLINQ sobre una colección de origen indizable puede producir en una carga de trabajo desequilibrada.</span><span class="sxs-lookup"><span data-stu-id="73c3d-149">In some cases, a PLINQ query over an indexable source collection may result in an unbalanced work load.</span></span> <span data-ttu-id="73c3d-150">Cuando esto ocurre, es posible que pueda aumentar el rendimiento de las consultas creando un particionador personalizado.</span><span class="sxs-lookup"><span data-stu-id="73c3d-150">When this occurs, you might be able to increase the query performance by creating a custom partitioner.</span></span> <span data-ttu-id="73c3d-151">Para más información, consulte [Custom Partitioners for PLINQ and TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) (Particionadores personalizados para PLINQ y TPL).</span><span class="sxs-lookup"><span data-stu-id="73c3d-151">For more information, see [Custom Partitioners for PLINQ and TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span></span>  
  
## <a name="when-plinq-chooses-sequential-mode"></a><span data-ttu-id="73c3d-152">Cuando elige PLINQ el modo secuencial</span><span class="sxs-lookup"><span data-stu-id="73c3d-152">When PLINQ Chooses Sequential Mode</span></span>  
 <span data-ttu-id="73c3d-153">PLINQ siempre intentará ejecutar una consulta al menos tan rápida como la consulta se ejecutara secuencialmente.</span><span class="sxs-lookup"><span data-stu-id="73c3d-153">PLINQ will always attempt to execute a query at least as fast as the query would run sequentially.</span></span> <span data-ttu-id="73c3d-154">Aunque PLINQ no observar computacionalmente son costosas de los delegados de usuario, o tamaño el origen de entrada, buscar para determinada consulta "formas".</span><span class="sxs-lookup"><span data-stu-id="73c3d-154">Although PLINQ does not look at how computationally expensive the user delegates are, or how big the input source is, it does look for certain query "shapes."</span></span> <span data-ttu-id="73c3d-155">En concreto, busca operadores de consulta o combinaciones de operadores que normalmente provocan una consulta se ejecute más lentamente en modo paralelo.</span><span class="sxs-lookup"><span data-stu-id="73c3d-155">Specifically, it looks for query operators or combinations of operators that typically cause a query to execute more slowly in parallel mode.</span></span> <span data-ttu-id="73c3d-156">Cuando encuentra esas formas, PLINQ predeterminada vuelve al modo secuencial.</span><span class="sxs-lookup"><span data-stu-id="73c3d-156">When it finds such shapes, PLINQ by default falls back to sequential mode.</span></span>  
  
 <span data-ttu-id="73c3d-157">Sin embargo, después de medir el rendimiento de una consulta concreta, puede determinar que realmente se ejecuta más rápido en modo paralelo.</span><span class="sxs-lookup"><span data-stu-id="73c3d-157">However, after measuring a specific query's performance, you may determine that it actually runs faster in parallel mode.</span></span> <span data-ttu-id="73c3d-158">En tales casos puede usar el <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> marca a través de la <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> método para indicar a PLINQ para paralelizar la consulta.</span><span class="sxs-lookup"><span data-stu-id="73c3d-158">In such cases you can use the <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> flag via the <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> method to instruct PLINQ to parallelize the query.</span></span> <span data-ttu-id="73c3d-159">Para más información, consulte [Especificación del modo de ejecución en PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="73c3d-159">For more information, see [How to: Specify the Execution Mode in PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span></span>  
  
 <span data-ttu-id="73c3d-160">En la lista siguiente se describe las formas de consulta PLINQ de forma predeterminada se ejecutará en modo secuencial:</span><span class="sxs-lookup"><span data-stu-id="73c3d-160">The following list describes the query shapes that PLINQ by default will execute in sequential mode:</span></span>  
  
-   <span data-ttu-id="73c3d-161">Las consultas que contienen una instrucción Select, Where indizado, SelectMany indizado o una cláusula ElementAt después de un operador de ordenación o filtrado que ha quitado o reorganizado los índices originales.</span><span class="sxs-lookup"><span data-stu-id="73c3d-161">Queries that contain a Select, indexed Where, indexed SelectMany, or ElementAt clause after an ordering or filtering operator that has removed or rearranged original indices.</span></span>  
  
-   <span data-ttu-id="73c3d-162">Consultas que contienen un Take, TakeWhile, Skip, SkipWhile (operador) y donde índices en la secuencia de origen no están en el orden original.</span><span class="sxs-lookup"><span data-stu-id="73c3d-162">Queries that contain a Take, TakeWhile, Skip, SkipWhile operator and where indices in the source sequence are not in the original order.</span></span>  
  
-   <span data-ttu-id="73c3d-163">Las consultas que contienen Zip o SequenceEquals, a menos que uno de los orígenes de datos tiene un índice ordenado inicialmente y el otro origen de datos sea indizable (es decir, una matriz o IList(T)).</span><span class="sxs-lookup"><span data-stu-id="73c3d-163">Queries that contain Zip or SequenceEquals, unless one of the data sources has an originally ordered index and the other data source is indexable (i.e. an array or IList(T)).</span></span>  
  
-   <span data-ttu-id="73c3d-164">Consultas que contienen Concat, a menos que se aplica a los orígenes de datos indizables.</span><span class="sxs-lookup"><span data-stu-id="73c3d-164">Queries that contain Concat, unless it is applied to indexable data sources.</span></span>  
  
-   <span data-ttu-id="73c3d-165">Invertir las consultas que contienen, a menos que aplique a un origen de datos indizables.</span><span class="sxs-lookup"><span data-stu-id="73c3d-165">Queries that contain Reverse, unless applied to an indexable data source.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="73c3d-166">Vea también</span><span class="sxs-lookup"><span data-stu-id="73c3d-166">See Also</span></span>  
 [<span data-ttu-id="73c3d-167">Parallel LINQ (PLINQ)</span><span class="sxs-lookup"><span data-stu-id="73c3d-167">Parallel LINQ (PLINQ)</span></span>](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)
