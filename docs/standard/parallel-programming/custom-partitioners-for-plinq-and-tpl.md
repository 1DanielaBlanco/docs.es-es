---
title: Particionadores personalizados para PLINQ y TPL
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords: tasks, partitioners
ms.assetid: 96153688-9a01-47c4-8430-909cee9a2887
caps.latest.revision: "19"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 12d234b86b0067178d54d2fdcb5d37ceaee6109d
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 11/21/2017
---
# <a name="custom-partitioners-for-plinq-and-tpl"></a><span data-ttu-id="1582e-102">Particionadores personalizados para PLINQ y TPL</span><span class="sxs-lookup"><span data-stu-id="1582e-102">Custom Partitioners for PLINQ and TPL</span></span>
<span data-ttu-id="1582e-103">Para paralelizar una operación en un origen de datos, uno de los pasos esenciales es *partición* el origen en varias secciones que pueden acceder varios subprocesos simultáneamente.</span><span class="sxs-lookup"><span data-stu-id="1582e-103">To parallelize an operation on a data source, one of the essential steps is to *partition* the source into multiple sections that can be accessed concurrently by multiple threads.</span></span> <span data-ttu-id="1582e-104">PLINQ y la biblioteca (TPL) proporcionan particionadores predeterminados que funcionan de manera transparente al escribir una consulta en paralelo o <xref:System.Threading.Tasks.Parallel.ForEach%2A> bucle.</span><span class="sxs-lookup"><span data-stu-id="1582e-104">PLINQ and the Task Parallel Library (TPL) provide default partitioners that work transparently when you write a parallel query or <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span> <span data-ttu-id="1582e-105">Para escenarios más avanzados, puede conectar su propio particionador.</span><span class="sxs-lookup"><span data-stu-id="1582e-105">For more advanced scenarios, you can plug in your own partitioner.</span></span>  
  
## <a name="kinds-of-partitioning"></a><span data-ttu-id="1582e-106">Tipos de particiones</span><span class="sxs-lookup"><span data-stu-id="1582e-106">Kinds of Partitioning</span></span>  
 <span data-ttu-id="1582e-107">Hay muchas maneras de dividir un origen de datos.</span><span class="sxs-lookup"><span data-stu-id="1582e-107">There are many ways to partition a data source.</span></span> <span data-ttu-id="1582e-108">En los enfoques más eficaces, varios subprocesos cooperan para el proceso de la secuencia de origen original, en lugar de separar físicamente el origen en varias secuencias secundarias.</span><span class="sxs-lookup"><span data-stu-id="1582e-108">In the most efficient approaches, multiple threads cooperate to process the original source sequence, rather than physically separating the source into multiple subsequences.</span></span> <span data-ttu-id="1582e-109">Para matrices y otros orígenes indizados como <xref:System.Collections.IList> colecciones donde la longitud se conoce de antemano, *creación de particiones range* es el tipo más sencillo de creación de particiones.</span><span class="sxs-lookup"><span data-stu-id="1582e-109">For arrays and other indexed sources such as <xref:System.Collections.IList> collections where the length is known in advance, *range partitioning* is the simplest kind of partitioning.</span></span> <span data-ttu-id="1582e-110">Cada subproceso recibe único de apertura y cierre índices, para que pueda procesar su intervalo de origen sin sobrescribir ni ningún otro subproceso que se va a sobrescribir.</span><span class="sxs-lookup"><span data-stu-id="1582e-110">Every thread receives unique beginning and ending indexes, so that it can process its range of the source without overwriting or being overwritten by any other thread.</span></span> <span data-ttu-id="1582e-111">La única sobrecarga implicada en la partición de intervalo es el trabajo inicial de crear los intervalos; se necesita ninguna sincronización adicional después de eso.</span><span class="sxs-lookup"><span data-stu-id="1582e-111">The only overhead involved in range partitioning is the initial work of creating the ranges; no additional synchronization is required after that.</span></span> <span data-ttu-id="1582e-112">Por lo tanto, puede proporcionar un buen rendimiento siempre y cuando la carga de trabajo se divide por igual.</span><span class="sxs-lookup"><span data-stu-id="1582e-112">Therefore, it can provide good performance as long as the workload is divided evenly.</span></span> <span data-ttu-id="1582e-113">Una desventaja de particionamiento de intervalo es que si un subproceso finaliza al principio, no puede ayudar a los demás subprocesos finalizar su trabajo.</span><span class="sxs-lookup"><span data-stu-id="1582e-113">A disadvantage of range partitioning is that if one thread finishes early, it cannot help the other threads finish their work.</span></span>  
  
 <span data-ttu-id="1582e-114">Para listas vinculadas u otras colecciones cuya longitud no se conoce, puede usar *fragmento particiones*.</span><span class="sxs-lookup"><span data-stu-id="1582e-114">For linked lists or other collections whose length is not known, you can use *chunk partitioning*.</span></span> <span data-ttu-id="1582e-115">En particiones de fragmentos, cada subproceso o tarea en un bucle paralelo o consulta consume un número de elementos de origen de un fragmento, procesarlos y, a continuación, vuelve a estar al recuperar los elementos adicionales.</span><span class="sxs-lookup"><span data-stu-id="1582e-115">In chunk partitioning, every thread or task in a parallel loop or query consumes some number of source elements in one chunk, processes them, and then comes back to retrieve additional elements.</span></span> <span data-ttu-id="1582e-116">Los particionadores se aseguran de que todos los elementos se distribuyen y que no haya duplicados.</span><span class="sxs-lookup"><span data-stu-id="1582e-116">The partitioner ensures that all elements are distributed and that there are no duplicates.</span></span> <span data-ttu-id="1582e-117">Un fragmento puede tener cualquier tamaño.</span><span class="sxs-lookup"><span data-stu-id="1582e-117">A chunk may be any size.</span></span> <span data-ttu-id="1582e-118">Por ejemplo, el particionador que se muestra en [Cómo: implementar las particiones dinámicas](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md) crea fragmentos que contienen un solo elemento.</span><span class="sxs-lookup"><span data-stu-id="1582e-118">For example, the partitioner that is demonstrated in [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md) creates chunks that contain just one element.</span></span> <span data-ttu-id="1582e-119">Siempre que los fragmentos no son demasiado grandes, este tipo de particiones es inherentemente el equilibrio de carga porque la asignación de elementos a los subprocesos no se ha determinado previamente.</span><span class="sxs-lookup"><span data-stu-id="1582e-119">As long as the chunks are not too large, this kind of partitioning is inherently load-balancing because the assignment of elements to threads is not pre-determined.</span></span> <span data-ttu-id="1582e-120">Sin embargo, la clase partitioner evitar la sobrecarga de sincronización cada vez que el subproceso necesita obtener otro fragmento.</span><span class="sxs-lookup"><span data-stu-id="1582e-120">However, the partitioner does incur the synchronization overhead each time the thread needs to get another chunk.</span></span> <span data-ttu-id="1582e-121">La cantidad de sincronización que se incurre en estos casos es inversamente proporcional al tamaño de los fragmentos.</span><span class="sxs-lookup"><span data-stu-id="1582e-121">The amount of synchronization incurred in these cases is inversely proportional to the size of the chunks.</span></span>  
  
 <span data-ttu-id="1582e-122">En general, la partición de intervalos solo es más rápido cuando el tiempo de ejecución del delegado es poco a moderado y el origen tiene un gran número de elementos y el trabajo total de cada partición es aproximadamente equivalente.</span><span class="sxs-lookup"><span data-stu-id="1582e-122">In general, range partitioning is only faster when the execution time of the delegate is small to moderate, and the source has a large number of elements, and the total work of each partition is roughly equivalent.</span></span> <span data-ttu-id="1582e-123">Creación de particiones de fragmentos, por tanto, es generalmente más rápido en la mayoría de los casos.</span><span class="sxs-lookup"><span data-stu-id="1582e-123">Chunk partitioning is therefore generally faster in most cases.</span></span> <span data-ttu-id="1582e-124">En orígenes con un número pequeño de elementos o el tiempo de ejecución para el delegado, a continuación, el rendimiento de fragmento y particiones de intervalo es casi igual.</span><span class="sxs-lookup"><span data-stu-id="1582e-124">On sources with a small number of elements or longer execution times for the delegate, then the performance of chunk and range partitioning is about equal.</span></span>  
  
 <span data-ttu-id="1582e-125">Los particionadores de TPL también admiten un número de particiones dinámico.</span><span class="sxs-lookup"><span data-stu-id="1582e-125">The TPL partitioners also support a dynamic number of partitions.</span></span> <span data-ttu-id="1582e-126">Esto significa que se pueden crear particiones sobre la marcha, por ejemplo, cuando el <xref:System.Threading.Tasks.Parallel.ForEach%2A> bucle genera una nueva tarea.</span><span class="sxs-lookup"><span data-stu-id="1582e-126">This means they can create partitions on-the-fly, for example, when the <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop spawns a new task.</span></span> <span data-ttu-id="1582e-127">Esta característica permite al particionador escalar junto con el propio bucle.</span><span class="sxs-lookup"><span data-stu-id="1582e-127">This feature enables the partitioner to scale together with the loop itself.</span></span> <span data-ttu-id="1582e-128">Los particionadores dinámicos también son inherentemente el equilibrio de carga.</span><span class="sxs-lookup"><span data-stu-id="1582e-128">Dynamic partitioners are also inherently load-balancing.</span></span> <span data-ttu-id="1582e-129">Cuando se crea un particionador personalizado, debe admitir la creación de particiones dinámicas para poder usarse desde un <xref:System.Threading.Tasks.Parallel.ForEach%2A> bucle.</span><span class="sxs-lookup"><span data-stu-id="1582e-129">When you create a custom partitioner, you must support dynamic partitioning to be consumable from a <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span>  
  
### <a name="configuring-load-balancing-partitioners-for-plinq"></a><span data-ttu-id="1582e-130">Configurar particionadores para PLINQ de equilibrio de carga</span><span class="sxs-lookup"><span data-stu-id="1582e-130">Configuring Load Balancing Partitioners for PLINQ</span></span>  
 <span data-ttu-id="1582e-131">Algunas sobrecargas de la <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> método le permite crear un particionador para una matriz o <xref:System.Collections.IList> de origen y especifique si debe intentar equilibrar la carga de trabajo entre los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="1582e-131">Some overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> method let you create a partitioner for an array or <xref:System.Collections.IList> source and specify whether it should attempt to balance the workload among the threads.</span></span> <span data-ttu-id="1582e-132">Cuando se configura el particionador para equilibrar la carga, fragmento las particiones se emplean y los elementos se entregan a cada partición en pequeños fragmentos conforme se solicitan.</span><span class="sxs-lookup"><span data-stu-id="1582e-132">When the partitioner is configured to load-balance, chunk partitioning is used, and the elements are handed off to each partition in small chunks as they are requested.</span></span> <span data-ttu-id="1582e-133">Este enfoque ayuda a garantizar que todas las particiones tienen elementos para procesar hasta que todo el bucle o se completa la consulta.</span><span class="sxs-lookup"><span data-stu-id="1582e-133">This approach helps ensure that all partitions have elements to process until the entire loop or query is completed.</span></span> <span data-ttu-id="1582e-134">Una sobrecarga adicional puede usarse para proporcionar equilibrio de carga de partición de cualquier <xref:System.Collections.IEnumerable> origen.</span><span class="sxs-lookup"><span data-stu-id="1582e-134">An additional overload can be used to provide load-balancing partitioning of any <xref:System.Collections.IEnumerable> source.</span></span>  
  
 <span data-ttu-id="1582e-135">En general, el equilibrio de carga requiere las particiones para solicitar elementos relativamente con frecuencia de la clase partitioner.</span><span class="sxs-lookup"><span data-stu-id="1582e-135">In general, load balancing requires the partitions to request elements relatively frequently from the partitioner.</span></span> <span data-ttu-id="1582e-136">Por el contrario, un particionador que crea particiones estáticas puede asignar los elementos a cada particionador todos a la vez mediante el uso de intervalo o creación de particiones de fragmento.</span><span class="sxs-lookup"><span data-stu-id="1582e-136">By contrast, a partitioner that does static partitioning can assign the elements to each partitioner all at once by using either range or chunk partitioning.</span></span> <span data-ttu-id="1582e-137">Esto requiere menos sobrecarga de equilibrio de carga, pero es posible que tarde más tiempo en ejecutarse si un subproceso termina significativamente con más trabajo que las demás.</span><span class="sxs-lookup"><span data-stu-id="1582e-137">This requires less overhead than load balancing, but it might take longer to execute if one thread ends up with significantly more work than the others.</span></span> <span data-ttu-id="1582e-138">De forma predeterminada cuando se pasa una interfaz IList o una matriz, PLINQ siempre utiliza la creación de particiones de intervalo sin equilibrio de carga.</span><span class="sxs-lookup"><span data-stu-id="1582e-138">By default when it is passed an IList or an array, PLINQ always uses range partitioning without load balancing.</span></span> <span data-ttu-id="1582e-139">Para habilitar Equilibrio de carga para PLINQ, use la `Partitioner.Create` método, tal como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="1582e-139">To enable load balancing for PLINQ, use the `Partitioner.Create` method, as shown in the following example.</span></span>  
  
 [!code-csharp[TPL_Partitioners#02](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioners.cs#02)]
 [!code-vb[TPL_Partitioners#02](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionsnippets_vb.vb#02)]  
  
 <span data-ttu-id="1582e-140">La mejor manera de determinar si utilizar carga equilibrio en un escenario determinado es experimentar y medir el tiempo que tarda la finalización bajo carga representativa y configuraciones de equipo de operaciones.</span><span class="sxs-lookup"><span data-stu-id="1582e-140">The best way to determine whether to use load balancing in any given scenario is to experiment and measure how long it takes operations to complete under representative loads and computer configurations.</span></span> <span data-ttu-id="1582e-141">Por ejemplo, la creación de particiones estático podría proporcionar un aumento significativo en un equipo de varios núcleos que tenga solo unos pocos núcleos, pero podría dar como resultado una ralentización en equipos que tienen relativamente más núcleos.</span><span class="sxs-lookup"><span data-stu-id="1582e-141">For example, static partitioning might provide significant speedup on a multi-core computer that has only a few cores, but it might result in slowdowns on computers that have relatively many cores.</span></span>  
  
 <span data-ttu-id="1582e-142">En la tabla siguiente se enumera las sobrecargas disponibles de la <xref:System.Collections.Concurrent.Partitioner.Create%2A> método.</span><span class="sxs-lookup"><span data-stu-id="1582e-142">The following table lists the available overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> method.</span></span> <span data-ttu-id="1582e-143">Estos particionadores no están limitados a utilizar únicamente con PLINQ o <xref:System.Threading.Tasks.Task>.</span><span class="sxs-lookup"><span data-stu-id="1582e-143">These partitioners are not limited to use only with PLINQ or <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="1582e-144">También se puede utilizar con cualquier construcción paralela personalizada.</span><span class="sxs-lookup"><span data-stu-id="1582e-144">They can also be used with any custom parallel construct.</span></span>  
  
|<span data-ttu-id="1582e-145">Sobrecarga</span><span class="sxs-lookup"><span data-stu-id="1582e-145">Overload</span></span>|<span data-ttu-id="1582e-146">Usa el equilibrio de carga</span><span class="sxs-lookup"><span data-stu-id="1582e-146">Uses load balancing</span></span>|  
|--------------|-------------------------|  
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>|<span data-ttu-id="1582e-147">Always</span><span class="sxs-lookup"><span data-stu-id="1582e-147">Always</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28%60%600%5B%5D%2CSystem.Boolean%29>|<span data-ttu-id="1582e-148">Cuando se especifica el argumento de tipo Boolean como true</span><span class="sxs-lookup"><span data-stu-id="1582e-148">When the Boolean argument is specified as true</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IList%7B%60%600%7D%2CSystem.Boolean%29>|<span data-ttu-id="1582e-149">Cuando se especifica el argumento de tipo Boolean como true</span><span class="sxs-lookup"><span data-stu-id="1582e-149">When the Boolean argument is specified as true</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%29>|<span data-ttu-id="1582e-150">Nunca</span><span class="sxs-lookup"><span data-stu-id="1582e-150">Never</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%2CSystem.Int32%29>|<span data-ttu-id="1582e-151">Nunca</span><span class="sxs-lookup"><span data-stu-id="1582e-151">Never</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%29>|<span data-ttu-id="1582e-152">Nunca</span><span class="sxs-lookup"><span data-stu-id="1582e-152">Never</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%2CSystem.Int64%29>|<span data-ttu-id="1582e-153">Nunca</span><span class="sxs-lookup"><span data-stu-id="1582e-153">Never</span></span>|  
  
### <a name="configuring-static-range-partitioners-for-parallelforeach"></a><span data-ttu-id="1582e-154">Configurar particionadores por intervalos estáticos para Parallel.ForEach</span><span class="sxs-lookup"><span data-stu-id="1582e-154">Configuring Static Range Partitioners for Parallel.ForEach</span></span>  
 <span data-ttu-id="1582e-155">En un <xref:System.Threading.Tasks.Parallel.For%2A> de bucles for, el cuerpo del bucle se proporciona al método como un delegado.</span><span class="sxs-lookup"><span data-stu-id="1582e-155">In a <xref:System.Threading.Tasks.Parallel.For%2A> loop, the body of the loop is provided to the method as a delegate.</span></span> <span data-ttu-id="1582e-156">El costo de invocar ese delegado es aproximadamente el mismo que una llamada al método virtual.</span><span class="sxs-lookup"><span data-stu-id="1582e-156">The cost of invoking that delegate is about the same as a virtual method call.</span></span> <span data-ttu-id="1582e-157">En algunos escenarios, el cuerpo de un bucle paralelo podría ser lo suficientemente pequeño como para que el costo de la invocación del delegado en cada iteración del bucle, pasa a ser significativo.</span><span class="sxs-lookup"><span data-stu-id="1582e-157">In some scenarios, the body of a parallel loop might be small enough that the cost of the delegate invocation on each loop iteration becomes significant.</span></span> <span data-ttu-id="1582e-158">En estas situaciones, puede usar uno de los <xref:System.Collections.Concurrent.Partitioner.Create%2A> sobrecargas para crear un <xref:System.Collections.Generic.IEnumerable%601> de particiones por rangos de los elementos de origen.</span><span class="sxs-lookup"><span data-stu-id="1582e-158">In such situations, you can use one of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads to create an <xref:System.Collections.Generic.IEnumerable%601> of range partitions over the source elements.</span></span> <span data-ttu-id="1582e-159">A continuación, puede pasar esta colección de intervalos para un <xref:System.Threading.Tasks.Parallel.ForEach%2A> método cuyo cuerpo se compone de una normal `for` bucle.</span><span class="sxs-lookup"><span data-stu-id="1582e-159">Then, you can pass this collection of ranges to a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method whose body consists of a regular `for` loop.</span></span> <span data-ttu-id="1582e-160">La ventaja de este enfoque es que el costo de invocación del delegado se incurre en una sola vez por intervalo, en lugar de una vez por cada elemento.</span><span class="sxs-lookup"><span data-stu-id="1582e-160">The benefit of this approach is that the delegate invocation cost is incurred only once per range, rather than once per element.</span></span> <span data-ttu-id="1582e-161">En el ejemplo siguiente se muestra el patrón básico.</span><span class="sxs-lookup"><span data-stu-id="1582e-161">The following example demonstrates the basic pattern.</span></span>  
  
 [!code-csharp[TPL_Partitioners#01](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioner01.cs#01)]
 [!code-vb[TPL_Partitioners#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionercreate01.vb#01)]  
  
 <span data-ttu-id="1582e-162">Cada subproceso del bucle recibe su propio <xref:System.Tuple%602> que contiene las iniciales y finales de los valores de índice en el intervalo secundario especificado.</span><span class="sxs-lookup"><span data-stu-id="1582e-162">Every thread in the loop receives its own <xref:System.Tuple%602> that contains the starting and ending index values in the specified sub-range.</span></span> <span data-ttu-id="1582e-163">Interna `for` bucle utiliza el `fromInclusive` y `toExclusive` valores para recorrer la matriz o <xref:System.Collections.IList> directamente.</span><span class="sxs-lookup"><span data-stu-id="1582e-163">The inner `for` loop uses the `fromInclusive` and `toExclusive` values to loop over the array or the <xref:System.Collections.IList> directly.</span></span>  
  
 <span data-ttu-id="1582e-164">Uno de los <xref:System.Collections.Concurrent.Partitioner.Create%2A> sobrecargas le permite especificar el tamaño de las particiones y el número de particiones.</span><span class="sxs-lookup"><span data-stu-id="1582e-164">One of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads lets you specify the size of the partitions, and the number of partitions.</span></span> <span data-ttu-id="1582e-165">Esta sobrecarga puede usarse en escenarios donde el trabajo por cada elemento es tan bajo que incluso un método virtual llamada por cada elemento tiene un impacto perceptible en el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="1582e-165">This overload can be used in scenarios where the work per element is so low that even one virtual method call per element has a noticeable impact on performance.</span></span>  
  
## <a name="custom-partitioners"></a><span data-ttu-id="1582e-166">Particionadores personalizados</span><span class="sxs-lookup"><span data-stu-id="1582e-166">Custom Partitioners</span></span>  
 <span data-ttu-id="1582e-167">En algunos casos, podría ser merece la pena o incluso necesarios para implementar a un particionador propio.</span><span class="sxs-lookup"><span data-stu-id="1582e-167">In some scenarios, it might be worthwhile or even required to implement your own partitioner.</span></span> <span data-ttu-id="1582e-168">Por ejemplo, podría tener una clase de colección personalizada que puede crear particiones de forma más eficaz que el valor predeterminado particionadores puede, según su conocimiento de la estructura interna de la clase.</span><span class="sxs-lookup"><span data-stu-id="1582e-168">For example, you might have a custom collection class that you can partition more efficiently than the default partitioners can, based on your knowledge of the internal structure of the class.</span></span> <span data-ttu-id="1582e-169">O bien, puede que desee crear particiones de intervalo de tamaños diferentes basándose en su conocimiento de cuánto tiempo se tardará en procesar los elementos en ubicaciones distintas de la colección de origen.</span><span class="sxs-lookup"><span data-stu-id="1582e-169">Or, you may want to create range partitions of varying sizes based on your knowledge of how long it will take to process elements at different locations in the source collection.</span></span>  
  
 <span data-ttu-id="1582e-170">Para crear un particionador personalizado básico, derive una clase de <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> e invalidar los métodos virtuales, tal como se describe en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="1582e-170">To create a basic custom partitioner, derive a class from <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> and override the virtual methods, as described in the following table.</span></span>  
  
|||  
|-|-|  
|<xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>|<span data-ttu-id="1582e-171">Este método se llama una vez por el subproceso principal y devuelve un IList(IEnumerator(TSource)).</span><span class="sxs-lookup"><span data-stu-id="1582e-171">This method is called once by the main thread and returns an IList(IEnumerator(TSource)).</span></span> <span data-ttu-id="1582e-172">Puede llamar cada subproceso de trabajo en el bucle o consulta `GetEnumerator` en la lista para recuperar un <xref:System.Collections.Generic.IEnumerator%601> a través de una partición distinta.</span><span class="sxs-lookup"><span data-stu-id="1582e-172">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="1582e-173">Devolver `true` si implementa <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, en caso contrario, `false`.</span><span class="sxs-lookup"><span data-stu-id="1582e-173">Return `true` if you implement <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, otherwise, `false`.</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="1582e-174">Si <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> es `true`, opcionalmente, puede llamar a este método en lugar de <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="1582e-174">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|  
  
 <span data-ttu-id="1582e-175">Si los resultados deben ser que se puede ordenar o necesite acceso indizado en los elementos, a continuación, se derivan de <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> e invalidar sus métodos virtuales como se describe en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="1582e-175">If the results must be sortable or you require indexed access into the elements, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> and override its virtual methods as described in the following table.</span></span>  
  
|||  
|-|-|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetPartitions%2A>|<span data-ttu-id="1582e-176">Este método se llama una vez por el subproceso principal y devuelve un `IList(IEnumerator(TSource))`.</span><span class="sxs-lookup"><span data-stu-id="1582e-176">This method is called once by the main thread and returns an `IList(IEnumerator(TSource))`.</span></span> <span data-ttu-id="1582e-177">Puede llamar cada subproceso de trabajo en el bucle o consulta `GetEnumerator` en la lista para recuperar un <xref:System.Collections.Generic.IEnumerator%601> a través de una partición distinta.</span><span class="sxs-lookup"><span data-stu-id="1582e-177">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="1582e-178">Devolver `true` si implementa <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>; de lo contrario, false.</span><span class="sxs-lookup"><span data-stu-id="1582e-178">Return `true` if you implement <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>; otherwise, false.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="1582e-179">Normalmente, esto simplemente llama <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="1582e-179">Typically, this just calls <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>|<span data-ttu-id="1582e-180">Si <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> es `true`, opcionalmente, puede llamar a este método en lugar de <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="1582e-180">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|  
  
 <span data-ttu-id="1582e-181">En la tabla siguiente proporciona detalles adicionales sobre cómo los tres tipos de equilibrio de carga particionadores implementan la <xref:System.Collections.Concurrent.OrderablePartitioner%601> clase.</span><span class="sxs-lookup"><span data-stu-id="1582e-181">The following table provides additional details about how the three kinds of load-balancing partitioners implement the <xref:System.Collections.Concurrent.OrderablePartitioner%601> class.</span></span>  
  
|<span data-ttu-id="1582e-182">Método o propiedad</span><span class="sxs-lookup"><span data-stu-id="1582e-182">Method/Property</span></span>|<span data-ttu-id="1582e-183">IList / matriz sin equilibrio de carga</span><span class="sxs-lookup"><span data-stu-id="1582e-183">IList / Array without Load Balancing</span></span>|<span data-ttu-id="1582e-184">IList / matriz con equilibrio de carga</span><span class="sxs-lookup"><span data-stu-id="1582e-184">IList / Array with Load Balancing</span></span>|<span data-ttu-id="1582e-185">IEnumerable</span><span class="sxs-lookup"><span data-stu-id="1582e-185">IEnumerable</span></span>|  
|----------------------|-------------------------------------------|----------------------------------------|-----------------|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>|<span data-ttu-id="1582e-186">Utiliza la creación de particiones de intervalo</span><span class="sxs-lookup"><span data-stu-id="1582e-186">Uses range partitioning</span></span>|<span data-ttu-id="1582e-187">La creación de particiones de fragmentos de usos optimizada para la partitionCount especificada</span><span class="sxs-lookup"><span data-stu-id="1582e-187">Uses chunk partitioning optimized for Lists for the partitionCount specified</span></span>|<span data-ttu-id="1582e-188">Fragmento utiliza creación de particiones mediante la creación de un número estático de particiones.</span><span class="sxs-lookup"><span data-stu-id="1582e-188">Uses chunk partitioning by creating a static number of partitions.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A?displayProperty=nameWithType>|<span data-ttu-id="1582e-189">Excepción produce no admitidos</span><span class="sxs-lookup"><span data-stu-id="1582e-189">Throws not-supported exception</span></span>|<span data-ttu-id="1582e-190">La creación de particiones de fragmentos de usos optimizada para las listas y las particiones dinámicas</span><span class="sxs-lookup"><span data-stu-id="1582e-190">Uses chunk partitioning optimized for Lists and dynamic partitions</span></span>|<span data-ttu-id="1582e-191">Fragmento utiliza creación de particiones mediante la creación de un número de particiones dinámico.</span><span class="sxs-lookup"><span data-stu-id="1582e-191">Uses chunk partitioning by creating a dynamic number of partitions.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedInEachPartition%2A>|<span data-ttu-id="1582e-192">Devuelve `true`</span><span class="sxs-lookup"><span data-stu-id="1582e-192">Returns `true`</span></span>|<span data-ttu-id="1582e-193">Devuelve `true`</span><span class="sxs-lookup"><span data-stu-id="1582e-193">Returns `true`</span></span>|<span data-ttu-id="1582e-194">Devuelve `true`</span><span class="sxs-lookup"><span data-stu-id="1582e-194">Returns `true`</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedAcrossPartitions%2A>|<span data-ttu-id="1582e-195">Devuelve `true`</span><span class="sxs-lookup"><span data-stu-id="1582e-195">Returns `true`</span></span>|<span data-ttu-id="1582e-196">Devuelve `false`</span><span class="sxs-lookup"><span data-stu-id="1582e-196">Returns `false`</span></span>|<span data-ttu-id="1582e-197">Devuelve `false`</span><span class="sxs-lookup"><span data-stu-id="1582e-197">Returns `false`</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysNormalized%2A>|<span data-ttu-id="1582e-198">Devuelve `true`</span><span class="sxs-lookup"><span data-stu-id="1582e-198">Returns `true`</span></span>|<span data-ttu-id="1582e-199">Devuelve `true`</span><span class="sxs-lookup"><span data-stu-id="1582e-199">Returns `true`</span></span>|<span data-ttu-id="1582e-200">Devuelve `true`</span><span class="sxs-lookup"><span data-stu-id="1582e-200">Returns `true`</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="1582e-201">Devuelve `false`</span><span class="sxs-lookup"><span data-stu-id="1582e-201">Returns `false`</span></span>|<span data-ttu-id="1582e-202">Devuelve `true`</span><span class="sxs-lookup"><span data-stu-id="1582e-202">Returns `true`</span></span>|<span data-ttu-id="1582e-203">Devuelve `true`</span><span class="sxs-lookup"><span data-stu-id="1582e-203">Returns `true`</span></span>|  
  
### <a name="dynamic-partitions"></a><span data-ttu-id="1582e-204">Particiones dinámicas</span><span class="sxs-lookup"><span data-stu-id="1582e-204">Dynamic Partitions</span></span>  
 <span data-ttu-id="1582e-205">Si piensa que el particionador para usarse en un <xref:System.Threading.Tasks.Parallel.ForEach%2A> método, debe poder devolver un número de particiones dinámico.</span><span class="sxs-lookup"><span data-stu-id="1582e-205">If you intend the partitioner to be used in a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method, you must be able to return a dynamic number of partitions.</span></span> <span data-ttu-id="1582e-206">Esto significa que el particionador pueden proporcionar un enumerador para una nueva partición a petición en cualquier momento durante la ejecución del bucle.</span><span class="sxs-lookup"><span data-stu-id="1582e-206">This means that the partitioner can supply an enumerator for a new partition on-demand at any time during loop execution.</span></span> <span data-ttu-id="1582e-207">Básicamente, siempre que el bucle agrega una nueva tarea en paralelo, solicita una nueva partición de esa tarea.</span><span class="sxs-lookup"><span data-stu-id="1582e-207">Basically, whenever the loop adds a new parallel task, it requests a new partition for that task.</span></span> <span data-ttu-id="1582e-208">Si necesita que se puede pedir a los datos, a continuación, se derivan de <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> para que se asigna a cada elemento en cada partición de un índice único.</span><span class="sxs-lookup"><span data-stu-id="1582e-208">If you require the data to be orderable, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> so that each item in each partition is assigned a unique index.</span></span>  
  
 <span data-ttu-id="1582e-209">Para obtener más información y un ejemplo, vea [Cómo: implementar las particiones dinámicas](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="1582e-209">For more information, and an example, see [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
### <a name="contract-for-partitioners"></a><span data-ttu-id="1582e-210">Contrato para particionadores</span><span class="sxs-lookup"><span data-stu-id="1582e-210">Contract for Partitioners</span></span>  
 <span data-ttu-id="1582e-211">Al implementar un particionador personalizado, siga estas instrucciones para ayudar a garantizar la interacción correcta con PLINQ y <xref:System.Threading.Tasks.Parallel.ForEach%2A> en la biblioteca TPL:</span><span class="sxs-lookup"><span data-stu-id="1582e-211">When you implement a custom partitioner, follow these guidelines to help ensure correct interaction with PLINQ and <xref:System.Threading.Tasks.Parallel.ForEach%2A> in the TPL:</span></span>  
  
-   <span data-ttu-id="1582e-212">Si <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> se llama con un argumento de cero o menos, para `partitionsCount`, producir <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="1582e-212">If <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> is called with an argument of zero or less for `partitionsCount`, throw <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="1582e-213">Aunque PLINQ y TPL nunca pasarán en una `partitionCount` igual a 0, no obstante, se recomienda que se protege contra la posibilidad.</span><span class="sxs-lookup"><span data-stu-id="1582e-213">Although PLINQ and TPL will never pass in a `partitionCount` equal to 0, we nevertheless recommend that you guard against the possibility.</span></span>  
  
-   <span data-ttu-id="1582e-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>y <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> siempre debe devolver `partitionsCount` número de particiones.</span><span class="sxs-lookup"><span data-stu-id="1582e-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> should always return `partitionsCount` number of partitions.</span></span> <span data-ttu-id="1582e-215">Si la clase partitioner agota los datos y no puede crear tantas particiones como se ha solicitado, el método debe devolver un enumerador vacío para cada una de las particiones restantes.</span><span class="sxs-lookup"><span data-stu-id="1582e-215">If the partitioner runs out of data and cannot create as many partitions as requested, then the method should return an empty enumerator for each of the remaining partitions.</span></span> <span data-ttu-id="1582e-216">De lo contrario, PLINQ y TPL producirán un <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="1582e-216">Otherwise, both PLINQ and TPL will throw an <xref:System.InvalidOperationException>.</span></span>  
  
-   <span data-ttu-id="1582e-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, y <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> nunca deberían devolver `null` (`Nothing` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="1582e-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> should never return `null` (`Nothing` in Visual Basic).</span></span> <span data-ttu-id="1582e-218">Si lo hacen, PLINQ / TPL producirán un <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="1582e-218">If they do, PLINQ / TPL will throw an <xref:System.InvalidOperationException>.</span></span>  
  
-   <span data-ttu-id="1582e-219">Métodos que devuelven particiones siempre deberían devolver particiones que pueden enumerar completamente y de forma única el origen de datos.</span><span class="sxs-lookup"><span data-stu-id="1582e-219">Methods that return partitions should always return partitions that can fully and uniquely enumerate the data source.</span></span> <span data-ttu-id="1582e-220">No debería haber ninguna duplicación en el origen de datos o elementos omitidos a menos que lo requiera específicamente el diseño de la clase partitioner.</span><span class="sxs-lookup"><span data-stu-id="1582e-220">There should be no duplication in the data source or skipped items unless specifically required by the design of the partitioner.</span></span> <span data-ttu-id="1582e-221">Si no se respeta esta regla, se puede alterar el orden de salida.</span><span class="sxs-lookup"><span data-stu-id="1582e-221">If this rule is not followed, then the output order may be scrambled.</span></span>  
  
-   <span data-ttu-id="1582e-222">Los siguientes captadores booleanos deben devolver siempre con precisión los siguientes valores para que no se altere el orden de salida:</span><span class="sxs-lookup"><span data-stu-id="1582e-222">The following Boolean getters must always accurately return the following values so that the output order is not scrambled:</span></span>  
  
    -   <span data-ttu-id="1582e-223">`KeysOrderedInEachPartition`: Cada partición devuelve elementos con cada vez mayores índices de clave.</span><span class="sxs-lookup"><span data-stu-id="1582e-223">`KeysOrderedInEachPartition`: Each partition returns elements with increasing key indices.</span></span>  
  
    -   <span data-ttu-id="1582e-224">`KeysOrderedAcrossPartitions`: Para todas las particiones que se devuelven, los índices de clave de partición *i* son más altos que los índices de clave de partición *i*-1.</span><span class="sxs-lookup"><span data-stu-id="1582e-224">`KeysOrderedAcrossPartitions`: For all partitions that are returned, the key indices in partition *i* are higher than the key indices in partition *i*-1.</span></span>  
  
    -   <span data-ttu-id="1582e-225">`KeysNormalized`: Todos los índices de clave son aumentar ininterrumpidamente sin espacios, empezando desde cero.</span><span class="sxs-lookup"><span data-stu-id="1582e-225">`KeysNormalized`: All key indices are monotonically increasing without gaps, starting from zero.</span></span>  
  
-   <span data-ttu-id="1582e-226">Todos los índices deben ser únicos.</span><span class="sxs-lookup"><span data-stu-id="1582e-226">All indices must be unique.</span></span> <span data-ttu-id="1582e-227">No puede haber índices duplicados.</span><span class="sxs-lookup"><span data-stu-id="1582e-227">There may not be duplicate indices.</span></span> <span data-ttu-id="1582e-228">Si no se respeta esta regla, se puede alterar el orden de salida.</span><span class="sxs-lookup"><span data-stu-id="1582e-228">If this rule is not followed, then the output order may be scrambled.</span></span>  
  
-   <span data-ttu-id="1582e-229">Todos los índices no deben ser negativos.</span><span class="sxs-lookup"><span data-stu-id="1582e-229">All indices must be nonnegative.</span></span> <span data-ttu-id="1582e-230">Si no se respeta esta regla, PLINQ/TPL pueden producir excepciones.</span><span class="sxs-lookup"><span data-stu-id="1582e-230">If this rule is not followed, then PLINQ/TPL may throw exceptions.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1582e-231">Vea también</span><span class="sxs-lookup"><span data-stu-id="1582e-231">See Also</span></span>  
 [<span data-ttu-id="1582e-232">Programación en paralelo</span><span class="sxs-lookup"><span data-stu-id="1582e-232">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)  
 [<span data-ttu-id="1582e-233">Implementar las particiones dinámicas</span><span class="sxs-lookup"><span data-stu-id="1582e-233">How to: Implement Dynamic Partitions</span></span>](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)  
 [<span data-ttu-id="1582e-234">Implementar un particionador para particionamiento estático</span><span class="sxs-lookup"><span data-stu-id="1582e-234">How to: Implement a Partitioner for Static Partitioning</span></span>](../../../docs/standard/parallel-programming/how-to-implement-a-partitioner-for-static-partitioning.md)
