---
title: "Flujo de datos (biblioteca TPL) | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-standard"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "Biblioteca TPL, flujos de datos"
  - "biblioteca de flujos de datos TPL"
ms.assetid: 643575d0-d26d-4c35-8de7-a9c403e97dd6
caps.latest.revision: 22
author: "rpetrusha"
ms.author: "ronpet"
manager: "wpickett"
caps.handback.revision: 22
---
# Flujo de datos (biblioteca TPL)
<a name="top"></a>La biblioteca (TPL) proporciona componentes de flujo de datos para aumentar la solidez de aplicaciones con la simultaneidad habilitada. Estos componentes de flujo de datos se conocen colectivamente como la *biblioteca de TPL Dataflow*. Este modelo de flujo de datos promueve una programación basada en actores mediante el paso de mensajes en proceso para tareas de canalización y de flujo de datos de grano grueso. Los componentes de flujo de datos se basan en los tipos y la infraestructura de programación de la biblioteca TPL y se integran con la compatibilidad de los lenguajes C#, [!INCLUDE[vbprvb](../../../includes/vbprvb-md.md)] y F# para proporcionar programación asincrónica. Estos componentes de flujo de datos son útiles cuando se tienen varias operaciones que deben comunicarse entre sí de forma asincrónica, o cuando se desea procesar datos a medida que estén disponibles. Por ejemplo, piense en una aplicación que procesa datos de imagen de una cámara web. Con el modelo de flujo de datos, la aplicación puede procesar fotogramas de imagen a medida que estén disponibles. Si la aplicación mejora fotogramas de imagen, por ejemplo, mediante la realización de una corrección o reduciendo ojos rojos, puede crear un *canalización* de componentes de flujo de datos. Cada fase de la canalización puede utilizar más funcionalidad de paralelismo de grano grueso, como la funcionalidad proporcionada por la biblioteca TPL, para transformar la imagen.  
  
 En este documento se proporciona información general sobre la biblioteca de flujos de datos TPL. Se describe el modelo de programación, los tipos de bloques de flujo de datos predefinidos y cómo configurar bloques de flujo de datos para satisfacer las necesidades específicas de las aplicaciones.  
  
> [!TIP]
>  La biblioteca de TPL Dataflow (<xref:System.Threading.Tasks.Dataflow?displayProperty=fullName> espacio de nombres) no se distribuye con el [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]. Para instalar el <xref:System.Threading.Tasks.Dataflow> espacio de nombres, abra el proyecto en [!INCLUDE[vs_dev11_long](../../../includes/vs-dev11-long-md.md)], elija **administrar paquetes de NuGet** en el menú proyecto y busque en línea el `Microsoft.Tpl.Dataflow` paquete.  
  
 Este documento contiene las siguientes secciones:  
  
-   [Modelo de programación](#model)  
  
-   [Tipos de bloques de flujo de datos predefinidos](#predefined_types)  
  
-   [Configurar el comportamiento del bloque de flujo de datos](#behavior)  
  
-   [Bloques de flujo de datos personalizados](#custom)  
  
<a name="model"></a>   
## <a name="programming-model"></a>Modelo de programación  
 La biblioteca de flujos de datos TPL proporciona una base para el paso de mensajes y para paralelizar aplicaciones que consumen mucha CPU, así como aplicaciones intensivas de entrada y salida con alto rendimiento y latencia baja. También ofrece el control explícito sobre cómo almacenar los datos en búfer y desplazarlos alrededor del sistema. Para entender mejor el modelo de programación de flujo de datos, piense en una aplicación que de forma asincrónica carga imágenes desde el disco y crea un compuesto de esas imágenes. Los modelos de programación tradicionales suelen usar devoluciones de llamada y objetos de sincronización, como bloqueos, para coordinar tareas y tener acceso a datos compartidos. Con el modelo de programación de flujo de datos, puede crear objetos de flujo de datos que procesan las imágenes como se leen desde el disco. Bajo el modelo de flujo de datos, se declara cómo se controlan los datos cuando están disponibles, así como las dependencias entre datos. Dado que el runtime administra las dependencias entre datos, se puede evitar a menudo la necesidad de sincronizar el acceso a los datos compartidos. Además, dado que el runtime programa el trabajo según la llegada asincrónica de datos, el flujo de datos puede mejorar la capacidad de respuesta y el nivel de rendimiento administrando de forma eficaz los subprocesos subyacentes. Para obtener un ejemplo que utiliza el modelo de programación de flujo de datos para implementar el procesamiento de imágenes en una aplicación de formularios Windows Forms, vea [Tutorial: usar el flujo de datos en una aplicación de Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
### <a name="sources-and-targets"></a>Orígenes y destinos  
 La biblioteca de flujo de datos TPL consta de *bloques de flujo de datos*, que son estructuras de datos ese búfer y procesar datos. La biblioteca TPL define tres tipos de bloques de flujo de datos: *bloques de origen*, *bloques de destino*, y *bloques propagadores*. Un bloque de origen actúa como un origen de datos y se puede leer desde él. Un bloque de destino actúa como un receptor de datos y se puede escribir en él. Un bloque propagador actúa como un bloque de origen y un bloque de destino, y se puede leer desde él y escribir en él. La biblioteca TPL define la <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601?displayProperty=fullName> interfaz para representar orígenes, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601?displayProperty=fullName> para representar destinos y <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602?displayProperty=fullName> para representar propagadores.</TInput, TOutput> <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> hereda de <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, y <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.\</TInput, TOutput>  
  
 La biblioteca de flujo de datos TPL proporciona varios tipos de bloques de flujo de datos predefinidos que implementan la <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>, y <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> interfaces.\</TInput, TOutput> Estos tipos de bloques de flujo de datos se describen en este documento en la sección [tipos de bloques de flujo de datos predefinidos](#predefined_types).  
  
### <a name="connecting-blocks"></a>Conectar bloques  
 Puede conectar los bloques de flujo de datos al formulario *canalizaciones*, que son secuencias lineales de bloques de flujo de datos, o *redes*, que son gráficos de bloques de flujo de datos. Una canalización es una forma de red. En una canalización o red, los orígenes propagan datos de forma asincrónica en destinos a medida que esos datos están disponibles. El <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=fullName> método vincula un bloque de origen a un bloque de destino. Un origen puede vincularse a cero o más destinos; los destinos se pueden vincular a partir de cero o más orígenes. Puede agregar o quitar bloques de flujo de datos hacia o desde una canalización o red simultáneamente. Los tipos de bloques de flujo de datos predefinidos controlan todos los aspectos de la seguridad para subprocesos de vinculación y desvinculación.  
  
 Para obtener un ejemplo que conecta los bloques de flujo de datos para formar una canalización básica, vea [Tutorial: crear una canalización de flujo de datos](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md). Para obtener un ejemplo que conecta los bloques de flujo de datos para formar una red más compleja, vea [Tutorial: usar el flujo de datos en una aplicación de Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md). Para obtener un ejemplo que desvincula un destino de un origen después de que el origen proporciona el destino de un mensaje, vea [Cómo: desvincular bloques de flujo de datos](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md).  
  
#### <a name="filtering"></a>Filtrado  
 Cuando se llama a la <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=fullName> método para vincular un origen a un destino, puede proporcionar un delegado que determina si el bloque de destino acepta o rechaza un mensaje basándose en el valor de ese mensaje. Este mecanismo de filtrado resulta útil para garantizar que un bloque de flujo de datos recibe solo ciertos valores. Para la mayoría de los tipos de bloques de flujo de datos predefinidos, si un bloque de origen está conectado a varios bloques de destino, cuando un bloque de destino rechaza un mensaje, el origen proporciona ese mensaje al destino siguiente. El orden en el que un origen proporciona mensajes a los destinos se define mediante el origen y puede variar según el tipo de origen. La mayoría de los tipos de bloques de origen dejan de proporcionar un mensaje después de que un destino acepta ese mensaje. Una excepción a esta regla es la <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> (clase), que proporciona cada mensaje a todos los destinos, aunque algunos destinos rechacen el mensaje. Para obtener un ejemplo que usa el filtrado para procesar únicamente determinados mensajes, consulte [Tutorial: usar el flujo de datos en una aplicación de Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
> [!IMPORTANT]
>  Dado que cada tipo de bloque de flujo de datos de origen predefinido garantiza que los mensajes se propaguen en el orden en que se reciben, se debe leer cada mensaje desde el bloque de origen antes de que el bloque de origen pueda procesar el mensaje siguiente. Por consiguiente, si usa el filtrado para conectarse varios destinos a un origen, asegúrese de que al menos un bloque de destino recibe cada mensaje. De lo contrario, la aplicación podría generar un interbloqueo.  
  
### <a name="message-passing"></a>Paso de mensajes  
 El modelo de programación de flujo de datos está relacionado con el concepto de *pasar mensajes*, donde los componentes independientes de un programa comunican entre sí enviándose mensajes. Una manera de propagar mensajes entre los componentes de la aplicación es llamar a la <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> y <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A?displayProperty=fullName> métodos para enviar mensajes a los bloques de flujo de datos de destino (<xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> actúa de forma sincrónica; <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A> actúa de forma asincrónica) y la <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Receive%2A>, <xref:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync%2A>, y <xref:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive%2A> métodos para recibir mensajes de los bloques de origen. Puede combinar estos métodos con las canalizaciones o redes de flujo de datos enviando datos de entrada al nodo principal (un bloque de destino) y recibiendo datos de salida del nodo terminal de la canalización o de los nodos terminales de la red (uno o varios bloques de origen). También puede utilizar el <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Choose%2A> método para leer desde el primero de los orígenes proporcionados siempre que tenga datos disponibles y realice acciones sobre esos datos.  
  
 Bloques de origen proporcionan datos a los bloques de destino mediante una llamada a la <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A?displayProperty=fullName> método. El bloque de destino responde a un mensaje proporcionado de una de estas tres maneras: puede aceptar el mensaje, rechazar el mensaje o posponer el mensaje. Cuando el destino acepta el mensaje, el <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> método devuelve <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus>. Cuando el destino rechaza el mensaje, el <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> método devuelve <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus>. Cuando el destino requiere que ya no recibe los mensajes del origen de <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> devuelve <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus>. Los tipos de bloques de origen predefinidos no proporcionan mensajes a los destinos vinculados después de recibir este valor devuelto, y automáticamente se desvinculan de estos destinos.  
  
 Cuando un bloque de destino pospone el mensaje para su uso posterior, el <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> método devuelve <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus>. Un bloque de destino que pospone un mensaje puede llamar posteriormente el <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A?displayProperty=fullName> método para intentar reservar el mensaje proporcionado. En este punto, el mensaje todavía permanece disponible y lo puede usar el bloque de destino, o puede que otro destino haya tomado el mensaje. Cuando el bloque de destino requiere el mensaje posteriormente o ya no necesita el mensaje, llama a la <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=fullName> o <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A> método, respectivamente. La reserva de mensajes la utilizan normalmente los tipos de bloques de flujo de datos que trabajan en modo no expansivo. El modo no expansivo se explica más adelante en este documento. En lugar de reservar un mensaje pospuesto, un bloque de destino también puede utilizar el <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=fullName> método para intentar utilizar directamente el mensaje pospuesto.  
  
### <a name="dataflow-block-completion"></a>Finalización del bloque de flujo de datos  
 Bloques de flujo de datos también admiten el concepto de *finalización*. Un bloque de flujo de datos que está en estado completado no realiza ningún trabajo posterior. Cada bloque de flujo de datos tiene asociado un <xref:System.Threading.Tasks.Task?displayProperty=fullName> objeto, conocido como un *tarea de finalización*, que representa el estado de finalización del bloque. Dado que puede esperar un <xref:System.Threading.Tasks.Task> para terminar, mediante tareas de finalización, puede esperar uno o más nodos terminales de un flujo de datos de red a fin de objeto. El <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> interfaz define el <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> método, que informa al bloque de flujo de datos de una solicitud para que se complete, y el <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> propiedad, que devuelve la tarea de finalización para el bloque. Ambos <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> y <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> heredan la <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> interfaz.  
  
 Hay dos maneras de determinar si un bloque de flujo de datos se completó sin error, encontró uno o más errores, o se canceló. La primera manera es llamar a la <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=fullName> método en la tarea de finalización de un `try` - `catch` bloque (`Try` - `Catch` en Visual Basic). En el ejemplo siguiente se crea un <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> objeto que produce <xref:System.ArgumentOutOfRangeException> si el valor de entrada es menor que cero. <xref:System.AggregateException> se produce cuando se llama a este ejemplo <xref:System.Threading.Tasks.Task.Wait%2A> en la tarea de finalización. El <xref:System.ArgumentOutOfRangeException> se tiene acceso mediante la <xref:System.AggregateException.InnerExceptions%2A> propiedad de la <xref:System.AggregateException> objeto.  
  
 [!code-csharp[TPLDataflow_Overview#10](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#10)]
 [!code-vb[TPLDataflow_Overview#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#10)]  
  
 En este ejemplo se muestra el caso en el que una excepción no está controlada en el delegado de un bloque de flujo de datos de ejecución. Se recomienda controlar las excepciones en los cuerpos de estos bloques. Sin embargo, si no puede hacerlo, el bloque se comporta como si estuviera cancelado y no procesa los mensajes entrantes.  
  
 Cuando un bloque de flujo de datos se cancela explícitamente, el <xref:System.AggregateException> objeto contiene <xref:System.OperationCanceledException> en el <xref:System.AggregateException.InnerExceptions%2A> propiedad. Para obtener más información sobre la cancelación del flujo de datos, vea Habilitar la cancelación más adelante en este documento.  
  
 La segunda manera de determinar el estado de finalización de un bloque de flujo de datos es usar una continuación fuera de la tarea de finalización o utilizar las características de lenguaje asincrónicas de C# y Visual Basic para esperar a la tarea de finalización de forma asincrónica. El delegado que proporciona a la <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=fullName> método toma un <xref:System.Threading.Tasks.Task> objeto que representa la tarea anterior. En el caso de la <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> propiedad, el delegado de continuación toma la propia tarea de finalización. En el siguiente ejemplo se parece el anterior, excepto que también utiliza la <xref:System.Threading.Tasks.Task.ContinueWith%2A> método para crear una tarea de finalización que imprime el estado de la operación de flujo de datos global.  
  
 [!code-csharp[TPLDataflow_Overview#11](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#11)]
 [!code-vb[TPLDataflow_Overview#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#11)]  
  
 También puede usar propiedades como <xref:System.Threading.Tasks.Task.IsCanceled%2A> en el cuerpo de la tarea de continuación para determinar información adicional sobre el estado de finalización de un bloque de flujo de datos. Para obtener más información sobre las tareas de continuación y cómo se relacionan con cancelación y control de errores, vea [encadenar tareas mediante tareas de continuación](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md), [cancelación de tareas](../../../docs/standard/parallel-programming/task-cancellation.md), [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md), y [NIB: Cómo: controlar excepciones iniciadas por tareas](http://msdn.microsoft.com/es-es/d6c47ec8-9de9-4880-beb3-ff19ae51565d).  
  
 [[go to top](#top)]  
  
<a name="predefined_types"></a>   
## <a name="predefined-dataflow-block-types"></a>Tipos de bloques de flujo de datos predefinidos  
 La biblioteca de flujos de datos TPL proporciona varios tipos de bloques de flujo de datos predefinidos. Estos tipos se dividen en tres categorías: *el búfer bloques*, *bloques de ejecución*, y *bloques de agrupación*. En las secciones siguientes se describen los tipos de bloques que componen estas categorías.  
  
### <a name="buffering-blocks"></a>Bloques de almacenamiento en búfer  
 Los bloques de almacenamiento en búfer contiene datos para su uso por los consumidores de datos. La biblioteca de flujo de datos TPL proporciona tres tipos de bloques de almacenamiento en búfer: <xref:System.Threading.Tasks.Dataflow.BufferBlock%601?displayProperty=fullName>, <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601?displayProperty=fullName>, y <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601?displayProperty=fullName>.  
  
#### <a name="bufferblockt"></a>BufferBlock(T)  
 El <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> clase representa una estructura de mensajería asincrónica de uso general. Esta clase almacena una cola FIFO (primero en entrar, primero en salir) de mensajes donde varios orígenes pueden escribir o de los que varios destinos pueden leer. Cuando un destino recibe un mensaje desde una <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> objeto, ese mensaje se quita de la cola de mensajes. Por lo tanto, aunque un <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> objeto puede tener varios destinos, solo uno recibirá cada mensaje. El <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> clase es útil si desea pasar varios mensajes a otro componente, y ese componente debe recibir cada mensaje.  
  
 El siguiente ejemplo básico se expone varios <xref:System.Int32> valores para una <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> de objetos y, a continuación, se leen esos valores desde ese objeto.  
  
 [!code-csharp[TPLDataflow_Overview#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#1)]
 [!code-vb[TPLDataflow_Overview#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#1)]  
  
 Para obtener un ejemplo completo que muestra cómo escribir y leer los mensajes de una <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> de objeto, vea [Cómo: escribir mensajes y leer los mensajes de Dataflow Block](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md).  
  
#### <a name="broadcastblockt"></a>BroadcastBlock(T)  
 El <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> clase es útil si debe pasar varios mensajes a otro componente, pero este componente necesita sólo el valor más reciente. Esta clase también resulta útil si desea difundir un mensaje a varios componentes.  
  
 El siguiente ejemplo básico se publica un <xref:System.Double> valor a un <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> objeto y, a continuación, lee ese valor desde el objeto varias veces. Dado que no se quitan los valores de <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> objetos después de leerlos, el mismo valor está disponible cada vez.  
  
 [!code-csharp[TPLDataflow_Overview#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#2)]
 [!code-vb[TPLDataflow_Overview#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#2)]  
  
 Para obtener un ejemplo completo que muestra cómo utilizar <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> para difundir un mensaje a varios bloques de destino, consulte [Cómo: especificar un programador de tareas en un Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md).  
  
#### <a name="writeonceblockt"></a>WriteOnceBlock(T)  
 El <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> clase es similar a la <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> clase, salvo que un <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> objeto puede escribirse en una sola vez. Puede pensar en <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> es similar a la de C# [readonly](../Topic/readonly%20\(C%23%20Reference\).md) ([ReadOnly](../Topic/ReadOnly%20\(Visual%20Basic\).md) en [!INCLUDE[vbprvb](../../../includes/vbprvb-md.md)]) (palabra clave), salvo que un <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> objeto se vuelve inalterable después de recibir un valor en lugar de construcción. Como el <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> (clase), cuando un destino recibe un mensaje desde una <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> objeto, ese mensaje no se quita de dicho objeto. Por tanto, varios destinos reciben una copia del mensaje. El <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> clase resulta útil si desea difundir solamente el primero de varios mensajes.  
  
 El siguiente ejemplo básico se expone varios <xref:System.String> valores para una <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> objeto y, a continuación, lee el valor de dicho objeto. Dado que un <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> objeto se puede escribir una vez, después de un <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> objeto recibe un mensaje, descarta los mensajes subsiguientes.  
  
 [!code-csharp[TPLDataflow_Overview#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#3)]
 [!code-vb[TPLDataflow_Overview#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#3)]  
  
 Para obtener un ejemplo completo que muestra cómo utilizar <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> para recibir el valor de la primera operación que finaliza, consulte [Cómo: desvincular bloques de flujo de datos](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md).  
  
### <a name="execution-blocks"></a>Bloques de ejecución  
 Los bloques de ejecución llaman a un delegado proporcionado por el usuario para cada fragmento de datos recibidos. La biblioteca de flujo de datos TPL proporciona tres tipos de bloques de ejecución: <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602?displayProperty=fullName>, y <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602?displayProperty=fullName>.\</TInput, TOutput> \</TInput, TOutput>  
  
#### <a name="actionblockt"></a>ActionBlock(T)  
 El <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> clase es un bloque de destino que llama a un delegado cuando recibe datos. Piense en un <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> objeto como un delegado que se ejecuta de forma asincrónica cuando los datos están disponibles. El delegado que se proporciona a un <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> objeto puede ser de tipo <xref:System.Action> o tipo `System.Func\<TInput, Task>`. Cuando se usa un <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> objeto con <xref:System.Action>, procesamiento de cada elemento de entrada se considera completada cuando vuelve el delegado. Cuando se usa un <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> objeto con `System.Func\<TInput, Task>`, procesamiento de cada elemento de entrada se considera completado solamente cuando el valor devuelto <xref:System.Threading.Tasks.Task> objeto se complete. Mediante estos dos mecanismos, puede usar <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> para el procesamiento sincrónico y asincrónico de cada elemento de entrada.  
  
 El siguiente ejemplo básico se expone varios <xref:System.Int32> valores para una <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> objeto. El <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> objeto imprime esos valores en la consola. Después, en este ejemplo se establece el bloque en estado completado y se espera hasta que finalicen todas las tareas de flujo de datos.  
  
 [!code-csharp[TPLDataflow_Overview#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#4)]
 [!code-vb[TPLDataflow_Overview#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#4)]  
  
 Para obtener ejemplos completos que muestran cómo utilizar delegados con la <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> de clases, consulte [Cómo: realizar acción cuando un flujo de datos recibe datos del bloque](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
#### <a name="transformblocktinput-toutput"></a>TransformBlock(TInput, TOutput)  
 El <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> clase es similar a la <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> clase salvo que actúa como origen y como destino.\</TInput, TOutput> El delegado que se pasa a un <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> objeto devuelve un valor de tipo `TOutput`.</TInput, TOutput> El delegado que se proporciona a un <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> objeto puede ser de tipo `System.Func<TInput, TOutput>` o tipo `System.Func<TInput, Task>`.\</TInput, TOutput> Cuando se usa un <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> objeto con `System.Func\<TInput, TOutput>`, procesamiento de cada elemento de entrada se considera completada cuando vuelve el delegado.</TInput, TOutput> Cuando se usa un <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> objeto usado con `System.Func<TInput, Task<TOutput>>`, procesamiento de cada elemento de entrada se considera completado solamente cuando el valor devuelto <xref:System.Threading.Tasks.Task> objeto se ha completado.\</TInput, TOutput> Al igual que con <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, mediante el uso de estos dos mecanismos, puede usar <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> para el procesamiento sincrónico y asincrónico de cada elemento de entrada.\</TInput, TOutput>  
  
 El siguiente ejemplo básico se crea un <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> objeto que calcula la raíz cuadrada de la entrada.</TInput, TOutput> El <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> objeto toma <xref:System.Int32> valores como entrada y genera <xref:System.Double> valores como salida.\</TInput, TOutput>  
  
 [!code-csharp[TPLDataflow_Overview#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#5)]
 [!code-vb[TPLDataflow_Overview#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#5)]  
  
 Para obtener ejemplos completos que usa <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> en una red de bloques de flujo de datos que realiza el procesamiento de imágenes en una aplicación de formularios Windows Forms, vea [Tutorial: usar el flujo de datos en una aplicación de Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).\</TInput, TOutput>  
  
#### <a name="transformmanyblocktinput-toutput"></a>TransformManyBlock(TInput, TOutput)  
 El <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> clase es similar a la <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> clase salvo que <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> produce cero o más valores de salida para cada valor de entrada, en lugar de solo uno valor de salida por cada valor de entrada.</TInput, TOutput> </TInput, TOutput> </TInput, TOutput> El delegado que se proporciona a un <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> objeto puede ser de tipo `System.Func<TInput, IEnumerable<TOutput>>` o `type System.Func<TInput, Task<IEnumerable<TOutput>>>`.\</TInput, TOutput> Cuando se usa un <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> objeto con `System.Func<TInput, IEnumerable<TOutput>>`, procesamiento de cada elemento de entrada se considera completada cuando vuelve el delegado.</TInput, TOutput> Cuando se usa un <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> objeto con `System.Func<TInput, Task<IEnumerable<TOutput>>>`, procesamiento de cada elemento de entrada se considera completado solo cuando el valor devuelto `System.Threading.Tasks.Task<IEnumerable<TOutput>>` objeto se ha completado.\</TInput, TOutput>  
  
 El siguiente ejemplo básico se crea un <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> objeto que divide las cadenas en sus secuencias de caracteres individuales.</TInput, TOutput> El <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> objeto toma <xref:System.String> valores como entrada y genera <xref:System.Char> valores como salida.\</TInput, TOutput>  
  
 [!code-csharp[TPLDataflow_Overview#6](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#6)]
 [!code-vb[TPLDataflow_Overview#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#6)]  
  
 Para obtener ejemplos completos que usan <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> para generar varias salidas independientes para cada entrada en una canalización de flujo de datos, vea [Tutorial: crear una canalización de flujo de datos](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md).\</TInput, TOutput>  
  
#### <a name="degree-of-parallelism"></a>Grado de paralelismo  
 Cada <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, y <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> mensajes de entrada de búferes del objeto hasta que el bloque está listo para procesarlos.</TInput, TOutput> </TInput, TOutput> De forma predeterminada, estas clases procesan los mensajes en el orden en el que se recibieron, un mensaje cada vez. También puede especificar el grado de paralelismo para permitir <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> y <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> objetos para procesar varios mensajes simultáneamente.\</TInput, TOutput> \</TInput, TOutput> Para obtener más información sobre la ejecución simultánea, vea la sección Especificar el grado de paralelismo más adelante en este documento. Para obtener un ejemplo que establece el grado de paralelismo para permitir que un bloque de flujo de datos de ejecución pueda procesar varios mensajes a la vez, consulte [Cómo: especificar el grado de paralelismo en un Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
#### <a name="summary-of-delegate-types"></a>Resumen de tipos de delegado  
 En la tabla siguiente resume los tipos de delegado que puede proporcionar a <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, y <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> objetos.\</TInput, TOutput> \</TInput, TOutput> En esta tabla también se especifica si el tipo de delegado funciona de forma sincrónica o asincrónica.  
  
|Tipo|Tipo de delegado sincrónico|Tipo de delegado asincrónico|  
|----------|-------------------------------|--------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|`System.Action`|`System.Func\<TInput, Task>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602></TInput, TOutput>|`System.Func\<TInput, TOutput>`2`|`System.Func<TInput, Task<TOutput>>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602></TInput, TOutput>|`System.Func<TInput, IEnumerable<TOutput>>`|`System.Func<TInput, Task<IEnumerable<TOutput>>>`|  
  
 También puede utilizar expresiones lambda cuando trabaja con tipos de bloque de ejecución. Para obtener un ejemplo que muestra cómo utilizar una expresión lambda con un bloque de ejecución, consulte [Cómo: realizar acción cuando un flujo de datos recibe datos del bloque](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
### <a name="grouping-blocks"></a>Bloques de agrupación  
 Los bloques de agrupación combinan datos de uno o más orígenes y con distintas restricciones. La biblioteca de flujo de datos TPL proporciona tres tipos de bloques de combinación: <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, y <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>.\</T1, T2> \</T1, T2>  
  
#### <a name="batchblockt"></a>BatchBlock(T)  
 El <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> clase combina los conjuntos de datos de entrada, que se conocen como lotes, en las matrices de datos de salida. Especificar el tamaño de cada lote cuando se crea un <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> objeto. Cuando el <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> objeto recibe el número especificado de elementos de entrada, propaga de forma asincrónica una matriz que contiene los elementos. Si un <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> objeto se establece en el estado completado pero no contiene elementos suficientes para formar un lote, propaga una matriz final que contiene los elementos restantes de entrada.  
  
 El <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> clase funciona en modo *expansiva* o *no expansivo* modo. En modo expansivo, que es el valor predeterminado, un <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> objeto acepta todos los mensajes que se proporciona y propaga una matriz después de recibir el número especificado de elementos. En modo no expansivo, un <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> objeto pospone todos los mensajes entrantes hasta que suficientes orígenes que proporcionen mensajes al bloque para formar un lote. Normalmente, el modo expansivo se comporta mejor que el modo no expansivo porque requiere menos sobrecarga de procesamiento. Sin embargo, se puede usar el modo no expansivo cuando se debe coordinar el consumo de varios orígenes en modo atómico. Especifica el modo no expansivo estableciendo <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> a `False` en el `dataflowBlockOptions` parámetro en el <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.%23ctor%2A> constructor.  
  
 El siguiente ejemplo básico se expone varios <xref:System.Int32> valores para una <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> objeto que contiene diez elementos en un lote. Para garantizar que todos los valores se propagan fuera de la <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, este ejemplo llama a la <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> método. El <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> método establece la <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> objeto al estado completado y por lo tanto, la <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> objeto propaga cualquier elemento restante como un lote final.  
  
 [!code-csharp[TPLDataflow_Overview#7](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#7)]
 [!code-vb[TPLDataflow_Overview#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#7)]  
  
 Para obtener un ejemplo completo que usa <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> para mejorar la eficacia de las operaciones de inserción de base de datos, vea [Tutorial: usar BatchBlock y BatchedJoinBlock para mejorar la eficacia](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  
  
#### <a name="joinblockt1-t2-"></a>JoinBlock(T1, T2, ...)  
 El <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> y <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> clases obtienen elementos de entrada y propagan <xref:System.Tuple%602?displayProperty=fullName> o <xref:System.Tuple%603?displayProperty=fullName> objetos que contienen esos elementos.\</T1, T2, T3> \</T1, T2> \</T1, T2, T3> \</T1, T2> El <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> y <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> clases no heredan de <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.</T1, T2, T3> </T1, T2> En su lugar, proporcionan propiedades, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target1%2A>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target2%2A>, y <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Target3%2A>, que implementan <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.  
  
 Como <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> y <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> funcionar en modo expansivo o no expansivo.</T1, T2, T3> </T1, T2> En modo expansivo, que es el valor predeterminado, un <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> o <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> objeto acepta todos los mensajes que se proporciona y propaga una tupla después de cada uno de sus destinos reciba al menos un mensaje.</T1, T2, T3> </T1, T2> En modo no expansivo, un <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> o <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> objeto pospone todos los mensajes entrantes hasta que todos los destinos han proporcionado los datos que se requiere para crear una tupla.\</T1, T2, T3> \</T1, T2> En este punto, el bloque se involucra en un protocolo de confirmación en dos fases para recuperar atómicamente todos los elementos necesarios de los orígenes. Este aplazamiento permite que, mientras tanto, otra entidad consuma datos, para permitir que el sistema global progrese.  
  
 El siguiente ejemplo básico muestra un caso en que un <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> objeto requiere varios datos para calcular un valor.</T1, T2, T3> Este ejemplo se crea un <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> objeto que requiere dos <xref:System.Int32> valores y un <xref:System.Char> valor para realizar una operación aritmética.\</T1, T2, T3>  
  
 [!code-csharp[TPLDataflow_Overview#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#8)]
 [!code-vb[TPLDataflow_Overview#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#8)]  
  
 Para obtener un ejemplo completo que usa <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> objetos en modo no expansivo para compartir de forma cooperativa un recurso, vea [Cómo: usar JoinBlock para leer datos desde varios orígenes](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md).\</T1, T2>  
  
#### <a name="batchedjoinblockt1-t2-"></a>BatchedJoinBlock(T1, T2, ...)  
 El <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> y <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603> clases obtienen lotes de elementos de entrada y propagan `System.Tuple(IList(T1), IList(T2))` o `System.Tuple(IList(T1), IList(T2), IList(T3))` objetos que contienen esos elementos.\</T1, T2, T3> \</T1, T2> Piense en <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> como una combinación de <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> y <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>.</T1, T2> </T1, T2> Especificar el tamaño de cada lote cuando se crea un <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> objeto.\</T1, T2> <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> también proporciona propiedades, <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> y <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A>, que implementan <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.\</T1, T2> Cuando se recibe el número especificado de elementos de entrada a través de todos los destinos, el <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> objeto propaga de forma asincrónica un `System.Tuple(IList(T1), IList(T2))` objeto que contiene esos elementos.\</T1, T2>  
  
 El siguiente ejemplo básico se crea un <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> objeto que contiene los resultados, <xref:System.Int32> valores y errores que son <xref:System.Exception> objetos.</T1, T2> En este ejemplo se realizan varias operaciones y se escriben los resultados en la <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> propiedad y los errores a la <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A> propiedad, de la <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> objeto.\</T1, T2> Dado que el recuento de operaciones correctas e incorrectas se conoce de antemano, el <xref:System.Collections.Generic.IList%601> objetos permiten que cada destino reciba cero o más valores.  
  
 [!code-csharp[TPLDataflow_Overview#9](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#9)]
 [!code-vb[TPLDataflow_Overview#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#9)]  
  
 Para obtener un ejemplo completo que usa <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> para capturar los resultados y las excepciones que se producen mientras el programa lee de una base de datos, vea [Tutorial: usar BatchBlock y BatchedJoinBlock para mejorar la eficacia](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).\</T1, T2>  
  
 [[go to top](#top)]  
  
<a name="behavior"></a>   
## <a name="configuring-dataflow--block-behavior"></a>Configurar el comportamiento del bloque de flujo de datos  
 Puede habilitar opciones adicionales si proporciona un <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=fullName> objeto al constructor de tipos de bloques de flujo de datos. Estas opciones controlan el comportamiento, como el del programador que administra la tarea subyacente, y el grado de paralelismo. El <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> también tiene tipos derivados que especifican el comportamiento es específico de ciertos tipos de bloques de flujo de datos. En la tabla siguiente se resumen los tipo de opciones que se asocian a cada tipo de bloques de flujo de datos.  
  
|Tipo de bloques de flujo de datos|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> tipo|  
|-------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.BufferBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>\</TInput, TOutput>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>\</TInput, TOutput>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchBlock%601>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.JoinBlock%602>\</T1, T2>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>\</T1, T2>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
  
 Las secciones siguientes proporcionan información adicional acerca de los tipos de flujo de datos importantes de opciones de bloque que están disponibles a través de la <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=fullName>, <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions?displayProperty=fullName>, y <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions?displayProperty=fullName> clases.  
  
### <a name="specifying-the-task-scheduler"></a>Especificar el programador de tareas  
 Cada bloque de flujo de datos predefinido utiliza el mecanismo de programación de tareas de la biblioteca TPL para realizar actividades como propagar datos a un destino, recibir datos de un origen y ejecutar delegados definido por el usuario si los datos están disponibles. <xref:System.Threading.Tasks.TaskScheduler> es una clase abstracta que representa un programador de tareas que pone en cola tareas en los subprocesos. El programador de tareas predeterminado, <xref:System.Threading.Tasks.TaskScheduler.Default%2A>, usa el <xref:System.Threading.ThreadPool> clase poner en cola y ejecutar el trabajo. Puede reemplazar el programador de tareas predeterminado estableciendo la <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.TaskScheduler%2A> propiedad cuando se construye un objeto de bloque de flujo de datos.  
  
 Cuando el mismo programador de tareas administra varios bloques de flujo de datos, puede aplicar directivas entre ellos. Por ejemplo, si varios bloques de flujo de datos están configurados para el destino del programador exclusivo del mismo <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> objeto, todo el trabajo que se ejecuta a través de estos bloques se serializa. De forma similar, si estos bloques se configuran como destino del programador simultáneo del mismo <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> objeto y el programador está configurada para tener un nivel de simultaneidad máximo, todo el trabajo de estos bloques se limita a ese número de operaciones simultáneas. Para obtener un ejemplo que utiliza la <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> clase para permitir operaciones de lectura en paralelo, pero escribir las operaciones que ocurren exclusivamente en todas las operaciones, consulte [Cómo: especificar un programador de tareas en un Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md). Para obtener más información acerca de los programadores de tareas en la biblioteca TPL, vea la <xref:System.Threading.Tasks.TaskScheduler> tema de la clase.  
  
### <a name="specifying-the-degree-of-parallelism"></a>Especificar el grado de Paralelismo  
 De forma predeterminada, los tipos de bloques de tres ejecución que proporciona la biblioteca de TPL Dataflow, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, y <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>, procesar un mensaje a la vez.\</TInput, TOutput> \</TInput, TOutput> Estos tipos de bloques de flujo de datos también procesan mensajes en el orden en que se reciben. Para habilitar estos bloques de flujo de datos procesar mensajes de forma simultánea, establezca el <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A?displayProperty=fullName> propiedad cuando se construye el objeto de bloques de flujo de datos.  
  
 El valor predeterminado de <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> es 1, lo que garantiza que el bloque procesa un mensaje a la vez. Al establecer esta propiedad en un valor mayor de 1 se permite que el bloque de flujo de datos procese varios mensajes simultáneamente. Establecer esta propiedad en <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=fullName> permite que el programador de tareas subyacente administre el grado máximo de simultaneidad.  
  
> [!IMPORTANT]
>  Cuando se especifica un grado máximo de paralelismo mayor que 1, varios mensajes se procesan simultáneamente y, por consiguiente, los mensajes no se pueden procesar en el orden en que se reciben. El orden en que los mensajes se generan desde el bloque, sin embargo, se ordenarán correctamente.  
  
 Dado que la <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> propiedad representa el grado máximo de paralelismo, el bloque puede ejecutarse con un menor grado de paralelismo que el especificado. El bloque de flujo de datos puede utilizar un menor grado de paralelismo para cumplir los requisitos funcionales o porque hay una falta de recursos del sistema disponibles. Un flujo de datos bloqueado nunca elige más paralelismo que el especificado.  
  
 El valor de la <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> propiedad es exclusivo para cada objeto de bloque de flujo de datos. Por ejemplo, si cuatro objetos de bloques de flujo de datos especifican 1 como el grado máximo de paralelismo, los cuatro objetos de bloques de flujo de datos podrían ejecutarse en paralelo.  
  
 Para obtener un ejemplo que establece el grado máximo de paralelismo para permitir operaciones largas se produzcan en paralelo, vea [Cómo: especificar el grado de paralelismo en un Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
### <a name="specifying-the-number-of-messages-per-task"></a>Especificar el número de mensajes por tarea  
 Los tipos predefinidos de bloques de flujo de datos utilizan tareas para procesar varios elementos de entrada. Esto ayuda a minimizar el número de objetos de tarea necesarios para procesar datos, lo que permite que las aplicaciones se ejecuten más eficazmente. Sin embargo, cuando las tareas de un conjunto de bloques de flujo de datos están procesando datos, es posible que las tareas de otros bloques de flujo de datos tengan que esperar el tiempo de procesamiento en la cola mensajes. Para habilitar una mejor equidad entre tareas de flujo de datos, establezca la <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> propiedad. Cuando <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> está establecido en <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=fullName>, que es el valor predeterminado, la tarea utilizada por un bloque de flujo de datos procesa tantos mensajes como están disponibles. Cuando <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> se establece en un valor distinto de <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded>, el bloque procesa como máximo este número de mensajes por <xref:System.Threading.Tasks.Task> objeto. Aunque al establecer el <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> propiedad puede aumentar la equidad entre tareas, puede provocar que el sistema cree más tareas que son necesarios, lo que puede disminuir el rendimiento.  
  
### <a name="enabling-cancellation"></a>Habilitar la cancelación  
 La biblioteca TPL proporciona un mecanismo que habilita las tareas para coordinar la cancelación de manera cooperativa. Para habilitar los bloques de flujo de datos puedan participar en este mecanismo de cancelación, establezca el <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.CancellationToken%2A> propiedad. Cuando esto <xref:System.Threading.CancellationToken> objeto se establece en el estado cancelado, todos los bloques de flujo de datos que controlan este token finalizan la ejecución de su elemento actual pero no comienzan a procesar los elementos siguientes. Estos bloques de flujo de datos también borran los mensajes almacenados en búfer, conexiones de inicio para los bloques de origen y de destino, y la transición al estado cancelado. Al realizar la transición al estado cancelado, el <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> propiedad tiene la <xref:System.Threading.Tasks.Task.Status%2A> propiedad establecida en <xref:System.Threading.Tasks.TaskStatus>, a menos que se produjo una excepción durante el procesamiento. En ese caso, <xref:System.Threading.Tasks.Task.Status%2A> está establecido en <xref:System.Threading.Tasks.TaskStatus>.  
  
 Para obtener un ejemplo que muestra cómo usar la cancelación en una aplicación de formularios Windows Forms, vea [Cómo: cancelar un Dataflow Block](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md). Para obtener más información sobre la cancelación en la biblioteca TPL, vea [cancelación de tareas](../../../docs/standard/parallel-programming/task-cancellation.md).  
  
### <a name="specifying-greedy-versus-non-greedy-behavior"></a>Especificar el comportamiento expansivo frente al no expansivo  
 Varios tipos de bloques de flujo de datos de agrupación pueden trabajar en modo *expansiva* o *no expansivo* modo. De forma predeterminada, los tipos de bloques de flujo de datos predefinidos funcionan en modo expansivo.  
  
 Para la combinación de tipos de bloques como <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, el modo expansivo significa que el bloque acepta datos inmediatamente aunque los correspondientes datos con el que se va a unir no están disponibles.</T1, T2> El modo no expansivo significa que el bloque pospone todos los mensajes entrantes hasta que uno esté disponible para cada uno de sus destinos para completar la combinación. Si los mensajes pospuestos ya no están disponibles, el bloque de combinación libera todos los mensajes pospuestos y reinicia el proceso. Para el <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> clase expansiva y comportamiento no expansivo es similar, salvo que en el modo no expansivo, un <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> objeto pospone todos los mensajes entrantes hasta que haya suficientes disponibles de orígenes distintos para completar un lote.  
  
 Para especificar el modo no expansivo para un bloque de flujo de datos, establezca <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> a `False`. Para obtener un ejemplo que muestra cómo utilizar el modo no expansivo para habilitar varios bloques de combinación puedan compartir un origen de datos más eficazmente, consulte [Cómo: usar JoinBlock para leer datos desde varios orígenes](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md).  
  
 [[go to top](#top)]  
  
<a name="custom"></a>   
## <a name="custom-dataflow-blocks"></a>Bloques de flujo de datos personalizados  
 Aunque la biblioteca de flujos de datos TPL proporciona muchos tipos de bloques predefinidos, puede crear tipos de bloques adicionales que tengan un comportamiento personalizado. Implemente el <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> o <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> interfaces directamente o utilizar el <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> método para crear un bloque complejo que encapsule el comportamiento de los tipos de bloques existentes.\</TInput, TOutput> Para obtener ejemplos que muestran cómo implementar funcionalidad en bloques de flujo de datos personalizados, consulte [Tutorial: crear un tipo de bloque de flujo de datos personalizado](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md).  
  
 [[go to top](#top)]  
  
## <a name="related-topics"></a>Temas relacionados  
  
|Título|Descripción|  
|-----------|-----------------|  
|[Cómo: escribir y leer los mensajes de un bloque de flujo de datos](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md)|Muestra cómo escribir y leer los mensajes de una <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> objeto.|  
|[Cómo: implementar un modelo de flujo de datos productor-consumidor](../../../docs/standard/parallel-programming/how-to-implement-a-producer-consumer-dataflow-pattern.md)|Describe cómo utilizar el modelo de flujo de datos para implementar un patrón consumidor-productor, cuando el productor envía mensajes a un bloque de flujo de datos y el consumidor lee mensajes de ese bloque.|  
|[Cómo: realizar una acción cuando un bloque de flujo de datos recibe datos](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md)|Describe cómo proporcionar delegados a los tipos de bloques de flujo de datos de ejecución, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, y <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>.\</TInput, TOutput> \</TInput, TOutput>|  
|[Tutorial: Crear una canalización de flujo de datos](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md)|Describe cómo crear una canalización de flujo de datos que descarga texto desde Internet y realiza operaciones en ese texto.|  
|[Cómo: desvincular bloques de flujo de datos](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md)|Muestra cómo utilizar el <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A> método desvincular un bloque de destino de su origen después de que el origen de un mensaje al destino.|  
|[Tutorial: Usar el flujo de datos en una aplicación de Windows Forms](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)|Muestra cómo crear una red de bloques de flujo de datos que realizan procesamiento de imágenes en una aplicación de Windows Forms.|  
|[Cómo: cancelar un bloque de flujo de datos](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md)|Muestra cómo se usa la cancelación en una aplicación de Windows Forms.|  
|[Cómo: usar JoinBlock para leer los datos de varios orígenes](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md)|Explica cómo utilizar el <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> clase para realizar una operación cuando hay datos de varios orígenes y cómo utilizar el modo no expansivo para habilitar varios bloques de combinación puedan compartir un origen de datos más eficazmente.\</T1, T2>|  
|[Cómo: especificar el grado de paralelismo en un bloque de flujo de datos](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)|Describe cómo establecer el <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> propiedad para habilitar un bloque de flujo de datos de ejecución pueda procesar varios mensajes a la vez.|  
|[Cómo: especificar un programador de tareas en un bloque de flujo de datos](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md)|Muestra cómo asociar un programador de tareas específico cuando se usa flujo de datos en la aplicación.|  
|[Tutorial: Usar BatchBlock y BatchedJoinBlock para mejorar la eficacia](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)|Describe cómo utilizar el <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> clase para mejorar la eficacia de la base de datos insertar operaciones y cómo utilizar el <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> clase para capturar los resultados y las excepciones que se producen mientras el programa lee de una base de datos.\</T1, T2>|  
|[Tutorial: Crear un tipo de bloque de flujo de datos personalizados](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md)|Muestra dos maneras de crear un tipo de bloque de flujo de datos que implementa un comportamiento personalizado.|  
|[Task Parallel Library (TPL)](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)|Presenta la biblioteca TPL, una biblioteca que simplifica la programación paralela y simultánea en aplicaciones de [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)].|