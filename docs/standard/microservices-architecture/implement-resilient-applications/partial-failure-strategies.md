---
title: Estrategias para controlar los errores parciales
description: Arquitectura de Microservicios de .NET para aplicaciones .NET en contenedores | Estrategias para controlar los errores parciales
keywords: Docker, microservicios, ASP.NET, contenedor
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: ff3bed530b13a9b1822c7cccf5a4d47df6fc6239
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 10/18/2017
---
# <a name="strategies-for-handling-partial-failure"></a><span data-ttu-id="9ded2-104">Estrategias para controlar los errores parciales</span><span class="sxs-lookup"><span data-stu-id="9ded2-104">Strategies for handling partial failure</span></span>

<span data-ttu-id="9ded2-105">Estrategias para tratar los errores parciales son los siguientes.</span><span class="sxs-lookup"><span data-stu-id="9ded2-105">Strategies for dealing with partial failures include the following.</span></span>

<span data-ttu-id="9ded2-106">**Usar la comunicación asincrónica (por ejemplo, la comunicación basada en mensajes) a través de microservicios interno**.</span><span class="sxs-lookup"><span data-stu-id="9ded2-106">**Use asynchronous communication (for example, message-based communication) across internal microservices**.</span></span> <span data-ttu-id="9ded2-107">Es muy aconsejable no crear cadenas largas de las llamadas sincrónicas de HTTP a través de la microservicios interna porque ese diseño incorrecto finalmente se convertirá en la causa principal de interrupciones incorrectas.</span><span class="sxs-lookup"><span data-stu-id="9ded2-107">It is highly advisable not to create long chains of synchronous HTTP calls across the internal microservices because that incorrect design will eventually become the main cause of bad outages.</span></span> <span data-ttu-id="9ded2-108">Por el contrario, excepto para las comunicaciones de front-end entre las aplicaciones cliente y el primer nivel de microservicios o puertas de enlace de API específica, se recomienda usar solo (basada en mensajes) comunicación asincrónica una vez más allá de la solicitud inicial / ciclo de respuesta, en la microservicios interno.</span><span class="sxs-lookup"><span data-stu-id="9ded2-108">On the contrary, except for the front-end communications between the client applications and the first level of microservices or fine-grained API Gateways, it is recommended to use only asynchronous (message-based) communication once past the initial request/response cycle, across the internal microservices.</span></span> <span data-ttu-id="9ded2-109">Coherencia definitiva y arquitecturas orientadas a eventos le ayudará a minimizar el efecto dominó.</span><span class="sxs-lookup"><span data-stu-id="9ded2-109">Eventual consistency and event-driven architectures will help to minimize ripple effects.</span></span> <span data-ttu-id="9ded2-110">Estos enfoques exigir un nivel más alto de autonomía de microservicio y, por tanto, evitar el problema que se describen a continuación.</span><span class="sxs-lookup"><span data-stu-id="9ded2-110">These approaches enforce a higher level of microservice autonomy and therefore prevent against the problem noted here.</span></span>

<span data-ttu-id="9ded2-111">**Usar reintentos con retroceso exponencial**.</span><span class="sxs-lookup"><span data-stu-id="9ded2-111">**Use retries with exponential backoff**.</span></span> <span data-ttu-id="9ded2-112">Esta técnica ayuda a evitar corto errores intermitentes mediante la realización de llamadas y vuelve a un número determinado de veces, en caso de que el servicio no estaba disponible sólo durante un breve período.</span><span class="sxs-lookup"><span data-stu-id="9ded2-112">This technique helps to avoid short and intermittent failures by performing call retries a certain number of times, in case the service was not available only for a short time.</span></span> <span data-ttu-id="9ded2-113">Esto puede ocurrir debido a problemas de red intermitentes, o cuando un contenedor de microservicio se mueva a otro nodo en un clúster.</span><span class="sxs-lookup"><span data-stu-id="9ded2-113">This might occur due to intermittent network issues or when a microservice/container is moved to a different node in a cluster.</span></span> <span data-ttu-id="9ded2-114">Sin embargo, si estos intentos no se ha diseñado correctamente con los disyuntores, puede agravar el efecto dominó, en última instancia, incluso que producen un [denegación de servicio (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span><span class="sxs-lookup"><span data-stu-id="9ded2-114">However, if these retries are not designed properly with circuit breakers, it can aggravate the ripple effects, ultimately even causing a [Denial of Service (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span></span>

<span data-ttu-id="9ded2-115">**Solucionar los tiempos de espera de la red**.</span><span class="sxs-lookup"><span data-stu-id="9ded2-115">**Work around network timeouts**.</span></span> <span data-ttu-id="9ded2-116">En general, los clientes deben diseñarse para que no se bloquea indefinidamente y usen siempre los tiempos de espera al esperar una respuesta.</span><span class="sxs-lookup"><span data-stu-id="9ded2-116">In general, clients should be designed not to block indefinitely and to always use timeouts when waiting for a response.</span></span> <span data-ttu-id="9ded2-117">Utilizar tiempos de espera garantiza que los recursos nunca se acumular la indefinidamente.</span><span class="sxs-lookup"><span data-stu-id="9ded2-117">Using timeouts ensures that resources are never tied up indefinitely.</span></span>

<span data-ttu-id="9ded2-118">**Usar el patrón de disyuntor**.</span><span class="sxs-lookup"><span data-stu-id="9ded2-118">**Use the Circuit Breaker pattern**.</span></span> <span data-ttu-id="9ded2-119">En este enfoque, el proceso de cliente supervisa el número de solicitudes con error.</span><span class="sxs-lookup"><span data-stu-id="9ded2-119">In this approach, the client process tracks the number of failed requests.</span></span> <span data-ttu-id="9ded2-120">Si la tasa de errores supera el límite configurado, un viajes "disyuntor" para que los repetidos intentos produce un error inmediato.</span><span class="sxs-lookup"><span data-stu-id="9ded2-120">If the error rate exceeds a configured limit, a “circuit breaker” trips so that further attempts fail immediately.</span></span> <span data-ttu-id="9ded2-121">(Si se producen errores en un gran número de solicitudes, que sugiere el servicio no está disponible y que las solicitudes de envío es inútil.) Tras un período de tiempo de espera, el cliente debe vuelva a intentarlo y, si las nuevas solicitudes se realizan correctamente, cierre el disyuntor.</span><span class="sxs-lookup"><span data-stu-id="9ded2-121">(If a large number of requests are failing, that suggests the service is unavailable and that sending requests is pointless.) After a timeout period, the client should try again and, if the new requests are successful, close the circuit breaker.</span></span>

<span data-ttu-id="9ded2-122">**Proporcionar las reservas**.</span><span class="sxs-lookup"><span data-stu-id="9ded2-122">**Provide fallbacks**.</span></span> <span data-ttu-id="9ded2-123">En este enfoque, el proceso del cliente realiza la lógica de retroceso cuando falla una solicitud, como devolver datos almacenados en caché o un valor predeterminado.</span><span class="sxs-lookup"><span data-stu-id="9ded2-123">In this approach, the client process performs fallback logic when a request fails, such as returning cached data or a default value.</span></span> <span data-ttu-id="9ded2-124">Esto es un enfoque adecuado para las consultas y es más compleja para las actualizaciones o los comandos.</span><span class="sxs-lookup"><span data-stu-id="9ded2-124">This is an approach suitable for queries, and is more complex for updates or commands.</span></span>

<span data-ttu-id="9ded2-125">**Limitar el número de solicitudes en cola**.</span><span class="sxs-lookup"><span data-stu-id="9ded2-125">**Limit the number of queued requests**.</span></span> <span data-ttu-id="9ded2-126">Los clientes también deben imponer un límite superior en el número de solicitudes pendientes que un microservicio de cliente puede enviar a un servicio determinado.</span><span class="sxs-lookup"><span data-stu-id="9ded2-126">Clients should also impose an upper bound on the number of outstanding requests that a client microservice can send to a particular service.</span></span> <span data-ttu-id="9ded2-127">Si se ha alcanzado el límite, tiene sentido probablemente realizar solicitudes adicionales y dichos intentos deben generar error inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="9ded2-127">If the limit has been reached, it is probably pointless to make additional requests, and those attempts should fail immediately.</span></span> <span data-ttu-id="9ded2-128">En cuanto a implementación, el Polly [cierre aislamiento](https://github.com/App-vNext/Polly/wiki/Bulkhead) directiva puede usarse para cumplir este requisito.</span><span class="sxs-lookup"><span data-stu-id="9ded2-128">In terms of implementation, the Polly [Bulkhead Isolation](https://github.com/App-vNext/Polly/wiki/Bulkhead) policy can be used to fulfil this requirement.</span></span> <span data-ttu-id="9ded2-129">Este enfoque es básicamente una limitación de la ejecución en paralelo con [SemaphoreSlim](https://docs.microsoft.com/dotnet/api/system.threading.semaphoreslim?view=netcore-1.1) como la implementación.</span><span class="sxs-lookup"><span data-stu-id="9ded2-129">This approach is essentially a parallelization throttle with [SemaphoreSlim](https://docs.microsoft.com/dotnet/api/system.threading.semaphoreslim?view=netcore-1.1) as the implementation.</span></span> <span data-ttu-id="9ded2-130">También permite a una "cola" fuera de la pared.</span><span class="sxs-lookup"><span data-stu-id="9ded2-130">It also permits a "queue" outside the bulkhead.</span></span> <span data-ttu-id="9ded2-131">Proactivamente puede perder una carga excesiva incluso antes de la ejecución (por ejemplo, porque se considera completa de capacidad).</span><span class="sxs-lookup"><span data-stu-id="9ded2-131">You can proactively shed excess load even before execution (for example, because capacity is deemed full).</span></span> <span data-ttu-id="9ded2-132">Esto hace que su respuesta a determinados escenarios de error mucho más rápido que sería un disyuntor, puesto que el disyuntor esperará a que los errores.</span><span class="sxs-lookup"><span data-stu-id="9ded2-132">This makes its response to certain failure scenarios faster than a circuit breaker would be, since the circuit breaker waits for the failures.</span></span> <span data-ttu-id="9ded2-133">El objeto BulkheadPolicy en Polly expone la cantidad de espacio libre pared cola son y ofertas de eventos si se produce desbordamiento por lo que también sirve para controlar el escalado horizontal automatizadas.</span><span class="sxs-lookup"><span data-stu-id="9ded2-133">The BulkheadPolicy object in Polly exposes how full the bulkhead and queue are, and offers events on overflow so can also be used to drive automated horizontal scaling.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="9ded2-134">Recursos adicionales</span><span class="sxs-lookup"><span data-stu-id="9ded2-134">Additional resources</span></span>

-   <span data-ttu-id="9ded2-135">**Patrones de resistencia**
    [*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](https://docs.microsoft.com/azure/architecture/patterns/category/resiliency)</span><span class="sxs-lookup"><span data-stu-id="9ded2-135">**Resiliency patterns**
[*https://docs.microsoft.com/azure/architecture/patterns/category/resiliency*](https://docs.microsoft.com/azure/architecture/patterns/category/resiliency)</span></span>

-   <span data-ttu-id="9ded2-136">**Agregar resistencia y optimizar el rendimiento de**
    [*https://msdn.microsoft.com/en-us/library/jj591574.aspx*](https://msdn.microsoft.com/en-us/library/jj591574.aspx)</span><span class="sxs-lookup"><span data-stu-id="9ded2-136">**Adding Resilience and Optimizing Performance**
[*https://msdn.microsoft.com/en-us/library/jj591574.aspx*](https://msdn.microsoft.com/en-us/library/jj591574.aspx)</span></span>

-   <span data-ttu-id="9ded2-137">**Cierre.**</span><span class="sxs-lookup"><span data-stu-id="9ded2-137">**Bulkhead.**</span></span> <span data-ttu-id="9ded2-138">Repositorio de GitHub.</span><span class="sxs-lookup"><span data-stu-id="9ded2-138">GitHub repo.</span></span> <span data-ttu-id="9ded2-139">Implementación con la directiva Polly. \\</span><span class="sxs-lookup"><span data-stu-id="9ded2-139">Implementation with Polly policy.\\</span></span>
    [<span data-ttu-id="9ded2-140">*https://github.com/app-vNext/Polly/Wiki/bulkhead*</span><span class="sxs-lookup"><span data-stu-id="9ded2-140">*https://github.com/App-vNext/Polly/wiki/Bulkhead*</span></span>](https://github.com/App-vNext/Polly/wiki/Bulkhead)

-   <span data-ttu-id="9ded2-141">**Diseñar las aplicaciones resistentes de Azure**
    [*https://docs.microsoft.com/azure/architecture/resiliency/*](https://docs.microsoft.com/azure/architecture/resiliency/)</span><span class="sxs-lookup"><span data-stu-id="9ded2-141">**Designing resilient applications for Azure**
[*https://docs.microsoft.com/azure/architecture/resiliency/*](https://docs.microsoft.com/azure/architecture/resiliency/)</span></span>

-   <span data-ttu-id="9ded2-142">**Control de errores transitorios**
    <https://docs.microsoft.com/azure/architecture/best-practices/transient-faults></span><span class="sxs-lookup"><span data-stu-id="9ded2-142">**Transient fault handling**
<https://docs.microsoft.com/azure/architecture/best-practices/transient-faults></span></span>


>[!div class="step-by-step"]
<span data-ttu-id="9ded2-143">[Anterior] (identificador-parcial-failure.md) [siguiente] (implemente-reintentos-exponencial-backoff.md)</span><span class="sxs-lookup"><span data-stu-id="9ded2-143">[Previous] (handle-partial-failure.md) [Next] (implement-retries-exponential-backoff.md)</span></span>
