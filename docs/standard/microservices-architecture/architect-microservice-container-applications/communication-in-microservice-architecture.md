---
title: "Comunicación en una arquitectura de microservicio"
description: "Arquitectura de Microservicios de .NET para aplicaciones .NET en contenedores | Comunicación en las arquitecturas de arquitectura de microservicio"
keywords: Docker, microservicios, ASP.NET, contenedor
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/18/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 8d38095a151b7568619b17340d768eff684d3271
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 10/22/2017
---
# <a name="communication-in-a-microservice-architecture"></a><span data-ttu-id="1c221-104">Comunicación en una arquitectura de microservicio</span><span class="sxs-lookup"><span data-stu-id="1c221-104">Communication in a microservice architecture</span></span>

<span data-ttu-id="1c221-105">En una aplicación monolítica se ejecuta en un único proceso, componentes invocación entre sí mediante llamadas de función o método de nivel de lenguaje.</span><span class="sxs-lookup"><span data-stu-id="1c221-105">In a monolithic application running on a single process, components invoke one another using language-level method or function calls.</span></span> <span data-ttu-id="1c221-106">Estos pueden ser estrechamente si va a crear objetos con el código (por ejemplo, `new ClassName()`), o puede invocar de forma desacoplada si usas la inyección de dependencia haciendo referencia a abstracciones en lugar de instancias de objeto concreta.</span><span class="sxs-lookup"><span data-stu-id="1c221-106">These can be strongly coupled if you are creating objects with code (for example, `new ClassName()`), or can be invoked in a decoupled way if you are using Dependency Injection by referencing abstractions rather than concrete object instances.</span></span> <span data-ttu-id="1c221-107">En cualquier caso, los objetos se están ejecutando en el mismo proceso.</span><span class="sxs-lookup"><span data-stu-id="1c221-107">Either way, the objects are running within the same process.</span></span> <span data-ttu-id="1c221-108">El desafío más importante cuando se cambia de una aplicación a una aplicación basada en microservicios monolítica consiste en cambiar el mecanismo de comunicación.</span><span class="sxs-lookup"><span data-stu-id="1c221-108">The biggest challenge when changing from a monolithic application to a microservices-based application lies in changing the communication mechanism.</span></span> <span data-ttu-id="1c221-109">Una conversión directa de las llamadas a métodos en proceso en llamadas a RPC a los servicios hará que una locuaz y una comunicación eficaz no que no se realizará correctamente en entornos distribuidos.</span><span class="sxs-lookup"><span data-stu-id="1c221-109">A direct conversion from in-process method calls into RPC calls to services will cause a chatty and not efficient communication that will not perform well in distributed environments.</span></span> <span data-ttu-id="1c221-110">Los desafíos de diseñar el sistema distribuido correctamente lo suficientemente bien como se sabe que incluso es un canon conocido como el [la fallacies de computación distribuida](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) que muestra suposiciones que los desarrolladores a menudo cuando se mueven desde monolítico a diseños distribuidos.</span><span class="sxs-lookup"><span data-stu-id="1c221-110">The challenges of designing distributed system properly are well enough known that there is even a canon known as the [The fallacies of distributed computing](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) that lists assumptions that developers often make when moving from monolithic to distributed designs.</span></span>

<span data-ttu-id="1c221-111">No hay no una solución, pero varios.</span><span class="sxs-lookup"><span data-stu-id="1c221-111">There is not one solution, but several.</span></span> <span data-ttu-id="1c221-112">Una solución implica aislar el microservicios de negocios tanto como sea posible.</span><span class="sxs-lookup"><span data-stu-id="1c221-112">One solution involves isolating the business microservices as much as possible.</span></span> <span data-ttu-id="1c221-113">A continuación, utilizan la comunicación asincrónica entre el microservicios interno y reemplace comunicación específica que es típica de comunicaciones dentro de un proceso entre los objetos con la comunicación general.</span><span class="sxs-lookup"><span data-stu-id="1c221-113">You then use asynchronous communication between the internal microservices and replace fine-grained communication that is typical in intra-process communication between objects with coarser-grained communication.</span></span> <span data-ttu-id="1c221-114">Puede hacerlo mediante la agrupación de llamadas y devolviendo los datos que agrega los resultados de varias llamadas internas, al cliente.</span><span class="sxs-lookup"><span data-stu-id="1c221-114">You can do this by grouping calls, and by returning data that aggregates the results of multiple internal calls, to the client.</span></span>

<span data-ttu-id="1c221-115">Una aplicación basada en microservicios es un sistema distribuido que se ejecutan en varios procesos o servicios, normalmente incluso en varios servidores o hosts.</span><span class="sxs-lookup"><span data-stu-id="1c221-115">A microservices-based application is a distributed system running on multiple processes or services, usually even across multiple servers or hosts.</span></span> <span data-ttu-id="1c221-116">Normalmente, cada instancia de servicio es un proceso.</span><span class="sxs-lookup"><span data-stu-id="1c221-116">Each service instance is typically a process.</span></span> <span data-ttu-id="1c221-117">Por lo tanto, los servicios deben interactúan mediante un protocolo de comunicación entre procesos, como HTTP, AMQP o un protocolo binario como TCP, dependiendo de la naturaleza de cada servicio.</span><span class="sxs-lookup"><span data-stu-id="1c221-117">Therefore, services must interact using an inter-process communication protocol such as HTTP, AMQP, or a binary protocol like TCP, depending on the nature of each service.</span></span>

<span data-ttu-id="1c221-118">La Comunidad de microservicio fomenta la filosofía de "[inteligentes extremos y canalizaciones no inteligente](http://simplicable.com/new/smart-endpoints-and-dumb-pipes)."</span><span class="sxs-lookup"><span data-stu-id="1c221-118">The microservice community promotes the philosophy of “[smart endpoints and dumb pipes](http://simplicable.com/new/smart-endpoints-and-dumb-pipes).”</span></span> <span data-ttu-id="1c221-119">Este eslogan anima a un diseño que sea lo más desacoplada como sea posible entre microservicios y productiva como posible dentro de un único microservicio.</span><span class="sxs-lookup"><span data-stu-id="1c221-119">This slogan encourages a design that is as decoupled as possible between microservices, and as cohesive as possible within a single microservice.</span></span> <span data-ttu-id="1c221-120">Como se explicó anteriormente, cada microservicio posee sus propios datos y su propia lógica de dominio.</span><span class="sxs-lookup"><span data-stu-id="1c221-120">As explained earlier, each microservice owns its own data and its own domain logic.</span></span> <span data-ttu-id="1c221-121">Pero normalmente simplemente se choreographed la microservicios crear una aplicación de extremo a extremo mediante el uso de las comunicaciones de REST, en lugar de protocolos complejos, como WS -\* y centralizada de comunicaciones flexibles orientada a eventos en lugar de proceso orchestrators empresarial.</span><span class="sxs-lookup"><span data-stu-id="1c221-121">But the microservices composing an end-to-end application are usually simply choreographed by using REST communications rather than complex protocols such as WS-\* and flexible event-driven communications instead of centralized business-process-orchestrators.</span></span>

<span data-ttu-id="1c221-122">Los dos protocolos usados son solicitud/respuesta HTTP con el recurso de API (al consultar la mayoría de todos) y mensajería asincrónica ligera al comunicarse las actualizaciones a través de varios microservicios.</span><span class="sxs-lookup"><span data-stu-id="1c221-122">The two commonly used protocols are HTTP request/response with resource APIs (when querying most of all), and lightweight asynchronous messaging when communicating updates across multiple microservices.</span></span> <span data-ttu-id="1c221-123">Estos se explican con más detalle en las secciones siguientes.</span><span class="sxs-lookup"><span data-stu-id="1c221-123">These are explained in more detail in the following sections.</span></span>

## <a name="communication-types"></a><span data-ttu-id="1c221-124">Tipos de comunicación</span><span class="sxs-lookup"><span data-stu-id="1c221-124">Communication types</span></span>

<span data-ttu-id="1c221-125">Cliente y servicios pueden comunicarse a través de muchos tipos diferentes de comunicación, cada uno destinado a un escenario diferente y objetivos.</span><span class="sxs-lookup"><span data-stu-id="1c221-125">Client and services can communicate through many different types of communication, each one targeting a different scenario and goals.</span></span> <span data-ttu-id="1c221-126">Inicialmente, los tipos de comunicaciones se pueden clasificar en dos ejes.</span><span class="sxs-lookup"><span data-stu-id="1c221-126">Initially, those types of communications can be classified in two axes.</span></span>

<span data-ttu-id="1c221-127">El primer eje consiste en definir si el protocolo es sincrónico o asincrónico:</span><span class="sxs-lookup"><span data-stu-id="1c221-127">The first axis is defining if the protocol is synchronous or asynchronous:</span></span>

-   <span data-ttu-id="1c221-128">Protocolo sincrónico.</span><span class="sxs-lookup"><span data-stu-id="1c221-128">Synchronous protocol.</span></span> <span data-ttu-id="1c221-129">HTTP es un protocolo sincrónico.</span><span class="sxs-lookup"><span data-stu-id="1c221-129">HTTP is a synchronous protocol.</span></span> <span data-ttu-id="1c221-130">El cliente envía una solicitud y espera una respuesta del servicio.</span><span class="sxs-lookup"><span data-stu-id="1c221-130">The client sends a request and waits for a response from the service.</span></span> <span data-ttu-id="1c221-131">Que es independiente de la ejecución de código de cliente que podría ser sincrónica (el subproceso está bloqueado) o asincrónico (no se bloquea el subproceso, y la respuesta de llegar a una devolución de llamada al final).</span><span class="sxs-lookup"><span data-stu-id="1c221-131">That is independent of the client code execution that could be synchronous (thread is blocked) or asynchronous (thread is not blocked, and the response will reach a callback eventually).</span></span> <span data-ttu-id="1c221-132">La cuestión importante aquí es que el protocolo (HTTP/HTTPS) es sincrónico y el código de cliente solo puede continuar su tarea cuando recibe la respuesta del servidor HTTP.</span><span class="sxs-lookup"><span data-stu-id="1c221-132">The important point here is that the protocol (HTTP/HTTPS) is synchronous and the client code can only continue its task when it receives the HTTP server response.</span></span>

-   <span data-ttu-id="1c221-133">Protocolo asincrónico.</span><span class="sxs-lookup"><span data-stu-id="1c221-133">Asynchronous protocol.</span></span> <span data-ttu-id="1c221-134">Otros protocolos como AMQP (es decir, un protocolo compatible con muchos sistemas operativos y entornos de nube) usan mensajes asincrónicos.</span><span class="sxs-lookup"><span data-stu-id="1c221-134">Other protocols like AMQP (a protocol supported by many operating systems and cloud environments) use asynchronous messages.</span></span> <span data-ttu-id="1c221-135">Normalmente el remitente de mensaje o código de cliente no espera una respuesta.</span><span class="sxs-lookup"><span data-stu-id="1c221-135">The client code or message sender usually does not wait for a response.</span></span> <span data-ttu-id="1c221-136">Simplemente envía el mensaje como al enviar un mensaje a una cola de RabbitMQ o cualquier otro agente de mensajes.</span><span class="sxs-lookup"><span data-stu-id="1c221-136">It just sends the message as when sending a message to a RabbitMQ queue or any other message broker.</span></span>

<span data-ttu-id="1c221-137">El segundo eje consiste en definir si la comunicación tiene un único receptor o receptores varios:</span><span class="sxs-lookup"><span data-stu-id="1c221-137">The second axis is defining if the communication has a single receiver or multiple receivers:</span></span>

-   <span data-ttu-id="1c221-138">Receptor único.</span><span class="sxs-lookup"><span data-stu-id="1c221-138">Single receiver.</span></span> <span data-ttu-id="1c221-139">Cada solicitud debe ser procesado por exactamente un receptor o servicio.</span><span class="sxs-lookup"><span data-stu-id="1c221-139">Each request must be processed by exactly one receiver or service.</span></span> <span data-ttu-id="1c221-140">Un ejemplo de este tipo de comunicación es la [patrón comandos](https://en.wikipedia.org/wiki/Command_pattern).</span><span class="sxs-lookup"><span data-stu-id="1c221-140">An example of this communication is the [Command pattern](https://en.wikipedia.org/wiki/Command_pattern).</span></span>

-   <span data-ttu-id="1c221-141">Varios receptores.</span><span class="sxs-lookup"><span data-stu-id="1c221-141">Multiple receivers.</span></span> <span data-ttu-id="1c221-142">Cada solicitud puede ser procesado por cero a varios receptores.</span><span class="sxs-lookup"><span data-stu-id="1c221-142">Each request can be processed by zero to multiple receivers.</span></span> <span data-ttu-id="1c221-143">Este tipo de comunicación debe ser asincrónica.</span><span class="sxs-lookup"><span data-stu-id="1c221-143">This type of communication must be asynchronous.</span></span> <span data-ttu-id="1c221-144">Un ejemplo es el [de publicación/suscripción](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) mecanismo utilizado para los patrones similares a [arquitectura orientada a eventos](http://microservices.io/patterns/data/event-driven-architecture.html).</span><span class="sxs-lookup"><span data-stu-id="1c221-144">An example is the [publish/subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) mechanism used in patterns like [Event-driven architecture](http://microservices.io/patterns/data/event-driven-architecture.html).</span></span> <span data-ttu-id="1c221-145">Esto se basa en un agente de interfaz o un mensaje de bus de eventos para propagar las actualizaciones de datos entre varios microservicios a través de eventos; Normalmente se implementa a través de un bus de servicio ni ningún artefacto similar como [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) utilizando [temas y suscripciones](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span><span class="sxs-lookup"><span data-stu-id="1c221-145">This is based on an event-bus interface or message broker when propagating data updates between multiple microservices through events; it is usually implemented through a service bus or similar artifact like [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) by using [topics and subscriptions](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span>

<span data-ttu-id="1c221-146">Una aplicación basada en microservicio a menudo utilizará una combinación de estos estilos de comunicación.</span><span class="sxs-lookup"><span data-stu-id="1c221-146">A microservice-based application will often use a combination of these communication styles.</span></span> <span data-ttu-id="1c221-147">El tipo más común es el único receptor comunicación con un protocolo sincrónico como HTTP/HTTPS al invocar un servicio Web API HTTP normal.</span><span class="sxs-lookup"><span data-stu-id="1c221-147">The most common type is single-receiver communication with a synchronous protocol like HTTP/HTTPS when invoking a regular Web API HTTP service.</span></span> <span data-ttu-id="1c221-148">Normalmente, también se Microservicios usar protocolos de mensajería para la comunicación asincrónica entre microservicios.</span><span class="sxs-lookup"><span data-stu-id="1c221-148">Microservices also typically use messaging protocols for asynchronous communication between microservices.</span></span>

<span data-ttu-id="1c221-149">Estos ejes son buenos conocer para tener mayor claridad en los mecanismos de comunicación posible, pero no son las preocupaciones más importantes al compilar microservicios.</span><span class="sxs-lookup"><span data-stu-id="1c221-149">These axes are good to know so you have clarity on the possible communication mechanisms, but they are not the important concerns when building microservices.</span></span> <span data-ttu-id="1c221-150">La naturaleza asincrónica de ejecución de subprocesos de cliente ni siquiera la naturaleza asincrónica del protocolo seleccionado son los puntos son importantes cuando se integra microservicios.</span><span class="sxs-lookup"><span data-stu-id="1c221-150">The asynchronous nature of client thread execution not even the asynchronous nature of the selected protocol are the important points when integrating microservices.</span></span> <span data-ttu-id="1c221-151">¿Qué *es* importante es poder integrar su microservicios asincrónicamente manteniendo la independencia del microservicios, tal como se describe en la sección siguiente.</span><span class="sxs-lookup"><span data-stu-id="1c221-151">What *is* important is being able to integrate your microservices asynchronously while maintaining the independence of microservices, as explained in the following section.</span></span>

## <a name="asynchronous-microservice-integration-enforces-microservices-autonomy"></a><span data-ttu-id="1c221-152">Integración de microservicio asincrónica aplica autonomía de microservicio</span><span class="sxs-lookup"><span data-stu-id="1c221-152">Asynchronous microservice integration enforces microservice’s autonomy</span></span>

<span data-ttu-id="1c221-153">Como se ha mencionado, el punto importante al compilar una aplicación basada en microservicios es la forma de integrar su microservicios.</span><span class="sxs-lookup"><span data-stu-id="1c221-153">As mentioned, the important point when building a microservices-based application is the way you integrate your microservices.</span></span> <span data-ttu-id="1c221-154">Idealmente, debe intentar minimizar la comunicación entre el microservicios interno.</span><span class="sxs-lookup"><span data-stu-id="1c221-154">Ideally, you should try to minimize the communication between the internal microservices.</span></span> <span data-ttu-id="1c221-155">El menos las comunicaciones entre microservicios, mejor.</span><span class="sxs-lookup"><span data-stu-id="1c221-155">The less communications between microservices, the better.</span></span> <span data-ttu-id="1c221-156">Pero, por supuesto, en muchos casos tendrá que integrar la microservicios de algún modo.</span><span class="sxs-lookup"><span data-stu-id="1c221-156">But of course, in many cases you will have to somehow integrate the microservices.</span></span> <span data-ttu-id="1c221-157">Si necesita hacerlo, la regla fundamental aquí es que la comunicación entre el microservicios debe ser asincrónica.</span><span class="sxs-lookup"><span data-stu-id="1c221-157">When you need to do that, the critical rule here is that the communication between the microservices should be asynchronous.</span></span> <span data-ttu-id="1c221-158">Que no significa que se debe usar un protocolo específico (por ejemplo, mensajería asincrónica frente a HTTP sincrónico).</span><span class="sxs-lookup"><span data-stu-id="1c221-158">That does not mean that you have to use a specific protocol (for example, asynchronous messaging versus synchronous HTTP).</span></span> <span data-ttu-id="1c221-159">Simplemente significa que la comunicación entre microservicios debe realizarse solo mediante la propagación datos de forma asincrónica, pero no intenta dependen de otros microservicios interno como parte de la operación de solicitud/respuesta HTTP del servicio inicial.</span><span class="sxs-lookup"><span data-stu-id="1c221-159">It just means that the communication between microservices should be done only by propagating data asynchronously, but try not to depend on other internal microservices as part of the initial service’s HTTP request/response operation.</span></span>

<span data-ttu-id="1c221-160">Si es posible, nunca dependen de comunicación sincrónica (solicitud-respuesta) entre varios microservicios, ni siquiera para las consultas.</span><span class="sxs-lookup"><span data-stu-id="1c221-160">If possible, never depend on synchronous communication (request/response) between multiple microservices, not even for queries.</span></span> <span data-ttu-id="1c221-161">El objetivo de cada microservicio es son autónomos y están disponibles para el consumidor de cliente, aunque los demás servicios que forman parte de la aplicación de extremo a extremo están inactivo o mal estado.</span><span class="sxs-lookup"><span data-stu-id="1c221-161">The goal of each microservice is to be autonomous and available to the client consumer, even if the other services that are part of the end-to-end application are down or unhealthy.</span></span> <span data-ttu-id="1c221-162">Si cree que necesita realizar una llamada desde un microservicio a otros microservicios (por ejemplo, realizando una solicitud HTTP para una consulta de datos) en orden para que pueda proporcionar una respuesta a una aplicación cliente, tiene una arquitectura que no será resistente cuando algunos microservicios producirá un error.</span><span class="sxs-lookup"><span data-stu-id="1c221-162">If you think you need to make a call from one microservice to other microservices (like performing an HTTP request for a data query) in order to be able to provide a response to a client application, you have an architecture that will not be resilient when some microservices fail.</span></span>

<span data-ttu-id="1c221-163">Además, si tiene dependencias HTTP entre microservicios, al igual que al crear largos ciclos de solicitud/respuesta con HTTP solicitan cadenas, como se muestra en la primera parte de la figura 4-15, no solo convierte su microservicios no autónomos, sino también su rendimiento afectados tan pronto como uno de los servicios en dicha cadena no esté funcionando correctamente.</span><span class="sxs-lookup"><span data-stu-id="1c221-163">Moreover, having HTTP dependencies between microservices, like when creating long request/response cycles with HTTP request chains, as shown in the first part of the Figure 4-15, not only makes your microservices not autonomous but also their performance is impacted as soon as one of the services in that chain is not performing well.</span></span> 

<span data-ttu-id="1c221-164">Más agregar dependencias sincrónicas entre microservicios, por ejemplo, las solicitudes de consulta, el peor que obtiene el tiempo de respuesta total para las aplicaciones cliente.</span><span class="sxs-lookup"><span data-stu-id="1c221-164">The more you add synchronous dependencies between microservices, such as query requests, the worse the overall response time gets for the client apps.</span></span>

![](./media/image15.png)

<span data-ttu-id="1c221-165">**Figura 4-15**.</span><span class="sxs-lookup"><span data-stu-id="1c221-165">**Figure 4-15**.</span></span> <span data-ttu-id="1c221-166">Antipatrones y patrones de comunicación entre microservicios</span><span class="sxs-lookup"><span data-stu-id="1c221-166">Anti-patterns and patterns in communication between microservices</span></span>

<span data-ttu-id="1c221-167">Si es necesario generar una acción adicional en otro microservicio su microservicio, si es posible, no realizar esa acción como parte de la operación de solicitud y respuesta de microservicio original y de forma sincrónica.</span><span class="sxs-lookup"><span data-stu-id="1c221-167">If your microservice needs to raise an additional action in another microservice, if possible, do not perform that action synchronously and as part of the original microservice request and reply operation.</span></span> <span data-ttu-id="1c221-168">En su lugar, hacerlo de forma asincrónica (mediante mensajería asincrónica o eventos de integración, colas, etcetera.).</span><span class="sxs-lookup"><span data-stu-id="1c221-168">Instead, do it asynchronously (using asynchronous messaging or integration events, queues, etc.).</span></span> <span data-ttu-id="1c221-169">Sin embargo, cuando sea posible, no invocan la acción de forma sincrónica como parte de la operación de solicitud y respuesta sincrónica original.</span><span class="sxs-lookup"><span data-stu-id="1c221-169">But, as much as possible, do not invoke the action synchronously as part of the original synchronous request and reply operation.</span></span>

<span data-ttu-id="1c221-170">Y, finalmente, (y es donde la mayoría de los problemas surgen al generar microservicios), si la microservicio inicial necesita que los datos que originalmente pertenece a otro microservicios, no confíe en que realiza solicitudes sincrónicas para esos datos.</span><span class="sxs-lookup"><span data-stu-id="1c221-170">And finally (and this is where most of the issues arise when building microservices), if your initial microservice needs data that is originally owned by other microservices, do not rely on making synchronous requests for that data.</span></span> <span data-ttu-id="1c221-171">En su lugar, replicar o propagar esos datos (solo los atributos que se necesiten) en la base de datos del servicio inicial mediante coherencia definitiva (normalmente mediante el uso de eventos de integración, como se explica en las próximas secciones).</span><span class="sxs-lookup"><span data-stu-id="1c221-171">Instead, replicate or propagate that data (only the attributes you need) into the initial service’s database by using eventual consistency (typically by using integration events, as explained in upcoming sections).</span></span>

<span data-ttu-id="1c221-172">Como se indicó anteriormente en la sección [identifica los límites del modelo de dominio para cada microservicio](#identifying-domain-model-boundaries-for-each-microservice), duplicación de algunos datos a través de varias microservicios no es un diseño incorrecto, por el contrario, al hacer que puede convertir los datos en el idioma específico o los términos de ese dominio adicional o el contexto limitado.</span><span class="sxs-lookup"><span data-stu-id="1c221-172">As noted earlier in the section [Identifying domain-model boundaries for each microservice](#identifying-domain-model-boundaries-for-each-microservice), duplicating some data across several microservices is not an incorrect design—on the contrary, when doing that you can translate the data into the specific language or terms of that additional domain or Bounded Context.</span></span> <span data-ttu-id="1c221-173">Por ejemplo, en la [eShopOnContainers](http://aka.ms/MicroservicesArchitecture) aplicación tienen un microservicio denominado identity.api que está a cargo de la mayoría de los datos del usuario a una entidad con el nombre de usuario.</span><span class="sxs-lookup"><span data-stu-id="1c221-173">For instance, in the [eShopOnContainers](http://aka.ms/MicroservicesArchitecture) application you have a microservice named identity.api that is in charge of most of the user’s data with an entity named User.</span></span> <span data-ttu-id="1c221-174">Sin embargo, si necesita almacenar datos acerca del usuario en el orden de microservicio, almacenar una entidad diferente denominada comprador.</span><span class="sxs-lookup"><span data-stu-id="1c221-174">However, when you need to store data about the user within the Ordering microservice, you store it as a different entity named Buyer.</span></span> <span data-ttu-id="1c221-175">La entidad de comprador comparte la misma identidad con la entidad de usuario original, pero podría tener sólo los atributos algunas son necesarios para el dominio de orden y no el perfil completo del usuario.</span><span class="sxs-lookup"><span data-stu-id="1c221-175">The Buyer entity shares the same identity with the original User entity, but it might have only the few attributes needed by the Ordering domain, and not the whole user profile.</span></span>

<span data-ttu-id="1c221-176">Puede usar cualquier protocolo de comunicarse y propagar datos de forma asincrónica a través de microservicios para disponer de coherencia definitiva.</span><span class="sxs-lookup"><span data-stu-id="1c221-176">You might use any protocol to communicate and propagate data asynchronously across microservices in order to have eventual consistency.</span></span> <span data-ttu-id="1c221-177">Como se mencionó, puede usar eventos de integración con un bus de eventos o el mensaje broker o se puede usar incluso HTTP por sondeo en los demás servicios en su lugar.</span><span class="sxs-lookup"><span data-stu-id="1c221-177">As mentioned, you could use integration events using an event bus or message broker or you could even use HTTP by polling the other services instead.</span></span> <span data-ttu-id="1c221-178">No importa.</span><span class="sxs-lookup"><span data-stu-id="1c221-178">It does not matter.</span></span> <span data-ttu-id="1c221-179">La regla importante es no crear dependencias sincrónicas entre su microservicios.</span><span class="sxs-lookup"><span data-stu-id="1c221-179">The important rule is to not create synchronous dependencies between your microservices.</span></span>

<span data-ttu-id="1c221-180">Las siguientes secciones explican los varios estilos de comunicación que se puede considerar el uso de una aplicación basada en microservicio.</span><span class="sxs-lookup"><span data-stu-id="1c221-180">The following sections explain the multiple communication styles you can consider using in a microservice-based application.</span></span>

## <a name="communication-styles"></a><span data-ttu-id="1c221-181">Estilos de comunicación</span><span class="sxs-lookup"><span data-stu-id="1c221-181">Communication styles</span></span>

<span data-ttu-id="1c221-182">Hay muchos protocolos y las opciones que puede usar para la comunicación, según el tipo de comunicación que desea usar.</span><span class="sxs-lookup"><span data-stu-id="1c221-182">There are many protocols and choices you can use for communication, depending on the communication type you want to use.</span></span> <span data-ttu-id="1c221-183">Si se utiliza un mecanismo de comunicación basada en solicitud/respuesta sincrónica, protocolos como HTTP y el resto de los enfoques son las más comunes, especialmente si va a publicar los servicios fuera del clúster de host o microservicio de Docker.</span><span class="sxs-lookup"><span data-stu-id="1c221-183">If you are using a synchronous request/response-based communication mechanism, protocols such as HTTP and REST approaches are the most common, especially if you are publishing your services outside the Docker host or microservice cluster.</span></span> <span data-ttu-id="1c221-184">Si va a comunicarse entre servicios internamente (dentro de su clúster de host o microservicios Docker) que le interese usar mecanismos de comunicación de formato binario (como la comunicación remota de Service Fabric o WCF mediante el uso de TCP y el formato binario).</span><span class="sxs-lookup"><span data-stu-id="1c221-184">If you are communicating between services internally (within your Docker host or microservices cluster) you might also want to use binary format communication mechanisms (like Service Fabric remoting or WCF using TCP and binary format).</span></span> <span data-ttu-id="1c221-185">Como alternativa, puede usar los mecanismos de comunicación asincrónica y basada en mensajes como AMQP.</span><span class="sxs-lookup"><span data-stu-id="1c221-185">Alternatively, you can use asynchronous, message-based communication mechanisms such as AMQP.</span></span>

<span data-ttu-id="1c221-186">También hay varios formatos de mensaje como JSON o XML, o incluso binarios formatos, que pueden ser más eficaces.</span><span class="sxs-lookup"><span data-stu-id="1c221-186">There are also multiple message formats like JSON or XML, or even binary formats, which can be more efficient.</span></span> <span data-ttu-id="1c221-187">Si el formato binario elegido no es un estándar, probablemente no es una buena idea públicamente publicar los servicios con ese formato.</span><span class="sxs-lookup"><span data-stu-id="1c221-187">If your chosen binary format is not a standard, it is probably not a good idea to publicly publish your services using that format.</span></span> <span data-ttu-id="1c221-188">Puede utilizar un formato no estándar para la comunicación interna entre los microservicios.</span><span class="sxs-lookup"><span data-stu-id="1c221-188">You could use a non-standard format for internal communication between your microservices.</span></span> <span data-ttu-id="1c221-189">Puede hacer esto cuando la comunicación entre microservicios dentro de su clúster de host o microservicio de Docker (orchestrators de Docker o Azure Service Fabric) o propietario de aplicaciones de cliente que se comunican con el microservicios.</span><span class="sxs-lookup"><span data-stu-id="1c221-189">You might do this when communicating between microservices within your Docker host or microservice cluster (Docker orchestrators or Azure Service Fabric), or for proprietary client applications that talk to the microservices.</span></span>

### <a name="requestresponse-communication-with-http-and-rest"></a><span data-ttu-id="1c221-190">Comunicación de solicitud/respuesta con HTTP y REST</span><span class="sxs-lookup"><span data-stu-id="1c221-190">Request/response communication with HTTP and REST</span></span> 

<span data-ttu-id="1c221-191">Cuando un cliente utiliza la comunicación de solicitud/respuesta, envía una solicitud a un servicio, a continuación, el servicio procesa la solicitud y envía una respuesta.</span><span class="sxs-lookup"><span data-stu-id="1c221-191">When a client uses request/response communication, it sends a request to a service, then the service processes the request and sends back a response.</span></span> <span data-ttu-id="1c221-192">Comunicación de solicitud/respuesta es especialmente idóneo para consultar los datos de una interfaz de usuario en tiempo real (una interfaz de usuario en directo) desde aplicaciones cliente.</span><span class="sxs-lookup"><span data-stu-id="1c221-192">Request/response communication is especially well suited for querying data for a real-time UI (a live user interface) from client apps.</span></span> <span data-ttu-id="1c221-193">Por lo tanto, en una arquitectura de microservicio probablemente usará este mecanismo de comunicación para la mayoría de las consultas, tal como se muestra en la figura 4-16.</span><span class="sxs-lookup"><span data-stu-id="1c221-193">Therefore, in a microservice architecture you will probably use this communication mechanism for most queries, as shown in Figure 4-16.</span></span>

![](./media/image16.png)

<span data-ttu-id="1c221-194">**Figura 4-16**.</span><span class="sxs-lookup"><span data-stu-id="1c221-194">**Figure 4-16**.</span></span> <span data-ttu-id="1c221-195">El uso de comunicación de solicitud/respuesta HTTP (sincrónica o asincrónica)</span><span class="sxs-lookup"><span data-stu-id="1c221-195">Using HTTP request/response communication (synchronous or asynchronous)</span></span>

<span data-ttu-id="1c221-196">Cuando un cliente utiliza la comunicación de solicitud/respuesta, da por supuesto que la respuesta llegarán en poco tiempo, normalmente menos de un segundo o unos pocos segundos como máximo.</span><span class="sxs-lookup"><span data-stu-id="1c221-196">When a client uses request/response communication, it assumes that the response will arrive in a short time, typically less than a second, or a few seconds at most.</span></span> <span data-ttu-id="1c221-197">Para respuestas con retraso, debe implementar la comunicación asincrónica basada en [patrones de mensajería](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) y [tecnologías de mensajería](https://en.wikipedia.org/wiki/Message-oriented_middleware), que es un enfoque diferente que se explica en la sección siguiente.</span><span class="sxs-lookup"><span data-stu-id="1c221-197">For delayed responses, you need to implement asynchronous communication based on [messaging patterns](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) and [messaging technologies](https://en.wikipedia.org/wiki/Message-oriented_middleware), which is a different approach that we explain in the next section.</span></span>

<span data-ttu-id="1c221-198">Es un estilo arquitectónico popular para la comunicación de solicitud/respuesta [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span><span class="sxs-lookup"><span data-stu-id="1c221-198">A popular architectural style for request/response communication is [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span></span> <span data-ttu-id="1c221-199">Este enfoque se basa en y estrechamente acoplado, el [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) de protocolo, la adopción de verbos HTTP, como GET, POST y colocar.</span><span class="sxs-lookup"><span data-stu-id="1c221-199">This approach is based on, and tightly coupled to, the [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) protocol, embracing HTTP verbs like GET, POST, and PUT.</span></span> <span data-ttu-id="1c221-200">REST es el enfoque de arquitectura de comunicación más usados al crear servicios.</span><span class="sxs-lookup"><span data-stu-id="1c221-200">REST is the most commonly used architectural communication approach when creating services.</span></span> <span data-ttu-id="1c221-201">Puede implementar servicios REST al desarrollar servicios Web de ASP.NET Core API.</span><span class="sxs-lookup"><span data-stu-id="1c221-201">You can implement REST services when you develop ASP.NET Core Web API services.</span></span>

<span data-ttu-id="1c221-202">Hay un valor adicional al usar los servicios de REST de HTTP como el lenguaje de definición de interfaz.</span><span class="sxs-lookup"><span data-stu-id="1c221-202">There is additional value when using HTTP REST services as your interface definition language.</span></span> <span data-ttu-id="1c221-203">Por ejemplo, si usa [Swagger metadatos](http://swagger.io/) para describir la API de servicio, puede usar herramientas que generan código auxiliar del cliente directamente puede detectar y consumir los servicios.</span><span class="sxs-lookup"><span data-stu-id="1c221-203">For instance, if you use [Swagger metadata](http://swagger.io/) to describe your service API, you can use tools that generate client stubs that can directly discover and consume your services.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="1c221-204">Recursos adicionales</span><span class="sxs-lookup"><span data-stu-id="1c221-204">Additional resources</span></span>

-   <span data-ttu-id="1c221-205">**Martin Fowler. Modelo de madurez Richardson.**</span><span class="sxs-lookup"><span data-stu-id="1c221-205">**Martin Fowler. Richardson Maturity Model.**</span></span> <span data-ttu-id="1c221-206">Una descripción del modelo REST.</span><span class="sxs-lookup"><span data-stu-id="1c221-206">A description of the REST model.</span></span>
    [<span data-ttu-id="1c221-207">*http://martinfowler.com/articles/richardsonMaturityModel.HTML*</span><span class="sxs-lookup"><span data-stu-id="1c221-207">*http://martinfowler.com/articles/richardsonMaturityModel.html*</span></span>](http://martinfowler.com/articles/richardsonMaturityModel.html)

-   <span data-ttu-id="1c221-208">**Swagger.**</span><span class="sxs-lookup"><span data-stu-id="1c221-208">**Swagger.**</span></span> <span data-ttu-id="1c221-209">El sitio oficial.</span><span class="sxs-lookup"><span data-stu-id="1c221-209">The official site.</span></span>
    [<span data-ttu-id="1c221-210">*http://swagger.IO/*</span><span class="sxs-lookup"><span data-stu-id="1c221-210">*http://swagger.io/*</span></span>](http://swagger.io/)

### <a name="push-and-real-time-communication-based-on-http"></a><span data-ttu-id="1c221-211">Comunicación en tiempo real basada en HTTP e inserción</span><span class="sxs-lookup"><span data-stu-id="1c221-211">Push and real-time communication based on HTTP</span></span>

<span data-ttu-id="1c221-212">Otra posibilidad (normalmente con fines diferentes al resto) es una comunicación en tiempo real y de uno a varios con marcos de trabajo de nivel superiores como [ASP.NET SignalR](https://www.asp.net/signalr) y protocolos como [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span><span class="sxs-lookup"><span data-stu-id="1c221-212">Another possibility (usually for different purposes than REST) is a real-time and one-to-many communication with higher-level frameworks such as [ASP.NET SignalR](https://www.asp.net/signalr) and protocols such as [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span></span>

<span data-ttu-id="1c221-213">Como se muestra en la figura 4-17, la comunicación en tiempo real de HTTP significa que puede tener el código de servidor Insertar contenido en los clientes conectados, como los datos estén disponibles, en lugar de hacer que el servidor espera para que un cliente solicitar nuevos datos.</span><span class="sxs-lookup"><span data-stu-id="1c221-213">As Figure 4-17 shows, real-time HTTP communication means that you can have server code pushing content to connected clients as the data becomes available, rather than having the server wait for a client to request new data.</span></span>

![](./media/image17.png)

<span data-ttu-id="1c221-214">**Figura 4-17**.</span><span class="sxs-lookup"><span data-stu-id="1c221-214">**Figure 4-17**.</span></span> <span data-ttu-id="1c221-215">Comunicación asincrónica de mensajes en tiempo real uno a uno</span><span class="sxs-lookup"><span data-stu-id="1c221-215">One-to-one real-time asynchronous message communication</span></span>

<span data-ttu-id="1c221-216">Puesto que es la comunicación en tiempo real, las aplicaciones cliente mostrar los cambios casi al instante.</span><span class="sxs-lookup"><span data-stu-id="1c221-216">Since communication is in real time, client apps show the changes almost instantly.</span></span> <span data-ttu-id="1c221-217">Normalmente, esto se controla mediante un protocolo como WebSockets, con muchas conexiones WebSockets (uno por cliente).</span><span class="sxs-lookup"><span data-stu-id="1c221-217">This is usually handled by a protocol such as WebSockets, using many WebSockets connections (one per client).</span></span> <span data-ttu-id="1c221-218">Un ejemplo típico es cuando un servicio comunica un cambio en la puntuación de un juego de deportes para muchas aplicaciones web de cliente al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="1c221-218">A typical example is when a service communicates a change in the score of a sports game to many client web apps simultaneously.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="1c221-219">[Anterior] (direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md) [siguiente] (asincrónica-message-según-communication.md)</span><span class="sxs-lookup"><span data-stu-id="1c221-219">[Previous] (direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md) [Next] (asynchronous-message-based-communication.md)</span></span>
