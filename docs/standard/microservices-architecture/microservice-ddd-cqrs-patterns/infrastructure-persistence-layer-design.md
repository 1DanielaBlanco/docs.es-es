---
title: "Diseñar la capa de persistencia de infraestructura"
description: "Arquitectura de Microservicios de .NET para aplicaciones .NET en contenedores | Diseñar la capa de persistencia de infraestructura"
keywords: Docker, microservicios, ASP.NET, contenedor
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: ce0f1d608eed909a7707f3c580afc5253f3eef06
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 10/18/2017
---
# <a name="designing-the-infrastructure-persistence-layer"></a><span data-ttu-id="2ffea-104">Diseñar la capa de persistencia de infraestructura</span><span class="sxs-lookup"><span data-stu-id="2ffea-104">Designing the infrastructure persistence layer</span></span>

<span data-ttu-id="2ffea-105">Componentes de persistencia de datos proporcionan acceso a los datos que se hospeda dentro de los límites de un microservicio (es decir, base de datos de microservicio).</span><span class="sxs-lookup"><span data-stu-id="2ffea-105">Data persistence components provide access to the data hosted within the boundaries of a microservice (that is, a microservice’s database).</span></span> <span data-ttu-id="2ffea-106">Contienen la implementación real de los componentes como repositorios y [unidad de trabajo](http://martinfowler.com/eaaCatalog/unitOfWork.html) clases, como DBContexts de EF personalizado.</span><span class="sxs-lookup"><span data-stu-id="2ffea-106">They contain the actual implementation of components such as repositories and [Unit of Work](http://martinfowler.com/eaaCatalog/unitOfWork.html) classes, like custom EF DBContexts.</span></span>

## <a name="the-repository-pattern"></a><span data-ttu-id="2ffea-107">El modelo de repositorio</span><span class="sxs-lookup"><span data-stu-id="2ffea-107">The Repository pattern</span></span>

<span data-ttu-id="2ffea-108">Los repositorios son clases o componentes que encapsulan la lógica necesaria para tener acceso a orígenes de datos.</span><span class="sxs-lookup"><span data-stu-id="2ffea-108">Repositories are classes or components that encapsulate the logic required to access data sources.</span></span> <span data-ttu-id="2ffea-109">Centralización de datos acceso a funcionalidad común, lo que proporciona un mejor mantenimiento y el desacoplamiento la infraestructura o la tecnología que se usa para tener acceso a las bases de datos de la capa de modelo de dominio.</span><span class="sxs-lookup"><span data-stu-id="2ffea-109">They centralize common data access functionality, providing better maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer.</span></span> <span data-ttu-id="2ffea-110">Si usas un ORM como Entity Framework, se simplifica el código que debe implementarse, gracias a LINQ y establecimiento inflexible de tipos.</span><span class="sxs-lookup"><span data-stu-id="2ffea-110">If you use an ORM like Entity Framework, the code that must be implemented is simplified, thanks to LINQ and strong typing.</span></span> <span data-ttu-id="2ffea-111">Esto le permite centrarse en la lógica de persistencia de datos en lugar de datos acceso mecánica.</span><span class="sxs-lookup"><span data-stu-id="2ffea-111">This lets you focus on the data persistence logic rather than on data access plumbing.</span></span>

<span data-ttu-id="2ffea-112">El modelo de repositorio es una manera de trabajar con un origen de datos bien documentada.</span><span class="sxs-lookup"><span data-stu-id="2ffea-112">The Repository pattern is a well-documented way of working with a data source.</span></span> <span data-ttu-id="2ffea-113">En la libreta de [patrones de arquitectura de aplicación empresarial](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler describe un repositorio como sigue:</span><span class="sxs-lookup"><span data-stu-id="2ffea-113">In the book [Patterns of Enterprise Application Architecture](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler describes a repository as follows:</span></span>

<span data-ttu-id="2ffea-114">Un repositorio realiza las tareas de intermediario entre los niveles de modelo de dominio y la asignación de datos, que actúa de forma similar a un conjunto de objetos de dominio en la memoria.</span><span class="sxs-lookup"><span data-stu-id="2ffea-114">A repository performs the tasks of an intermediary between the domain model layers and data mapping, acting in a similar way to a set of domain objects in memory.</span></span> <span data-ttu-id="2ffea-115">Objetos de cliente mediante declaración generan consultas y envían a los repositorios de respuestas.</span><span class="sxs-lookup"><span data-stu-id="2ffea-115">Client objects declaratively build queries and send them to the repositories for answers.</span></span> <span data-ttu-id="2ffea-116">Conceptualmente, un repositorio encapsula un conjunto de objetos almacenados en la base de datos y las operaciones que se pueden realizar en ellos, proporcionan una manera de que esté cerca de la capa de persistencia.</span><span class="sxs-lookup"><span data-stu-id="2ffea-116">Conceptually, a repository encapsulates a set of objects stored in the database and operations that can be performed on them, providing a way that is closer to the persistence layer.</span></span> <span data-ttu-id="2ffea-117">Repositorios, además, admiten la finalidad de asignación o separar con claridad y en una dirección, la dependencia entre el dominio de trabajo y la asignación de datos.</span><span class="sxs-lookup"><span data-stu-id="2ffea-117">Repositories, also, support the purpose of separating, clearly and in one direction, the dependency between the work domain and the data allocation or mapping.</span></span>

### <a name="define-one-repository-per-aggregate"></a><span data-ttu-id="2ffea-118">Definir un repositorio por agregado</span><span class="sxs-lookup"><span data-stu-id="2ffea-118">Define one repository per aggregate</span></span>

<span data-ttu-id="2ffea-119">Para cada raíz aggregate o aggregate, debe crear una clase de repositorio.</span><span class="sxs-lookup"><span data-stu-id="2ffea-119">For each aggregate or aggregate root, you should create one repository class.</span></span> <span data-ttu-id="2ffea-120">En un microservicio basándose en patrones de diseño basado en dominio, el único canal que se debe usar para actualizar la base de datos debe ser los repositorios.</span><span class="sxs-lookup"><span data-stu-id="2ffea-120">In a microservice based on domain-driven design patterns, the only channel you should use to update the database should be the repositories.</span></span> <span data-ttu-id="2ffea-121">Esto es porque tienen una relación uno a uno con la raíz de agregado, que controla el agregado invariables y coherencia transaccional.</span><span class="sxs-lookup"><span data-stu-id="2ffea-121">This is because they have a one-to-one relationship with the aggregate root, which controls the aggregate’s invariants and transactional consistency.</span></span> <span data-ttu-id="2ffea-122">Es correcto consultar la base de datos a través de otros canales (tal y como se pueden realizar después de un enfoque CQRS), dado que las consultas no cambian el estado de la base de datos.</span><span class="sxs-lookup"><span data-stu-id="2ffea-122">It is okay to query the database through other channels (as you can do following a CQRS approach), because queries do not change the state of the database.</span></span> <span data-ttu-id="2ffea-123">Sin embargo, el área transaccional, las actualizaciones, siempre debe controlarse mediante los repositorios y las agregados raíces.</span><span class="sxs-lookup"><span data-stu-id="2ffea-123">However, the transactional area—the updates—must always be controlled by the repositories and the aggregate roots.</span></span>

<span data-ttu-id="2ffea-124">Básicamente, un repositorio permite rellenar los datos en la memoria que procede de la base de datos en forma de las entidades de dominio.</span><span class="sxs-lookup"><span data-stu-id="2ffea-124">Basically, a repository allows you to populate data in memory that comes from the database in the form of the domain entities.</span></span> <span data-ttu-id="2ffea-125">Una vez que las entidades se encuentran en la memoria, se pueden cambiar y, a continuación, se conserva en la base de datos a través de las transacciones.</span><span class="sxs-lookup"><span data-stu-id="2ffea-125">Once the entities are in memory, they can be changed and then persisted back to the database through transactions.</span></span>

<span data-ttu-id="2ffea-126">Como se indicó anteriormente, si está utilizando el modelo de arquitectura de CQS/CQRS, las consultas iniciales se realizará por consultas del lado fuera del modelo de dominio, realizadas por instrucciones SQL simples con Dapper.</span><span class="sxs-lookup"><span data-stu-id="2ffea-126">As noted earlier, if you are using the CQS/CQRS architectural pattern, the initial queries will be performed by side queries out of the domain model, performed by simple SQL statements using Dapper.</span></span> <span data-ttu-id="2ffea-127">Este enfoque es mucho más flexible que los repositorios, ya que puede consultar y combinar las tablas necesita, y estas consultas no están limitadas por las reglas de los agregados.</span><span class="sxs-lookup"><span data-stu-id="2ffea-127">This approach is much more flexible than repositories because you can query and join any tables you need, and these queries are not restricted by rules from the aggregates.</span></span> <span data-ttu-id="2ffea-128">Esos datos irá a la aplicación de cliente o de capa de presentación.</span><span class="sxs-lookup"><span data-stu-id="2ffea-128">That data will go to the presentation layer or client app.</span></span>

<span data-ttu-id="2ffea-129">Si el usuario hace cambios, los datos se actualicen procederán de la capa de presentación o de aplicación de cliente a la capa de aplicación (por ejemplo, un servicio de API Web).</span><span class="sxs-lookup"><span data-stu-id="2ffea-129">If the user makes changes, the data to be updated will come from the client app or presentation layer to the application layer (such as a Web API service).</span></span> <span data-ttu-id="2ffea-130">Cuando reciba un comando (con datos) en un controlador de comandos, utilice repositorios para obtener los datos que desea actualizar desde la base de datos.</span><span class="sxs-lookup"><span data-stu-id="2ffea-130">When you receive a command (with data) in a command handler, you use repositories to get the data you want to update from the database.</span></span> <span data-ttu-id="2ffea-131">Actualizar en la memoria con la información que se pasa con los comandos y, a continuación, agrega o actualiza los datos (entidades de dominio) en la base de datos a través de una transacción.</span><span class="sxs-lookup"><span data-stu-id="2ffea-131">You update it in memory with the information passed with the commands, and you then add or update the data (domain entities) in the database through a transaction.</span></span>

<span data-ttu-id="2ffea-132">Lo debemos destacamos nuevo que un solo repositorio debe definirse para cada raíz agregada, como se muestra en la figura 9-17.</span><span class="sxs-lookup"><span data-stu-id="2ffea-132">We must emphasize again that only one repository should be defined for each aggregate root, as shown in Figure 9-17.</span></span> <span data-ttu-id="2ffea-133">Para lograr el objetivo de la raíz agregada para mantener la coherencia transaccional entre todos los objetos dentro del agregado, nunca se debe crear un repositorio para cada tabla en la base de datos.</span><span class="sxs-lookup"><span data-stu-id="2ffea-133">To achieve the goal of the aggregate root to maintain transactional consistency between all the objects within the aggregate, you should never create a repository for each table in the database.</span></span>

![](./media/image18.png)

<span data-ttu-id="2ffea-134">**Figura 9-17**.</span><span class="sxs-lookup"><span data-stu-id="2ffea-134">**Figure 9-17**.</span></span> <span data-ttu-id="2ffea-135">La relación entre tablas de base de datos, agregados y repositorios</span><span class="sxs-lookup"><span data-stu-id="2ffea-135">The relationship between repositories, aggregates, and database tables</span></span>

### <a name="enforcing-one-aggregate-root-per-repository"></a><span data-ttu-id="2ffea-136">Aplicar una raíz agregada por repositorio</span><span class="sxs-lookup"><span data-stu-id="2ffea-136">Enforcing one aggregate root per repository</span></span>

<span data-ttu-id="2ffea-137">Puede ser útil para implementar el diseño de repositorio de tal manera que aplica la regla que solo las raíces agregadas deben tener repositorios.</span><span class="sxs-lookup"><span data-stu-id="2ffea-137">It can be valuable to implement your repository design in such a way that it enforces the rule that only aggregate roots should have repositories.</span></span> <span data-ttu-id="2ffea-138">Puede crear un tipo de almacén genérico o base que restringe al tipo de entidades que funciona con para asegurarse de que tienen la interfaz de marcador IAggregateRoot.</span><span class="sxs-lookup"><span data-stu-id="2ffea-138">You can create a generic or base repository type that constrains the type of entities it works with to ensure they have the IAggregateRoot marker interface.</span></span>

<span data-ttu-id="2ffea-139">Por lo tanto, cada clase de repositorio que se implementan en el nivel de infraestructura implementa su propio contrato o interfaz, como se muestra en el código siguiente:</span><span class="sxs-lookup"><span data-stu-id="2ffea-139">Thus, each repository class implemented at the infrastructure layer implements its own contract or interface, as shown in the following code:</span></span>

```csharp
namespace Microsoft.eShopOnContainers.Services.Ordering.Infrastructure.Repositories
{
    public class OrderRepository : IOrderRepository
    {
```

<span data-ttu-id="2ffea-140">Cada interfaz del repositorio específico implementa la interfaz genérica de IRepository:</span><span class="sxs-lookup"><span data-stu-id="2ffea-140">Each specific repository interface implements the generic IRepository interface:</span></span>

```csharp
public interface IOrderRepository : IRepository<Order>
{
    Order Add(Order order);
    // ...
}
```

<span data-ttu-id="2ffea-141">Sin embargo, una mejor manera para que el código de aplicar la convención de que un único agregado debe estar relacionados con cada repositorio sería implementar un tipo de almacén genérico por lo que es explícita que está usando un repositorio para tener como destino un agregado concreto.</span><span class="sxs-lookup"><span data-stu-id="2ffea-141">However, a better way to have the code enforce the convention that each repository should be related to a single aggregate would be to implement a generic repository type so it is explicit that you are using a repository to target a specific aggregate.</span></span> <span data-ttu-id="2ffea-142">Esto puede hacer fácilmente mediante la implementación de ese genérico en la interfaz base IRepository, como se muestra en el código siguiente:</span><span class="sxs-lookup"><span data-stu-id="2ffea-142">That can be easily done by implementing that generic in the IRepository base interface, as in the following code:</span></span>

```csharp
  public interface IRepository<T> where T : IAggregateRoot
```

### <a name="the-repository-pattern-makes-it-easier-to-test-your-application-logic"></a><span data-ttu-id="2ffea-143">El modelo de repositorio facilita probar la lógica de aplicación</span><span class="sxs-lookup"><span data-stu-id="2ffea-143">The Repository pattern makes it easier to test your application logic</span></span>

<span data-ttu-id="2ffea-144">El modelo de repositorio permite fácilmente probar la aplicación en pruebas unitarias.</span><span class="sxs-lookup"><span data-stu-id="2ffea-144">The Repository pattern allows you to easily test your application with unit tests.</span></span> <span data-ttu-id="2ffea-145">Recuerde que las pruebas unitarias prueba solo su código, no en la infraestructura, por lo que las abstracciones de repositorio que sea más fácil alcanzar ese objetivo.</span><span class="sxs-lookup"><span data-stu-id="2ffea-145">Remember that unit tests only test your code, not infrastructure, so the repository abstractions make it easier to achieve that goal.</span></span>

<span data-ttu-id="2ffea-146">Como se indicó en una sección anterior, se recomienda que defina y coloque las interfaces de repositorio en el nivel de modelo de dominio por lo que no dependen de la capa de aplicación (por ejemplo, su microservicio API Web) directamente en el nivel de infraestructura que tiene implementa las clases de repositorio real.</span><span class="sxs-lookup"><span data-stu-id="2ffea-146">As noted in an earlier section, it is recommended that you define and place the repository interfaces in the domain model layer so the application layer (for instance, your Web API microservice) does not depend directly on the infrastructure layer where you have implemented the actual repository classes.</span></span> <span data-ttu-id="2ffea-147">Al hacerlo y usar inserción de dependencias en los controladores de la API de Web, puede implementar repositorios ficticios que devuelven datos falsos en lugar de datos de la base de datos.</span><span class="sxs-lookup"><span data-stu-id="2ffea-147">By doing this and using Dependency Injection in the controllers of your Web API, you can implement mock repositories that return fake data instead of data from the database.</span></span> <span data-ttu-id="2ffea-148">Que el enfoque desacoplado le permite crear y las pruebas unitarias de ejecución pueden probar simplemente la lógica de la aplicación sin necesidad de conectividad a la base de datos.</span><span class="sxs-lookup"><span data-stu-id="2ffea-148">That decoupled approach allows you to create and run unit tests that can test just the logic of your application without requiring connectivity to the database.</span></span>

<span data-ttu-id="2ffea-149">Las conexiones a bases de datos pueden realizarse y, más importante aún, ejecutan centenares de pruebas en una base de datos está dañada por dos motivos.</span><span class="sxs-lookup"><span data-stu-id="2ffea-149">Connections to databases can fail and, more importantly, running hundreds of tests against a database is bad for two reasons.</span></span> <span data-ttu-id="2ffea-150">En primer lugar, puede tardar mucho tiempo debido al gran número de pruebas.</span><span class="sxs-lookup"><span data-stu-id="2ffea-150">First, it can take a lot of time because of the large number of tests.</span></span> <span data-ttu-id="2ffea-151">En segundo lugar, los registros de base de datos pueden cambiar y afectar a los resultados de las pruebas, por lo que podrían no ser coherentes.</span><span class="sxs-lookup"><span data-stu-id="2ffea-151">Second, the database records might change and impact the results of your tests, so that they might not be consistent.</span></span> <span data-ttu-id="2ffea-152">Pruebas con la base de datos no son una unidad de prueba sino una integración de pruebas.</span><span class="sxs-lookup"><span data-stu-id="2ffea-152">Testing against the database is not a unit tests but an integration test.</span></span> <span data-ttu-id="2ffea-153">Debería tener muchas pruebas unitarias con rapidez, pero menos integración comprueba en las bases de datos.</span><span class="sxs-lookup"><span data-stu-id="2ffea-153">You should have many unit tests running fast, but fewer integration tests against the databases.</span></span>

<span data-ttu-id="2ffea-154">En cuanto a la separación de intereses para las pruebas unitarias, la lógica funciona en entidades de dominio en la memoria.</span><span class="sxs-lookup"><span data-stu-id="2ffea-154">In terms of separation of concerns for unit tests, your logic operates on domain entities in memory.</span></span> <span data-ttu-id="2ffea-155">Se supone que la clase de repositorio ha entregado los.</span><span class="sxs-lookup"><span data-stu-id="2ffea-155">It assumes the repository class has delivered those.</span></span> <span data-ttu-id="2ffea-156">Una vez que la lógica de modifica las entidades de dominio, se supone que la clase del repositorio los almacenará correctamente.</span><span class="sxs-lookup"><span data-stu-id="2ffea-156">Once your logic modifies the domain entities, it assumes the repository class will store them correctly.</span></span> <span data-ttu-id="2ffea-157">La cuestión importante aquí es crear pruebas unitarias para el modelo de dominio y su lógica de dominio.</span><span class="sxs-lookup"><span data-stu-id="2ffea-157">The important point here is to create unit tests against your domain model and its domain logic.</span></span> <span data-ttu-id="2ffea-158">Las raíces agregadas son los límites de coherencia principal en DDD.</span><span class="sxs-lookup"><span data-stu-id="2ffea-158">Aggregate roots are the main consistency boundaries in DDD.</span></span>

### <a name="the-difference-between-the-repository-pattern-and-the-legacy-data-access-class-dal-class-pattern"></a><span data-ttu-id="2ffea-159">La diferencia entre el modelo de repositorio y el patrón DAL (clase) de acceso a datos heredado</span><span class="sxs-lookup"><span data-stu-id="2ffea-159">The difference between the Repository pattern and the legacy Data Access class (DAL class) pattern</span></span>

<span data-ttu-id="2ffea-160">Un objeto de acceso a datos directamente realiza operaciones de acceso y persistencia de datos en almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="2ffea-160">A data access object directly performs data access and persistence operations against storage.</span></span> <span data-ttu-id="2ffea-161">Marcas de repositorio que los datos con las operaciones que desea realizar en la memoria de una unidad de objeto de trabajo (como en EF al usar DbContext), pero estas actualizaciones no se realizará inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="2ffea-161">A repository marks the data with the operations you want to perform in the memory of a unit of work object (as in EF when using the DbContext), but these updates will not be performed immediately.</span></span>

<span data-ttu-id="2ffea-162">Una unidad de trabajo se conoce como una sola transacción que implica varias Insertar, actualizar o eliminar operaciones.</span><span class="sxs-lookup"><span data-stu-id="2ffea-162">A unit of work is referred to as a single transaction that involves multiple insert, update, or delete operations.</span></span> <span data-ttu-id="2ffea-163">En otras palabras, significa que para una acción de usuario específico (por ejemplo, el registro en un sitio Web), el de insert, update y delete transacciones se administran en una sola transacción.</span><span class="sxs-lookup"><span data-stu-id="2ffea-163">In simple terms, it means that for a specific user action (for example, registration on a website), all the insert, update, and delete transactions are handled in a single transaction.</span></span> <span data-ttu-id="2ffea-164">Esto es más eficaz que el control de varias transacciones de base de datos de una manera chattier.</span><span class="sxs-lookup"><span data-stu-id="2ffea-164">This is more efficient than handling multiple database transactions in a chattier way.</span></span>

<span data-ttu-id="2ffea-165">Estos varias operaciones de persistencia se realizará más adelante en una sola acción cuando el código de la capa de aplicación los comandos.</span><span class="sxs-lookup"><span data-stu-id="2ffea-165">These multiple persistence operations will be performed later in a single action when your code from the application layer commands it.</span></span> <span data-ttu-id="2ffea-166">La decisión sobre cómo aplicar los cambios en memoria para el almacenamiento real de la base de datos normalmente se basa en el [patrón de la unidad de trabajo](http://martinfowler.com/eaaCatalog/unitOfWork.html).</span><span class="sxs-lookup"><span data-stu-id="2ffea-166">The decision about applying the in-memory changes to the actual database storage is typically based on the [Unit of Work pattern](http://martinfowler.com/eaaCatalog/unitOfWork.html).</span></span> <span data-ttu-id="2ffea-167">En EF, se implementa el patrón de la unidad de trabajo como DBContext.</span><span class="sxs-lookup"><span data-stu-id="2ffea-167">In EF, the Unit of Work pattern is implemented as the DBContext.</span></span>

<span data-ttu-id="2ffea-168">En muchos casos, este patrón o una forma de aplicar las operaciones en el almacenamiento puede aumentar el rendimiento de la aplicación y reducir la posibilidad de incoherencias.</span><span class="sxs-lookup"><span data-stu-id="2ffea-168">In many cases, this pattern or way of applying operations against the storage can increase application performance and reduce the possibility of inconsistencies.</span></span> <span data-ttu-id="2ffea-169">Además, reduce transacciones de bloqueo en las tablas de base de datos, ya que todas las operaciones previstas se confirmará como parte de una transacción.</span><span class="sxs-lookup"><span data-stu-id="2ffea-169">Also, it reduces transaction blocking in the database tables, because all the intended operations are committed as part of one transaction.</span></span> <span data-ttu-id="2ffea-170">Esto es más eficaz en comparación con la ejecución de muchas operaciones aisladas en la base de datos.</span><span class="sxs-lookup"><span data-stu-id="2ffea-170">This is more efficient in comparison to executing many isolated operations against the database.</span></span> <span data-ttu-id="2ffea-171">Por lo tanto, la ORM seleccionado podrán realizar optimizar la ejecución en la base de datos mediante la agrupación de varias acciones de actualización en la misma transacción, en lugar de varias ejecuciones de transacciones pequeñas e independientes.</span><span class="sxs-lookup"><span data-stu-id="2ffea-171">Therefore, the selected ORM will be able to optimize the execution against the database by grouping several update actions within the same transaction, as opposed to many small and separate transaction executions.</span></span>

### <a name="repositories-should-not-be-mandatory"></a><span data-ttu-id="2ffea-172">Repositorios no deberían ser obligatorios</span><span class="sxs-lookup"><span data-stu-id="2ffea-172">Repositories should not be mandatory</span></span>

<span data-ttu-id="2ffea-173">Los repositorios personalizados son útiles para los motivos citados anteriormente, y es el enfoque para la ordenación microservicio en eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="2ffea-173">Custom repositories are useful for the reasons cited earlier, and that is the approach for the ordering microservice in eShopOnContainers.</span></span> <span data-ttu-id="2ffea-174">Sin embargo, no es un patrón esencial para implementar en un diseño DDD o incluso en general desarrollo en. NET.</span><span class="sxs-lookup"><span data-stu-id="2ffea-174">However, it is not an essential pattern to implement in a DDD design or even in general development in .NET.</span></span>

<span data-ttu-id="2ffea-175">Por ejemplo, Jimmy Bogard, al proporcionar información directa sobre esta guía, dice lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="2ffea-175">For instance, Jimmy Bogard, when providing direct feedback for this guide, said the following:</span></span>

<span data-ttu-id="2ffea-176">Esto probablemente estará mis comentarios más importantes.</span><span class="sxs-lookup"><span data-stu-id="2ffea-176">This’ll probably be my biggest feedback.</span></span> <span data-ttu-id="2ffea-177">Realmente no estoy un ventilador de repositorios, principalmente porque ocultan los detalles importantes del mecanismo de persistencia subyacente.</span><span class="sxs-lookup"><span data-stu-id="2ffea-177">I’m really not a fan of repositories, mainly because they hide the important details of the underlying persistence mechanism.</span></span> <span data-ttu-id="2ffea-178">Su ¿por qué ir para MediatR para los comandos, demasiado.</span><span class="sxs-lookup"><span data-stu-id="2ffea-178">It’s why I go for MediatR for commands, too.</span></span> <span data-ttu-id="2ffea-179">Puedo usar toda la funcionalidad de la capa de persistencia e insertar ese comportamiento de dominio en las raíces agregadas.</span><span class="sxs-lookup"><span data-stu-id="2ffea-179">I can use the full power of the persistence layer, and push all that domain behavior into my aggregate roots.</span></span> <span data-ttu-id="2ffea-180">Normalmente no desea simular mi repositorios: sigue siendo necesario tener que la integración de prueba con la acción real.</span><span class="sxs-lookup"><span data-stu-id="2ffea-180">I don’t usually want to mock my repositories – I still need to have that integration test with the real thing.</span></span> <span data-ttu-id="2ffea-181">Vaya CQRS significaba que realmente no teníamos una necesidad de repositorios más.</span><span class="sxs-lookup"><span data-stu-id="2ffea-181">Going CQRS meant that we didn’t really have a need for repositories any more.</span></span>

<span data-ttu-id="2ffea-182">Se encontraron repositorios útil, pero sabemos que no son críticos para el DDD, en la forma en que el patrón de agregado y el modelo de dominio enriquecido son.</span><span class="sxs-lookup"><span data-stu-id="2ffea-182">We find repositories useful, but we acknowledge that they are not critical for your DDD, in the way that the Aggregate pattern and rich domain model are.</span></span> <span data-ttu-id="2ffea-183">Por lo tanto, utilice el modelo de repositorio o no, como ver quepa.</span><span class="sxs-lookup"><span data-stu-id="2ffea-183">Therefore, use the Repository pattern or not, as you see fit.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="2ffea-184">Recursos adicionales</span><span class="sxs-lookup"><span data-stu-id="2ffea-184">Additional resources</span></span>

##### <a name="the-repository-pattern"></a><span data-ttu-id="2ffea-185">El modelo de repositorio</span><span class="sxs-lookup"><span data-stu-id="2ffea-185">The Repository pattern</span></span>

-   <span data-ttu-id="2ffea-186">**Edward Hieatt y Rob me. Modelo de repositorio. ** 
     [ *http://martinfowler.com/eaaCatalog/repository.html*](http://martinfowler.com/eaaCatalog/repository.html)</span><span class="sxs-lookup"><span data-stu-id="2ffea-186">**Edward Hieatt and Rob Mee. Repository pattern.**
[*http://martinfowler.com/eaaCatalog/repository.html*](http://martinfowler.com/eaaCatalog/repository.html)</span></span>

-   <span data-ttu-id="2ffea-187">**El modelo de repositorio**
    [*https://msdn.microsoft.com/en-us/library/ff649690.aspx*](https://msdn.microsoft.com/en-us/library/ff649690.aspx)</span><span class="sxs-lookup"><span data-stu-id="2ffea-187">**The Repository pattern**
[*https://msdn.microsoft.com/en-us/library/ff649690.aspx*](https://msdn.microsoft.com/en-us/library/ff649690.aspx)</span></span>

-   <span data-ttu-id="2ffea-188">**Modelo de repositorio: Una persistencia abstracción de datos**
    [*http://deviq.com/repository-pattern/*](http://deviq.com/repository-pattern/)</span><span class="sxs-lookup"><span data-stu-id="2ffea-188">**Repository Pattern: A data persistence abstraction**
[*http://deviq.com/repository-pattern/*](http://deviq.com/repository-pattern/)</span></span>

-   <span data-ttu-id="2ffea-189">**Eric Evans. Diseño basado en dominio: Realiza para complejidad en el centro de Software.**</span><span class="sxs-lookup"><span data-stu-id="2ffea-189">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="2ffea-190">(Libro; incluye una explicación sobre el modelo de repositorio) [ *https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span><span class="sxs-lookup"><span data-stu-id="2ffea-190">(Book; includes a discussion of the Repository pattern) [*https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span></span>

##### <a name="unit-of-work-pattern"></a><span data-ttu-id="2ffea-191">Unidad de patrón de trabajo</span><span class="sxs-lookup"><span data-stu-id="2ffea-191">Unit of Work pattern</span></span>

-   <span data-ttu-id="2ffea-192">**Martin Fowler. Unidad de patrón de trabajo. ** 
     [ *http://martinfowler.com/eaaCatalog/unitOfWork.html*](http://martinfowler.com/eaaCatalog/unitOfWork.html)</span><span class="sxs-lookup"><span data-stu-id="2ffea-192">**Martin Fowler. Unit of Work pattern.**
[*http://martinfowler.com/eaaCatalog/unitOfWork.html*](http://martinfowler.com/eaaCatalog/unitOfWork.html)</span></span>

<!-- -->

-   <span data-ttu-id="2ffea-193">**Implementar el repositorio y una unidad de patrones de trabajo en una aplicación de ASP.NET MVC**
    [*https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/ Implementing-the-Repository-and-Unit-of-Work-Patterns-in-an-ASP-NET-MVC-Application*](https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span><span class="sxs-lookup"><span data-stu-id="2ffea-193">**Implementing the Repository and Unit of Work Patterns in an ASP.NET MVC Application**
[*https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application*](https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="2ffea-194">[Anterior] (dominio-eventos-diseño-implementation.md) [siguiente] (infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span><span class="sxs-lookup"><span data-stu-id="2ffea-194">[Previous] (domain-events-design-implementation.md) [Next] (infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span></span>
