---
title: Diseño de la capa de persistencia de infraestructura
description: Obtenga información sobre cómo diseñar la capa de persistencia de infraestructura.
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 06/28/2017
ms.openlocfilehash: a0fcaead363e41f0dd02ed1e2ddfc90afb8d0c57
ms.sourcegitcommit: 4c158beee818c408d45a9609bfc06f209a523e22
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 07/03/2018
ms.locfileid: "37404478"
---
# <a name="designing-the-infrastructure-persistence-layer"></a><span data-ttu-id="48e91-103">Diseño de la capa de persistencia de infraestructura</span><span class="sxs-lookup"><span data-stu-id="48e91-103">Designing the infrastructure persistence layer</span></span>

<span data-ttu-id="48e91-104">Los componentes de persistencia de datos proporcionan acceso a los datos que se hospedan dentro de los límites de un microservicio (es decir, la base de datos de un microservicio).</span><span class="sxs-lookup"><span data-stu-id="48e91-104">Data persistence components provide access to the data hosted within the boundaries of a microservice (that is, a microservice’s database).</span></span> <span data-ttu-id="48e91-105">Contienen la implementación real de componentes como repositorios y clases de [unidad de trabajo](https://martinfowler.com/eaaCatalog/unitOfWork.html), como los objetos <xref:Microsoft.EntityFrameworkCore.DbContext> de Entity Framework (EF).</span><span class="sxs-lookup"><span data-stu-id="48e91-105">They contain the actual implementation of components such as repositories and [Unit of Work](https://martinfowler.com/eaaCatalog/unitOfWork.html) classes, like custom Entity Framework (EF) <xref:Microsoft.EntityFrameworkCore.DbContext> objects.</span></span>

## <a name="the-repository-pattern"></a><span data-ttu-id="48e91-106">El modelo de repositorio</span><span class="sxs-lookup"><span data-stu-id="48e91-106">The Repository pattern</span></span>

<span data-ttu-id="48e91-107">Los repositorios son clases o componentes que encapsulan la lógica necesaria para tener acceso a orígenes de datos.</span><span class="sxs-lookup"><span data-stu-id="48e91-107">Repositories are classes or components that encapsulate the logic required to access data sources.</span></span> <span data-ttu-id="48e91-108">Centralizan la funcionalidad de acceso a datos comunes, lo que proporciona un mejor mantenimiento y el desacoplamiento de la infraestructura o tecnología que se usa para acceder a bases de datos desde el nivel de modelo de dominio.</span><span class="sxs-lookup"><span data-stu-id="48e91-108">They centralize common data access functionality, providing better maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer.</span></span> <span data-ttu-id="48e91-109">Si se usa una asignación relacional de objetos (ORM) como Entity Framework, se simplifica el código que se debe implementar, gracias a LINQ y al establecimiento inflexible de tipos.</span><span class="sxs-lookup"><span data-stu-id="48e91-109">If you use an object-relational mapping (ORM) like Entity Framework, the code that must be implemented is simplified, thanks to LINQ and strong typing.</span></span> <span data-ttu-id="48e91-110">Esto permite centrarse en la lógica de persistencia de datos en lugar del establecimiento del acceso a los datos.</span><span class="sxs-lookup"><span data-stu-id="48e91-110">This lets you focus on the data persistence logic rather than on data access plumbing.</span></span>

<span data-ttu-id="48e91-111">El modelo de repositorio es una manera bien documentada de trabajar con un origen de datos.</span><span class="sxs-lookup"><span data-stu-id="48e91-111">The Repository pattern is a well-documented way of working with a data source.</span></span> <span data-ttu-id="48e91-112">En el libro [Patterns of Enterprise Application Architecture](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/) (Patrones de arquitectura de aplicaciones empresariales), Martin Fowler describe un repositorio de esta forma:</span><span class="sxs-lookup"><span data-stu-id="48e91-112">In the book [Patterns of Enterprise Application Architecture](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler describes a repository as follows:</span></span>

> <span data-ttu-id="48e91-113">Un repositorio realiza las tareas de un intermediario entre los niveles de modelo de dominio y asignación de datos, actuando de forma similar a un conjunto de objetos de dominio en memoria.</span><span class="sxs-lookup"><span data-stu-id="48e91-113">A repository performs the tasks of an intermediary between the domain model layers and data mapping, acting in a similar way to a set of domain objects in memory.</span></span> <span data-ttu-id="48e91-114">Los objetos de cliente generan consultas mediante declaraciones y las envían a los repositorios para obtener las respuestas.</span><span class="sxs-lookup"><span data-stu-id="48e91-114">Client objects declaratively build queries and send them to the repositories for answers.</span></span> <span data-ttu-id="48e91-115">Conceptualmente, un repositorio encapsula un conjunto de objetos almacenados en la base de datos y las operaciones que se pueden realizar en ellos, proporcionando una manera de que esté más cerca de la capa de persistencia.</span><span class="sxs-lookup"><span data-stu-id="48e91-115">Conceptually, a repository encapsulates a set of objects stored in the database and operations that can be performed on them, providing a way that is closer to the persistence layer.</span></span> <span data-ttu-id="48e91-116">Además, los repositorios admiten la finalidad de separar, con claridad y en una dirección, la dependencia entre el dominio de trabajo y la asignación de datos.</span><span class="sxs-lookup"><span data-stu-id="48e91-116">Repositories, also, support the purpose of separating, clearly and in one direction, the dependency between the work domain and the data allocation or mapping.</span></span>

### <a name="define-one-repository-per-aggregate"></a><span data-ttu-id="48e91-117">Definir un repositorio por agregado</span><span class="sxs-lookup"><span data-stu-id="48e91-117">Define one repository per aggregate</span></span>

<span data-ttu-id="48e91-118">Para cada agregado o raíz agregada, se debe crear una clase de repositorio.</span><span class="sxs-lookup"><span data-stu-id="48e91-118">For each aggregate or aggregate root, you should create one repository class.</span></span> <span data-ttu-id="48e91-119">En un microservicio basado en patrones de diseño controlado por dominios (DDD), el único canal que se debe usar para actualizar la base de datos deben ser los repositorios.</span><span class="sxs-lookup"><span data-stu-id="48e91-119">In a microservice based on domain-driven design (DDD) patterns, the only channel you should use to update the database should be the repositories.</span></span> <span data-ttu-id="48e91-120">Esto se debe a que tienen una relación uno a uno con la raíz agregada, que controla las invariables del agregado y la coherencia transaccional.</span><span class="sxs-lookup"><span data-stu-id="48e91-120">This is because they have a one-to-one relationship with the aggregate root, which controls the aggregate’s invariants and transactional consistency.</span></span> <span data-ttu-id="48e91-121">Es correcto consultar la base de datos a través de otros canales (como con un enfoque CQRS), dado que las consultas no cambian el estado de la base de datos.</span><span class="sxs-lookup"><span data-stu-id="48e91-121">It's okay to query the database through other channels (as you can do following a CQRS approach), because queries don't change the state of the database.</span></span> <span data-ttu-id="48e91-122">Pero el área transaccional (es decir, las actualizaciones) siempre se debe controlar mediante los repositorios y las raíces agregadas.</span><span class="sxs-lookup"><span data-stu-id="48e91-122">However, the transactional area (that is, the updates) must always be controlled by the repositories and the aggregate roots.</span></span>

<span data-ttu-id="48e91-123">Básicamente, un repositorio permite rellenar los datos en memoria que proceden de la base de datos en forma de entidades de dominio.</span><span class="sxs-lookup"><span data-stu-id="48e91-123">Basically, a repository allows you to populate data in memory that comes from the database in the form of the domain entities.</span></span> <span data-ttu-id="48e91-124">Una vez que las entidades se encuentran en memoria, se pueden cambiar y después volver a conservar en la base de datos a través de transacciones.</span><span class="sxs-lookup"><span data-stu-id="48e91-124">Once the entities are in memory, they can be changed and then persisted back to the database through transactions.</span></span>

<span data-ttu-id="48e91-125">Como se indicó anteriormente, si se usa el modelo de arquitectura de CQS/CQRS, las consultas iniciales se realizan por medio de consultas paralelas fuera del modelo de dominio, ejecutadas por instrucciones SQL simples mediante Dapper.</span><span class="sxs-lookup"><span data-stu-id="48e91-125">As noted earlier, if you're using the CQS/CQRS architectural pattern, the initial queries are performed by side queries out of the domain model, performed by simple SQL statements using Dapper.</span></span> <span data-ttu-id="48e91-126">Este enfoque es mucho más flexible que los repositorios, ya que se pueden consultar y combinar las tablas que se necesitan, y estas consultas no están limitadas por las reglas de los agregados.</span><span class="sxs-lookup"><span data-stu-id="48e91-126">This approach is much more flexible than repositories because you can query and join any tables you need, and these queries aren't restricted by rules from the aggregates.</span></span> <span data-ttu-id="48e91-127">Esos datos van a la capa de presentación o a la aplicación cliente.</span><span class="sxs-lookup"><span data-stu-id="48e91-127">That data goes to the presentation layer or client app.</span></span>

<span data-ttu-id="48e91-128">Si el usuario realiza cambios, los datos que se van a actualizar proceden de la aplicación cliente o la capa de presentación al nivel de la aplicación (por ejemplo, un servicio de API web).</span><span class="sxs-lookup"><span data-stu-id="48e91-128">If the user makes changes, the data to be updated comes from the client app or presentation layer to the application layer (such as a Web API service).</span></span> <span data-ttu-id="48e91-129">Cuando se recibe un comando con datos en un controlador de comandos, se usan repositorios para obtener los datos que se quieren actualizar desde la base de datos.</span><span class="sxs-lookup"><span data-stu-id="48e91-129">When you receive a command with data in a command handler, you use repositories to get the data you want to update from the database.</span></span> <span data-ttu-id="48e91-130">Se actualiza en memoria con la información que se pasa con los comandos y, después, se agregan o actualizan los datos (entidades de dominio) en la base de datos a través de una transacción.</span><span class="sxs-lookup"><span data-stu-id="48e91-130">You update it in memory with the information passed with the commands, and you then add or update the data (domain entities) in the database through a transaction.</span></span>

<span data-ttu-id="48e91-131">Recuerde que solo se debe definir un repositorio para cada raíz agregada, como se muestra en la figura 9-17.</span><span class="sxs-lookup"><span data-stu-id="48e91-131">Remember that only one repository should be defined for each aggregate root, as shown in Figure 9-17.</span></span> <span data-ttu-id="48e91-132">Para lograr el objetivo de la raíz agregada de mantener la coherencia transaccional entre todos los objetos del agregado, nunca se debe crear un repositorio para cada tabla de la base de datos.</span><span class="sxs-lookup"><span data-stu-id="48e91-132">To achieve the goal of the aggregate root to maintain transactional consistency between all the objects within the aggregate, you should never create a repository for each table in the database.</span></span>

![](./media/image18.png)

<span data-ttu-id="48e91-133">**Figura 9-17**.</span><span class="sxs-lookup"><span data-stu-id="48e91-133">**Figure 9-17**.</span></span> <span data-ttu-id="48e91-134">La relación entre repositorios, agregados y tablas de base de datos</span><span class="sxs-lookup"><span data-stu-id="48e91-134">The relationship between repositories, aggregates, and database tables</span></span>

### <a name="enforcing-one-aggregate-root-per-repository"></a><span data-ttu-id="48e91-135">Aplicación de una raíz agregada por repositorio</span><span class="sxs-lookup"><span data-stu-id="48e91-135">Enforcing one aggregate root per repository</span></span>

<span data-ttu-id="48e91-136">Puede ser útil implementar el diseño de repositorio de tal manera que aplique la regla de que solo las raíces agregadas deban tener repositorios.</span><span class="sxs-lookup"><span data-stu-id="48e91-136">It can be valuable to implement your repository design in such a way that it enforces the rule that only aggregate roots should have repositories.</span></span> <span data-ttu-id="48e91-137">Puede crear un tipo de repositorio base o genérico que limite el tipo de las entidades con las que funciona para asegurarse de que tengan la interfaz de marcador `IAggregateRoot`.</span><span class="sxs-lookup"><span data-stu-id="48e91-137">You can create a generic or base repository type that constrains the type of entities it works with to ensure they have the `IAggregateRoot` marker interface.</span></span>

<span data-ttu-id="48e91-138">Por tanto, cada clase de repositorio que se implemente en el nivel de infraestructura implementa su propio contrato o interfaz, como se muestra en el código siguiente:</span><span class="sxs-lookup"><span data-stu-id="48e91-138">Thus, each repository class implemented at the infrastructure layer implements its own contract or interface, as shown in the following code:</span></span>

```csharp
namespace Microsoft.eShopOnContainers.Services.Ordering.Infrastructure.Repositories
{
    public class OrderRepository : IOrderRepository
    {
      // ...
    }
}
```

<span data-ttu-id="48e91-139">Cada interfaz de repositorio específica implementa la interfaz genérica IRepository:</span><span class="sxs-lookup"><span data-stu-id="48e91-139">Each specific repository interface implements the generic IRepository interface:</span></span>

```csharp
public interface IOrderRepository : IRepository<Order>
{
    Order Add(Order order);
    // ...
}
```

<span data-ttu-id="48e91-140">Pero una manera mejor de que el código aplique la convención de que cada repositorio esté relacionado con un único agregado consiste en implementar un tipo de repositorio genérico.</span><span class="sxs-lookup"><span data-stu-id="48e91-140">However, a better way to have the code enforce the convention that each repository is related to a single aggregate is to implement a generic repository type.</span></span> <span data-ttu-id="48e91-141">De este modo, es explícito que se está usando un repositorio para tener como destino un agregado concreto.</span><span class="sxs-lookup"><span data-stu-id="48e91-141">That way, it's explicit that you're using a repository to target a specific aggregate.</span></span> <span data-ttu-id="48e91-142">Eso se puede hacer fácilmente mediante la implementación de una interfaz base `IRepository` genérica, como se muestra en el código siguiente:</span><span class="sxs-lookup"><span data-stu-id="48e91-142">That can be easily done by implementing a generic `IRepository` base interface, as in the following code:</span></span>

```csharp
public interface IRepository<T> where T : IAggregateRoot
{
    //....
}
```

### <a name="the-repository-pattern-makes-it-easier-to-test-your-application-logic"></a><span data-ttu-id="48e91-143">El modelo de repositorio facilita probar la lógica de la aplicación</span><span class="sxs-lookup"><span data-stu-id="48e91-143">The Repository pattern makes it easier to test your application logic</span></span>

<span data-ttu-id="48e91-144">El modelo de repositorio permite probar fácilmente la aplicación en pruebas unitarias.</span><span class="sxs-lookup"><span data-stu-id="48e91-144">The Repository pattern allows you to easily test your application with unit tests.</span></span> <span data-ttu-id="48e91-145">Recuerde que en las pruebas unitarias solo se prueba el código, no la infraestructura, por lo que las abstracciones de repositorio facilitan alcanzar ese objetivo.</span><span class="sxs-lookup"><span data-stu-id="48e91-145">Remember that unit tests only test your code, not infrastructure, so the repository abstractions make it easier to achieve that goal.</span></span>

<span data-ttu-id="48e91-146">Como se indicó en una sección anterior, se recomienda definir y colocar las interfaces de repositorio en el nivel de modelo de dominio para que el nivel de aplicación (como el microservicio de API web) no dependa directamente del nivel de infraestructura en el que se han implementado las clases de repositorio reales.</span><span class="sxs-lookup"><span data-stu-id="48e91-146">As noted in an earlier section, it's recommended that you define and place the repository interfaces in the domain model layer so the application layer, such as your Web API microservice, doesn't depend directly on the infrastructure layer where you've implemented the actual repository classes.</span></span> <span data-ttu-id="48e91-147">Al hacer esto y usar la inserción de dependencias en los controladores de la API web, puede implementar repositorios ficticios que devuelven datos falsos en lugar de datos de la base de datos.</span><span class="sxs-lookup"><span data-stu-id="48e91-147">By doing this and using Dependency Injection in the controllers of your Web API, you can implement mock repositories that return fake data instead of data from the database.</span></span> <span data-ttu-id="48e91-148">Ese enfoque desacoplado permite crear y ejecutar pruebas unitarias que pueden probar simplemente la lógica de la aplicación sin necesidad de conectividad a la base de datos.</span><span class="sxs-lookup"><span data-stu-id="48e91-148">This decoupled approach allows you to create and run unit tests that can test just the logic of your application without requiring connectivity to the database.</span></span>

<span data-ttu-id="48e91-149">Se pueden producir errores en las conexiones a las bases de datos y, más importante aún, la ejecución de centenares de pruebas en una base de datos no es recomendable por dos motivos.</span><span class="sxs-lookup"><span data-stu-id="48e91-149">Connections to databases can fail and, more importantly, running hundreds of tests against a database is bad for two reasons.</span></span> <span data-ttu-id="48e91-150">En primer lugar, puede tardar mucho tiempo debido al gran número de pruebas.</span><span class="sxs-lookup"><span data-stu-id="48e91-150">First, it can take a long time because of the large number of tests.</span></span> <span data-ttu-id="48e91-151">En segundo lugar, es posible que los registros de base de datos cambien y afecten a los resultados de las pruebas, por lo que podrían no ser coherentes.</span><span class="sxs-lookup"><span data-stu-id="48e91-151">Second, the database records might change and impact the results of your tests, so that they might not be consistent.</span></span> <span data-ttu-id="48e91-152">Realizar pruebas en la base de datos no es una prueba unitaria sino una prueba de integración.</span><span class="sxs-lookup"><span data-stu-id="48e91-152">Testing against the database isn't a unit test but an integration test.</span></span> <span data-ttu-id="48e91-153">Debería tener muchas pruebas unitarias que se ejecuten con rapidez, pero menos pruebas de integración sobre las bases de datos.</span><span class="sxs-lookup"><span data-stu-id="48e91-153">You should have many unit tests running fast, but fewer integration tests against the databases.</span></span>

<span data-ttu-id="48e91-154">En cuanto a la separación de intereses para las pruebas unitarias, la lógica funciona en entidades de dominio en memoria,</span><span class="sxs-lookup"><span data-stu-id="48e91-154">In terms of separation of concerns for unit tests, your logic operates on domain entities in memory.</span></span> <span data-ttu-id="48e91-155">ya que supone que la clase de repositorio las ha entregado.</span><span class="sxs-lookup"><span data-stu-id="48e91-155">It assumes the repository class has delivered those.</span></span> <span data-ttu-id="48e91-156">Una vez que la lógica modifica las entidades de dominio, asume que la clase del repositorio las almacenará correctamente.</span><span class="sxs-lookup"><span data-stu-id="48e91-156">Once your logic modifies the domain entities, it assumes the repository class will store them correctly.</span></span> <span data-ttu-id="48e91-157">El aspecto importante aquí es crear pruebas unitarias para el modelo de dominio y su lógica de dominio.</span><span class="sxs-lookup"><span data-stu-id="48e91-157">The important point here is to create unit tests against your domain model and its domain logic.</span></span> <span data-ttu-id="48e91-158">Las raíces agregadas son los límites de coherencia principales en DDD.</span><span class="sxs-lookup"><span data-stu-id="48e91-158">Aggregate roots are the main consistency boundaries in DDD.</span></span>

### <a name="the-difference-between-the-repository-pattern-and-the-legacy-data-access-class-dal-class-pattern"></a><span data-ttu-id="48e91-159">La diferencia entre el modelo de repositorio y el patrón de clases de acceso a datos (DAL) heredado</span><span class="sxs-lookup"><span data-stu-id="48e91-159">The difference between the Repository pattern and the legacy Data Access class (DAL class) pattern</span></span>

<span data-ttu-id="48e91-160">Un objeto de acceso a datos realiza directamente operaciones de acceso y persistencia de datos en el almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="48e91-160">A data access object directly performs data access and persistence operations against storage.</span></span> <span data-ttu-id="48e91-161">Un repositorio marca los datos con las operaciones que se quieren realizar en la memoria de un objeto de unidad de trabajo (como sucede en EF al usar la clase <xref:Microsoft.EntityFrameworkCore.DbContext>), pero estas actualizaciones no se realizan de forma inmediata.</span><span class="sxs-lookup"><span data-stu-id="48e91-161">A repository marks the data with the operations you want to perform in the memory of a unit of work object (as in EF when using the <xref:Microsoft.EntityFrameworkCore.DbContext> class), but these updates aren't performed immediately.</span></span>

<span data-ttu-id="48e91-162">Una unidad de trabajo se conoce como una sola transacción que implica varias operaciones de inserción, actualización o eliminación.</span><span class="sxs-lookup"><span data-stu-id="48e91-162">A unit of work is referred to as a single transaction that involves multiple insert, update, or delete operations.</span></span> <span data-ttu-id="48e91-163">En otras palabras, significa que para una acción de usuario específica (como el registro en un sitio web) todas las transacciones de inserción, actualización o eliminación se administran en una única transacción.</span><span class="sxs-lookup"><span data-stu-id="48e91-163">In simple terms, it means that for a specific user action, such as a registration on a website, all the insert, update, and delete transactions are handled in a single transaction.</span></span> <span data-ttu-id="48e91-164">Esto es más eficaz que el control de varias transacciones de base de datos de una manera profusa.</span><span class="sxs-lookup"><span data-stu-id="48e91-164">This is more efficient than handling multiple database transactions in a chattier way.</span></span>

<span data-ttu-id="48e91-165">Estos operaciones de persistencia múltiples se realizan más adelante en una sola acción cuando el código del nivel de aplicación lo ordena.</span><span class="sxs-lookup"><span data-stu-id="48e91-165">These multiple persistence operations are performed later in a single action when your code from the application layer commands it.</span></span> <span data-ttu-id="48e91-166">La decisión sobre cómo aplicar los cambios en memoria al almacenamiento de base de datos real normalmente se basa en el [patrón de unidades de trabajo](https://martinfowler.com/eaaCatalog/unitOfWork.html).</span><span class="sxs-lookup"><span data-stu-id="48e91-166">The decision about applying the in-memory changes to the actual database storage is typically based on the [Unit of Work pattern](https://martinfowler.com/eaaCatalog/unitOfWork.html).</span></span> <span data-ttu-id="48e91-167">En EF, el patrón de unidades de trabajo se implementa como el <xref:Microsoft.EntityFrameworkCore.DbContext>.</span><span class="sxs-lookup"><span data-stu-id="48e91-167">In EF, the Unit of Work pattern is implemented as the <xref:Microsoft.EntityFrameworkCore.DbContext>.</span></span>

<span data-ttu-id="48e91-168">En muchos casos, este patrón o forma de aplicar operaciones en el almacenamiento puede aumentar el rendimiento de la aplicación y reducir la posibilidad de incoherencias.</span><span class="sxs-lookup"><span data-stu-id="48e91-168">In many cases, this pattern or way of applying operations against the storage can increase application performance and reduce the possibility of inconsistencies.</span></span> <span data-ttu-id="48e91-169">También reduce el bloqueo de transacciones en las tablas de base de datos, ya que todas las operaciones previstas se confirman como parte de una transacción.</span><span class="sxs-lookup"><span data-stu-id="48e91-169">It also reduces transaction blocking in the database tables, because all the intended operations are committed as part of one transaction.</span></span> <span data-ttu-id="48e91-170">Esto es más eficaz en comparación con la ejecución de muchas operaciones aisladas en la base de datos.</span><span class="sxs-lookup"><span data-stu-id="48e91-170">This is more efficient in comparison to executing many isolated operations against the database.</span></span> <span data-ttu-id="48e91-171">Por tanto, el ORM seleccionado puede optimizar la ejecución en la base de datos mediante la agrupación de varias acciones de actualización en la misma transacción, en lugar de muchas ejecuciones de transacciones pequeñas e independientes.</span><span class="sxs-lookup"><span data-stu-id="48e91-171">Therefore, the selected ORM can optimize the execution against the database by grouping several update actions within the same transaction, as opposed to many small and separate transaction executions.</span></span>

### <a name="repositories-shouldnt-be-mandatory"></a><span data-ttu-id="48e91-172">Los repositorios no deben ser obligatorios</span><span class="sxs-lookup"><span data-stu-id="48e91-172">Repositories shouldn't be mandatory</span></span>

<span data-ttu-id="48e91-173">Los repositorios personalizados son útiles por los motivos citados anteriormente, y es el enfoque para el microservicio de pedidos de eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="48e91-173">Custom repositories are useful for the reasons cited earlier, and that is the approach for the ordering microservice in eShopOnContainers.</span></span> <span data-ttu-id="48e91-174">Pero no es un patrón esencial para implementar en un diseño de DDD o incluso en el desarrollo general de .NET.</span><span class="sxs-lookup"><span data-stu-id="48e91-174">However, it isn't an essential pattern to implement in a DDD design or even in general .NET development.</span></span>

<span data-ttu-id="48e91-175">Por ejemplo, Jimmy Bogard, al proporcionar información directa para esta guía, afirmó lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="48e91-175">For instance, Jimmy Bogard, when providing direct feedback for this guide, said the following:</span></span>

> <span data-ttu-id="48e91-176">Este probablemente será mi comentario más importante.</span><span class="sxs-lookup"><span data-stu-id="48e91-176">This’ll probably be my biggest feedback.</span></span> <span data-ttu-id="48e91-177">No soy un gran defensor de los repositorios, sobre todo porque ocultan los detalles importantes del mecanismo de persistencia subyacente.</span><span class="sxs-lookup"><span data-stu-id="48e91-177">I’m really not a fan of repositories, mainly because they hide the important details of the underlying persistence mechanism.</span></span> <span data-ttu-id="48e91-178">Por ese motivo también prefiero MediatR para los comandos.</span><span class="sxs-lookup"><span data-stu-id="48e91-178">It’s why I go for MediatR for commands, too.</span></span> <span data-ttu-id="48e91-179">Puedo usar toda la funcionalidad de la capa de persistencia e insertar todo ese comportamiento de dominio en las raíces agregadas.</span><span class="sxs-lookup"><span data-stu-id="48e91-179">I can use the full power of the persistence layer, and push all that domain behavior into my aggregate roots.</span></span> <span data-ttu-id="48e91-180">Normalmente no me interesa simular los repositorios: sigo necesitando que esa prueba de integración esté con la acción real.</span><span class="sxs-lookup"><span data-stu-id="48e91-180">I don’t usually want to mock my repositories – I still need to have that integration test with the real thing.</span></span> <span data-ttu-id="48e91-181">La elección de CQRS significaba que realmente ya no necesitábamos los repositorios.</span><span class="sxs-lookup"><span data-stu-id="48e91-181">Going CQRS meant that we didn’t really have a need for repositories any more.</span></span>

<span data-ttu-id="48e91-182">Los repositorios son útiles, pero no esenciales para el DDD, de la misma forma que el patrón de agregado y el modelo de dominio enriquecido lo son.</span><span class="sxs-lookup"><span data-stu-id="48e91-182">Repositories are useful, but they aren't critical for your DDD, in the way that the Aggregate pattern and rich domain model are.</span></span> <span data-ttu-id="48e91-183">Por tanto, use el modelo de repositorio o no, como considere oportuno.</span><span class="sxs-lookup"><span data-stu-id="48e91-183">Therefore, use the Repository pattern or not, as you see fit.</span></span>

## <a name="the-specification-pattern"></a><span data-ttu-id="48e91-184">El patrón de especificación</span><span class="sxs-lookup"><span data-stu-id="48e91-184">The Specification pattern</span></span>

<span data-ttu-id="48e91-185">El patrón de especificación (el nombre completo sería Patrón de especificación de consultas) es un modelo de diseño DDD que se designa como el lugar donde se puede incluir la definición de una consulta con lógica opcional de ordenación y paginación.</span><span class="sxs-lookup"><span data-stu-id="48e91-185">The specification pattern (its full name would be Query-specification pattern) is a DDD pattern designed as the place where you can put the definition of a query with optional sorting and paging logic.</span></span>

<span data-ttu-id="48e91-186">El patrón de especificación define una consulta en un objeto.</span><span class="sxs-lookup"><span data-stu-id="48e91-186">The specification pattern defines a query in an object.</span></span> <span data-ttu-id="48e91-187">Por ejemplo, para encapsular una consulta paginada que busque algunos productos, se puede crear una especificación `PagedProduct` que tome los parámetros de entrada necesarios, como `pageNumber`, `pageSize`, `filter`, etc. Después, dentro de cualquier método del repositorio (normalmente una sobrecarga de List()) aceptaría una `ISpecification` y ejecutaría la consulta esperada según esa especificación.</span><span class="sxs-lookup"><span data-stu-id="48e91-187">For example, to encapsulate a paged query that searches for some products, you can create a `PagedProduct` specification that takes the necessary input parameters, such as `pageNumber`, `pageSize`, `filter`, etc. Then, within any Repository method (usually a List() overload), it'd accept an `ISpecification` and run the expected query based on that specification.</span></span>

<span data-ttu-id="48e91-188">Este enfoque ofrece varias ventajas:</span><span class="sxs-lookup"><span data-stu-id="48e91-188">There are several benefits to this approach:</span></span>

- <span data-ttu-id="48e91-189">La especificación tiene un nombre (en contraposición a solo unas cuantas expresiones LINQ) del que se puede hablar.</span><span class="sxs-lookup"><span data-stu-id="48e91-189">The specification has a name (as opposed to just a bunch of LINQ expressions) that you can discuss about.</span></span>

- <span data-ttu-id="48e91-190">Se pueden realizar pruebas unitarias aisladas de la especificación para asegurarse de que es correcta.</span><span class="sxs-lookup"><span data-stu-id="48e91-190">The specification can be unit tested in isolation to ensure it's right.</span></span> <span data-ttu-id="48e91-191">También se puede reutilizar con facilidad si se necesita un comportamiento similar.</span><span class="sxs-lookup"><span data-stu-id="48e91-191">It can also easily be reused if you need similar behavior.</span></span> <span data-ttu-id="48e91-192">Por ejemplo, en una acción de vista de MVC y una de API web, así como en varios servicios.</span><span class="sxs-lookup"><span data-stu-id="48e91-192">For example, on an MVC View action and a Web API action, as well as in various services.</span></span>

- <span data-ttu-id="48e91-193">Una especificación también se puede usar para describir la forma de los datos que se van a devolver, para que las consultas puedan devolver solamente los datos que necesitan.</span><span class="sxs-lookup"><span data-stu-id="48e91-193">A specification can also be used to describe the shape of the data to be returned, so that queries can return just the data they required.</span></span> <span data-ttu-id="48e91-194">Esto elimina la necesidad de la carga diferida en las aplicaciones web (que no suele ser recomendable) y ayuda a evitar que las implementaciones de repositorio se colapsen con estos detalles.</span><span class="sxs-lookup"><span data-stu-id="48e91-194">This eliminates the need for lazy loading in web applications, which is usually not recommended, and helps keep repository implementations from becoming cluttered with these details.</span></span>

<span data-ttu-id="48e91-195">Un ejemplo de una interfaz de especificación genérica es el código siguiente de [eShopOnWeb](https://github.com/dotnet-architecture/eShopOnWeb).</span><span class="sxs-lookup"><span data-stu-id="48e91-195">An example of a generic specification interface is the following code from [eShopOnWeb](https://github.com/dotnet-architecture/eShopOnWeb).</span></span>

```csharp
// https://github.com/dotnet-architecture/eShopOnWeb
public interface ISpecification<T>
{
    Expression<Func<T, bool>> Criteria { get; }
    List<Expression<Func<T, object>>> Includes { get; }
    List<string> IncludeStrings { get; }
}
```

<span data-ttu-id="48e91-196">En las próximas secciones se explica cómo implementar el patrón de especificación con EF Core 2.x y cómo usarlo desde cualquier clase de repositorio.</span><span class="sxs-lookup"><span data-stu-id="48e91-196">The upcoming sections explain how to implement the specification pattern with EF Core 2.x and how to use it from any Repository class.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="48e91-197">El patrón de especificación es un patrón antiguo que se puede implementar de muchas maneras diferentes, como en los recursos adicionales siguientes.</span><span class="sxs-lookup"><span data-stu-id="48e91-197">The specification pattern is an old pattern that can be implemented in many different ways, as in the following additional resources.</span></span> <span data-ttu-id="48e91-198">Como un patrón o una idea, es bueno conocer los enfoques anteriores, pero tenga cuidado con las implementaciones anteriores que no aprovechan las funciones de lenguajes modernos como LINQ y las expresiones.</span><span class="sxs-lookup"><span data-stu-id="48e91-198">As a pattern/idea, older approaches are good to know, but beware of older implementations that are not taking advantage of modern language capabilities like Linq and expressions.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="48e91-199">Recursos adicionales</span><span class="sxs-lookup"><span data-stu-id="48e91-199">Additional resources</span></span>

### <a name="the-repository-pattern"></a><span data-ttu-id="48e91-200">El modelo de repositorio</span><span class="sxs-lookup"><span data-stu-id="48e91-200">The Repository pattern</span></span>

- <span data-ttu-id="48e91-201">**The Repository pattern (El modelo de repositorio)**
  [https://deviq.com/repository-pattern/](https://deviq.com/repository-pattern/)</span><span class="sxs-lookup"><span data-stu-id="48e91-201">**The Repository pattern**
[https://deviq.com/repository-pattern/](https://deviq.com/repository-pattern/)</span></span>

- <span data-ttu-id="48e91-202">**Edward Hieatt y Rob Mee. Repository pattern (Patrón de repositorio).**
  [_https://martinfowler.com/eaaCatalog/repository.html_](https://martinfowler.com/eaaCatalog/repository.html)</span><span class="sxs-lookup"><span data-stu-id="48e91-202">**Edward Hieatt and Rob Mee. Repository pattern.**
[_https://martinfowler.com/eaaCatalog/repository.html_](https://martinfowler.com/eaaCatalog/repository.html)</span></span>

- <span data-ttu-id="48e91-203">**The Repository pattern (El patrón de repositorio)**
  [_https://docs.microsoft.com/previous-versions/msp-n-p/ff649690(v=pandp.10)_](https://docs.microsoft.com/previous-versions/msp-n-p/ff649690(v=pandp.10))</span><span class="sxs-lookup"><span data-stu-id="48e91-203">**The Repository pattern**
[_https://docs.microsoft.com/previous-versions/msp-n-p/ff649690(v=pandp.10)_](https://docs.microsoft.com/previous-versions/msp-n-p/ff649690(v=pandp.10))</span></span>

- <span data-ttu-id="48e91-204">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software** (Diseño guiado por el dominio: abordar la complejidad en el corazón del software).</span><span class="sxs-lookup"><span data-stu-id="48e91-204">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="48e91-205">(Libro; incluye un debate sobre el patrón de repositorio) [_https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/_](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span><span class="sxs-lookup"><span data-stu-id="48e91-205">(Book; includes a discussion of the Repository pattern) [_https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/_](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span></span>

### <a name="unit-of-work-pattern"></a><span data-ttu-id="48e91-206">Patrón de unidades de trabajo</span><span class="sxs-lookup"><span data-stu-id="48e91-206">Unit of Work pattern</span></span>

- <span data-ttu-id="48e91-207">**Martin Fowler. Unit of Work pattern (Patrón de unidades de trabajo).**
  [_https://martinfowler.com/eaaCatalog/unitOfWork.html_](https://martinfowler.com/eaaCatalog/unitOfWork.html)</span><span class="sxs-lookup"><span data-stu-id="48e91-207">**Martin Fowler. Unit of Work pattern.**
[_https://martinfowler.com/eaaCatalog/unitOfWork.html_](https://martinfowler.com/eaaCatalog/unitOfWork.html)</span></span>

- <span data-ttu-id="48e91-208">**Implementing the Repository and Unit of Work Patterns in an ASP.NET MVC Application**
  [_https://docs.microsoft.com/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application_](https://docs.microsoft.com/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application) (Implementación de los patrones de repositorio y unidad de trabajo en una aplicación MVC de ASP.NET)</span><span class="sxs-lookup"><span data-stu-id="48e91-208">**Implementing the Repository and Unit of Work Patterns in an ASP.NET MVC Application**
[_https://docs.microsoft.com/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application_](https://docs.microsoft.com/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span></span>

### <a name="the-specification-pattern"></a><span data-ttu-id="48e91-209">El patrón de especificación</span><span class="sxs-lookup"><span data-stu-id="48e91-209">The Specification pattern</span></span>

- <span data-ttu-id="48e91-210">**The Specification pattern (Patrón de especificación).**
  [_https://deviq.com/specification-pattern/_](https://deviq.com/specification-pattern/)</span><span class="sxs-lookup"><span data-stu-id="48e91-210">**The Specification pattern.**
[_https://deviq.com/specification-pattern/_](https://deviq.com/specification-pattern/)</span></span>

- <span data-ttu-id="48e91-211">**Evans, Eric (2004). Domain Driven Design (Diseño controlado por dominios). Addison-Wesley. p. 224.**</span><span class="sxs-lookup"><span data-stu-id="48e91-211">**Evans, Eric (2004). Domain Driven Design. Addison-Wesley. p. 224.**</span></span>

- <span data-ttu-id="48e91-212">**Specifications (Especificaciones). Martin Fowler**
  [_https://www.martinfowler.com/apsupp/spec.pdf/_](https://www.martinfowler.com/apsupp/spec.pdf)</span><span class="sxs-lookup"><span data-stu-id="48e91-212">**Specifications. Martin Fowler**
[_https://www.martinfowler.com/apsupp/spec.pdf/_](https://www.martinfowler.com/apsupp/spec.pdf)</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="48e91-213">[Anterior](domain-events-design-implementation.md)
[Siguiente](infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span><span class="sxs-lookup"><span data-stu-id="48e91-213">[Previous](domain-events-design-implementation.md)
[Next](infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span></span>
