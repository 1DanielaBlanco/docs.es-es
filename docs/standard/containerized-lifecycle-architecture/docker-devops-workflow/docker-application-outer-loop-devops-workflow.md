---
title: "Pasos del flujo de trabajo de DevOps de bucle externo para una aplicación de Docker"
description: Ciclo de vida de aplicaciones de Docker en contenedor con la plataforma y las herramientas de Microsoft
keywords: Docker, microservicios, ASP.NET, contenedor
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 09/22/2017
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: fe51fc4b5026d17f0f9b93e7fd0dedde93ef4a3c
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 12/23/2017
---
# <a name="steps-in-the-outer-loop-devops-workflow-for-a-docker-application"></a><span data-ttu-id="a9737-104">Pasos del flujo de trabajo de DevOps de bucle externo para una aplicación de Docker</span><span class="sxs-lookup"><span data-stu-id="a9737-104">Steps in the outer-loop DevOps workflow for a Docker application</span></span>

<span data-ttu-id="a9737-105">Figura 5-1 presenta una representación to-end de los pasos que componen el flujo de trabajo de DevOps bucle exterior.</span><span class="sxs-lookup"><span data-stu-id="a9737-105">Figure 5-1 presents an end-to-end depiction of the steps comprising the DevOps outer-loop workflow.</span></span>

![](./media/image1.png)

<span data-ttu-id="a9737-106">Figura 5-1: flujo de trabajo de DevOps bucle externo para las aplicaciones de Docker con herramientas de Microsoft</span><span class="sxs-lookup"><span data-stu-id="a9737-106">Figure 5-1: DevOps outer-loop workflow for Docker applications with Microsoft tools</span></span>

<span data-ttu-id="a9737-107">Ahora, examinemos cada uno de estos pasos con más detalle.</span><span class="sxs-lookup"><span data-stu-id="a9737-107">Now, let's examine each of these steps in greater detail.</span></span>

## <a name="step-1-inner-loop-development-workflow"></a><span data-ttu-id="a9737-108">Paso 1: Flujo de trabajo de desarrollo de bucle interno</span><span class="sxs-lookup"><span data-stu-id="a9737-108">Step 1: Inner-loop development workflow</span></span>

<span data-ttu-id="a9737-109">Este paso se explica con detalle en el capítulo 4, pero, en resumen, aquí es donde empieza el bucle exterior, el momento en que un desarrollador inserta código en el sistema de administración de control de código fuente (por ejemplo, Git) iniciar acciones de canalización de elemento de configuración.</span><span class="sxs-lookup"><span data-stu-id="a9737-109">This step is explained in detail in Chapter 4, but, to recap, here is where the outer-loop begins, the moment at which a developer pushes code to the source control management system (like Git) initiating CI pipeline actions.</span></span>

## <a name="step-2-source-code-control-integration-and-management-with-visual-studio-team-services-and-git"></a><span data-ttu-id="a9737-110">Paso 2: Integración de Control de código fuente y la administración con Visual Studio Team Services y Git</span><span class="sxs-lookup"><span data-stu-id="a9737-110">Step 2: Source-Code Control integration and management with Visual Studio Team Services and Git</span></span>

<span data-ttu-id="a9737-111">En este paso, debe tener un sistema de control de versiones para recopilar una versión consolidada de todo el código procedente de los desarrolladores diferentes en el equipo.</span><span class="sxs-lookup"><span data-stu-id="a9737-111">At this step, you need to have a version-control system to gather a consolidated version of all the code coming from the different developers in the team.</span></span>

<span data-ttu-id="a9737-112">Aunque el control de código fuente (SCC) y la administración de código fuente pueden parecer rutinario desplazarse a la mayoría de los desarrolladores, al crear aplicaciones de Docker en una vida DevOps, es fundamental para destacar que no se debe enviar las imágenes de Docker con la aplicación directamente en el registro de Docker de global (como registro de contenedor de Azure o Docker Hub) desde el equipo del desarrollador.</span><span class="sxs-lookup"><span data-stu-id="a9737-112">Even though source-code control (SCC) and source-code management might seem second-nature to most developers, when creating Docker applications in a DevOps life cycle, it is critical to emphasize that you must not submit the Docker images with the application directly to the global Docker Registry (like Azure Container Registry or Docker Hub) from the developer's machine.</span></span> <span data-ttu-id="a9737-113">Por el contrario, las imágenes de Docker se libera y se implementan en entornos de producción deben crearse únicamente en el código fuente que se integra en la compilación global o la canalización de elemento de configuración basado en el repositorio de código fuente (por ejemplo, Git).</span><span class="sxs-lookup"><span data-stu-id="a9737-113">On the contrary, the Docker images to be released and deployed to production environments must be created solely on the source code that is being integrated in your global build or CI pipeline based on your source-code repository (like Git).</span></span>

<span data-ttu-id="a9737-114">Las imágenes locales generadas por los desarrolladores a sí mismos deben utilizarse solo por los desarrolladores al probar dentro de sus propios equipos.</span><span class="sxs-lookup"><span data-stu-id="a9737-114">The local images generated by the developers themselves should be used just by the developers when testing within their own machines.</span></span> <span data-ttu-id="a9737-115">Este es el motivo por el que es fundamental que la canalización de DevOps activa desde el código de control de código fuente.</span><span class="sxs-lookup"><span data-stu-id="a9737-115">This is why it is critical to have the DevOps pipeline activated from the SCC code.</span></span>

<span data-ttu-id="a9737-116">Visual Studio Team Services y Team Foundation Server admiten Git y Control de versiones de Team Foundation.</span><span class="sxs-lookup"><span data-stu-id="a9737-116">Visual Studio Team Services and Team Foundation Server support Git and Team Foundation Version Control.</span></span> <span data-ttu-id="a9737-117">Puede elegir entre ellos y usarlo para obtener una experiencia de Microsoft-to-end.</span><span class="sxs-lookup"><span data-stu-id="a9737-117">You can choose between them and use it for an end-to-end Microsoft experience.</span></span> <span data-ttu-id="a9737-118">Sin embargo, también puede administrar el código en repositorios externos (por ejemplo, GitHub, repositorios de Git local o secundaria) y seguir siendo capaces de conectarse a él y obtener el código como punto de partida de la canalización de CI de DevOps.</span><span class="sxs-lookup"><span data-stu-id="a9737-118">However, you also can manage your code in external repositories (like GitHub, on-premises Git repositories, or Subversion) and still be able to connect to it and get the code as the starting point for your DevOps CI pipeline.</span></span>

## <a name="step-3-build-ci-integrate-and-test-with-visual-studio-team-services-and-docker"></a><span data-ttu-id="a9737-119">Paso 3: Compilación, CI, integrar y probar con Visual Studio Team Services y Docker</span><span class="sxs-lookup"><span data-stu-id="a9737-119">Step 3: Build, CI, Integrate, and Test with Visual Studio Team Services and Docker</span></span>

<span data-ttu-id="a9737-120">Elemento de configuración ha surgido como un estándar para las pruebas de software moderno y entrega.</span><span class="sxs-lookup"><span data-stu-id="a9737-120">CI has emerged as a standard for modern software testing and delivery.</span></span> <span data-ttu-id="a9737-121">La solución de Docker mantiene una separación clara de intereses entre los equipos de desarrollo y las operaciones.</span><span class="sxs-lookup"><span data-stu-id="a9737-121">The Docker solution maintains a clear separation of concerns between the development and operations teams.</span></span> <span data-ttu-id="a9737-122">La inmutabilidad de imágenes de Docker garantiza una implementación repetible entre lo que ha desarrollado, probado a través de los elementos de configuración y ejecutadas en producción.</span><span class="sxs-lookup"><span data-stu-id="a9737-122">The immutability of Docker images ensures a repeatable deployment between what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="a9737-123">Motor de docker se implementa en los equipos portátiles de desarrollador e infraestructura de prueba hace que los contenedores portátil a través de entornos.</span><span class="sxs-lookup"><span data-stu-id="a9737-123">Docker Engine deployed across the developer laptops and test infrastructure makes the containers portable across environments.</span></span>

<span data-ttu-id="a9737-124">En este momento, una vez que un sistema de control de versiones con el código correcto enviado, necesita un *crear servicio* para recoger el código y ejecutar la compilación global y las pruebas.</span><span class="sxs-lookup"><span data-stu-id="a9737-124">At this point, after you have a version-control system with the correct code submitted, you need a *build service* to pick up the code and run the global build and tests.</span></span>

<span data-ttu-id="a9737-125">El flujo de trabajo interno para este paso (elemento de configuración, compilación, prueba) consiste en la construcción de una canalización de elemento de configuración que consta de su repositorio de código (Git, etc.), el servidor de compilación (Visual Studio Team Services), el motor de Docker y un registro de Docker.</span><span class="sxs-lookup"><span data-stu-id="a9737-125">The internal workflow for this step (CI, build, test) is about the construction of a CI pipeline consisting of your code repository (Git, etc.), your build server (Visual Studio Team Services), Docker Engine, and a Docker Registry.</span></span>

<span data-ttu-id="a9737-126">Puede usar Visual Studio Team Services como base para compilar las aplicaciones y la configuración de la canalización de elemento de configuración y para publicar los integrada "artefactos" a un "repositorio de artefactos", que se explica en el paso siguiente.</span><span class="sxs-lookup"><span data-stu-id="a9737-126">You can use Visual Studio Team Services as the foundation for building your applications and setting your CI pipeline, and for publishing the built "artifacts" to an "artifacts repository," which is explained in the next step.</span></span>

<span data-ttu-id="a9737-127">Al usar Docker para la implementación, los "artefactos finales" para implementar imágenes de Docker con sus aplicaciones o servicios incrustadas dentro de ellos.</span><span class="sxs-lookup"><span data-stu-id="a9737-127">When using Docker for the deployment, the "final artifacts" to be deployed are Docker images with your application or services embedded within them.</span></span> <span data-ttu-id="a9737-128">Las imágenes se insertan o se publican en un *Docker registro* (un repositorio privado como los que puede tener en el registro de contenedor de Azure o una pública como registro de Docker Hub, que se utiliza normalmente para las imágenes base oficiales).</span><span class="sxs-lookup"><span data-stu-id="a9737-128">Those images are pushed or published to a *Docker Registry* (a private repository like the ones you can have in Azure Container Registry, or a public one like Docker Hub Registry, which is commonly used for official base images).</span></span>

<span data-ttu-id="a9737-129">Este es el concepto básico: elementos de configuración de la canalización será iniciado desactivada por una confirmación a un repositorio de control de código fuente como Git.</span><span class="sxs-lookup"><span data-stu-id="a9737-129">Here is the basic concept: The CI pipeline will be kicked-off by a commit to an SCC repository like Git.</span></span> <span data-ttu-id="a9737-130">La confirmación hará que Visual Studio Team Services ejecutar un trabajo de compilación dentro de un contenedor de Docker y, en la realización correcta de ese trabajo, insertar una imagen de Docker en el registro de Docker, como se muestra en la figura 5-2.</span><span class="sxs-lookup"><span data-stu-id="a9737-130">The commit will cause Visual Studio Team Services to run a build job within a Docker container and, upon successful completion of that job, push a Docker image to the Docker Registry, as illustrated in Figure 5-2.</span></span>

![](./media/image2.png)

<span data-ttu-id="a9737-131">Figura 5-2: los pasos necesarios para el elemento de configuración</span><span class="sxs-lookup"><span data-stu-id="a9737-131">Figure 5-2: The steps involved in CI</span></span>

<span data-ttu-id="a9737-132">Estos son los pasos de flujo de trabajo de elementos de configuración básicos con Docker y Visual Studio Team Services:</span><span class="sxs-lookup"><span data-stu-id="a9737-132">Here are the basic CI workflow steps with Docker and Visual Studio Team Services:</span></span>

1.  <span data-ttu-id="a9737-133">El desarrollador inserta una confirmación a un repositorio de control de código fuente (Git o Visual Studio Team Services, GitHub, etcetera).</span><span class="sxs-lookup"><span data-stu-id="a9737-133">The developer pushes a commit to an SCC repository (Git/Visual Studio Team Services, GitHub, etc.).</span></span>

2.  <span data-ttu-id="a9737-134">Si usa Visual Studio Team Services o Git, CI está integrada, lo que significa que es tan sencilla como activar una casilla de verificación en Visual Studio Team Services.</span><span class="sxs-lookup"><span data-stu-id="a9737-134">If you're using Visual Studio Team Services or Git, CI is built in, which means that it is as simple as selecting a check box in Visual Studio Team Services.</span></span> <span data-ttu-id="a9737-135">Si usas un SCC externo (por ejemplo, GitHub), un *webhook* va a notificar a Visual Studio Team Services de la actualización o inserción en Git y GitHub.</span><span class="sxs-lookup"><span data-stu-id="a9737-135">If you're using an external SCC (like GitHub), a *webhook* will notify Visual Studio Team Services of the update or push to Git/GitHub.</span></span>

3.  <span data-ttu-id="a9737-136">Visual Studio Team Services extrae el repositorio de control de código fuente, incluidos el DockerFile que describen la imagen, así como el código de aplicación y prueba.</span><span class="sxs-lookup"><span data-stu-id="a9737-136">Visual Studio Team Services pulls the SCC repository, including the DockerFile describing the image as well as the application and test code.</span></span>

4.  <span data-ttu-id="a9737-137">Visual Studio Team Services genera una imagen de Docker y etiquetas con un número de compilación.</span><span class="sxs-lookup"><span data-stu-id="a9737-137">Visual Studio Team Services builds a Docker image and labels it with a build number.</span></span>

5.  <span data-ttu-id="a9737-138">Visual Studio Team Services crea el contenedor de Docker en el Host Docker aprovisionado y ejecuta las pruebas adecuadas.</span><span class="sxs-lookup"><span data-stu-id="a9737-138">Visual Studio Team Services instantiates the Docker container within the provisioned Docker Host, and runs the appropriate tests.</span></span>

6.  <span data-ttu-id="a9737-139">Si las pruebas son correctas, la imagen se primero vuelve a etiquetar a un nombre descriptivo para que sepa que es una "compilación designada" (como "/ 1.0.0" o cualquier otra etiqueta) y, a continuación, inserta en el registro de Docker (Docker Hub, registro de contenedor de Azure, DTR, etcetera.)</span><span class="sxs-lookup"><span data-stu-id="a9737-139">If the tests are successful, the image is first relabeled to a meaningful name so that you know it is a "blessed build" (like "/1.0.0" or any other label), and then pushed up to your Docker Registry (Docker Hub, Azure Container Registry, DTR, etc.)</span></span>

### <a name="implementing-the-ci-pipeline-with-visual-studio-team-services-and-the-docker-extension-for-visual-studio-team-services"></a><span data-ttu-id="a9737-140">Implementar la canalización de integración continua con Visual Studio Team Services y la extensión Docker para Visual Studio Team Services</span><span class="sxs-lookup"><span data-stu-id="a9737-140">Implementing the CI pipeline with Visual Studio Team Services and the Docker extension for Visual Studio Team Services</span></span>

<span data-ttu-id="a9737-141">El [extensión de Visual Studio Team Services Docker](https://aka.ms/vstsdockerextension) agrega una tarea a la canalización de elemento de configuración con el que puede crear imágenes de Docker, insertar imágenes de Docker en un registro de Docker autenticado, ejecutar imágenes de Docker o ejecutar otras operaciones que ofrece el CLI de docker.</span><span class="sxs-lookup"><span data-stu-id="a9737-141">The [Visual Studio Team Services Docker extension](https://aka.ms/vstsdockerextension) adds a task to your CI pipeline with which you can build Docker images, push Docker images to an authenticated Docker registry, run Docker images, or run other operations offered by the Docker CLI.</span></span> <span data-ttu-id="a9737-142">También agrega una tarea Docker Compose que puede usar para crear, insertar y ejecutar aplicaciones de Docker multicontainer o ejecutar otras operaciones que ofrece la CLI de redacción de Docker, tal como se muestra en la figura 5-3.</span><span class="sxs-lookup"><span data-stu-id="a9737-142">It also adds a Docker Compose task that you can use to build, push, and run multicontainer Docker applications, or run other operations offered by the Docker Compose CLI, as shown in Figure 5-3.</span></span>

![](./media/image3.png)

<span data-ttu-id="a9737-143">Figura 5-3: la canalización de elemento de configuración de Docker en Visual Studio Team Services</span><span class="sxs-lookup"><span data-stu-id="a9737-143">Figure 5-3: The Docker CI pipeline in Visual Studio Team Services</span></span>

<span data-ttu-id="a9737-144">La extensión Docker puede usar los puntos de conexión de servicio para los hosts de Docker y de contenedor o registros de la imagen.</span><span class="sxs-lookup"><span data-stu-id="a9737-144">The Docker extension can use service endpoints for Docker hosts and for container or image registries.</span></span> <span data-ttu-id="a9737-145">El valor predeterminado de tareas para utilizar un host Docker local si está disponible (Esto requiere actualmente un agente de Visual Studio Team Services personalizado); en caso contrario, requiere que se proporcione una conexión a host Docker.</span><span class="sxs-lookup"><span data-stu-id="a9737-145">The tasks default to using a local Docker host if available (this currently requires a custom Visual Studio Team Services agent); otherwise, they require that you provide a Docker host connection.</span></span> <span data-ttu-id="a9737-146">Las acciones que dependen de que se va a autenticar con un registro de Docker, como la inserción de una imagen, requieren que se proporcione a una Docker conexión del registro.</span><span class="sxs-lookup"><span data-stu-id="a9737-146">Actions that depend on being authenticated with a Docker registry, such as pushing an image, require that you provide a Docker registry connection.</span></span>

<span data-ttu-id="a9737-147">La extensión de Visual Studio Team Services Docker instala los componentes siguientes en su cuenta de Visual Studio Team Services:</span><span class="sxs-lookup"><span data-stu-id="a9737-147">The Visual Studio Team Services Docker extension installs the following components in your Visual Studio Team Services account:</span></span>

-   <span data-ttu-id="a9737-148">Un extremo de servicio para conectarse a un registro de Docker</span><span class="sxs-lookup"><span data-stu-id="a9737-148">A service endpoint for connecting to a Docker registry</span></span>

-   <span data-ttu-id="a9737-149">Un extremo de servicio para conectarse a un Host de contenedor de Docker</span><span class="sxs-lookup"><span data-stu-id="a9737-149">A service endpoint for connecting to a Docker Container Host</span></span>

-   <span data-ttu-id="a9737-150">Una tarea de Docker para hacer lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="a9737-150">A Docker task to do the following:</span></span>

-   <span data-ttu-id="a9737-151">Crear una imagen</span><span class="sxs-lookup"><span data-stu-id="a9737-151">Build an image</span></span>

-   <span data-ttu-id="a9737-152">Insertar una imagen o un repositorio para un registro</span><span class="sxs-lookup"><span data-stu-id="a9737-152">Push an image or a repository to a registry</span></span>

-   <span data-ttu-id="a9737-153">Ejecutar una imagen en un contenedor</span><span class="sxs-lookup"><span data-stu-id="a9737-153">Run an image in a container</span></span>

-   <span data-ttu-id="a9737-154">Ejecutar un comando de Docker</span><span class="sxs-lookup"><span data-stu-id="a9737-154">Run a Docker command</span></span>

-   <span data-ttu-id="a9737-155">Una tarea para ejecutar un comando Docker Compose Docker Compose</span><span class="sxs-lookup"><span data-stu-id="a9737-155">A Docker Compose task to run a Docker Compose command</span></span>

<span data-ttu-id="a9737-156">Con estas tareas de Visual Studio Team Services, una compilación de Docker de Linux/máquina virtual de Host aprovisionado en Azure y el registro de Docker preferido (registro de contenedor de Azure, Docker Hub, privada DTR de Docker o cualquier otro registro de Docker) puede ensamblar la canalización de elemento de configuración de Docker en un forma muy coherente.</span><span class="sxs-lookup"><span data-stu-id="a9737-156">With these Visual Studio Team Services tasks, a build Linux-Docker Host/VM provisioned in Azure and your preferred Docker registry (Azure Container Registry, Docker Hub, private Docker DTR, or any other Docker registry) you can assemble your Docker CI pipeline in a very consistent way.</span></span>

<span data-ttu-id="a9737-157">***Requisitos:***</span><span class="sxs-lookup"><span data-stu-id="a9737-157">***Requirements:***</span></span>

-   <span data-ttu-id="a9737-158">Visual Studio Team Services, o para las instalaciones locales, Team Foundation Server 2015 Update 3 o posterior.</span><span class="sxs-lookup"><span data-stu-id="a9737-158">Visual Studio Team Services, or for on-premises installations, Team Foundation Server 2015 Update 3 or later.</span></span>

-   <span data-ttu-id="a9737-159">Un agente de Visual Studio Team Services que contenga los archivos binarios de Docker.</span><span class="sxs-lookup"><span data-stu-id="a9737-159">A Visual Studio Team Services agent that has the Docker binaries.</span></span>

<span data-ttu-id="a9737-160">Una manera fácil de crear una de ellas es usar Docker para ejecutar un contenedor en función de la imagen de Docker de agente de Visual Studio Team Services.</span><span class="sxs-lookup"><span data-stu-id="a9737-160">An easy way to create one of these is to use Docker to run a container based on the Visual Studio Team Services agent Docker image.</span></span>

<span data-ttu-id="a9737-161">**Obtener más información** para leer más acerca de cómo ensamblar un CI de Visual Studio Team Services Docker de canalización y para ver los tutoriales, visiten los siguientes sitios:</span><span class="sxs-lookup"><span data-stu-id="a9737-161">**More info** To read more about assembling a Visual Studio Team Services Docker CI pipeline and to view walkthroughs, visit the following sites:</span></span>

<span data-ttu-id="a9737-162">Ejecuta un agente de Visual Studio Team Services como un contenedor de Docker: [https://hub.docker.com/r/ \ vsts-agente/microsoft /](https://hub.docker.com/r/microsoft/vsts-agent/)</span><span class="sxs-lookup"><span data-stu-id="a9737-162">Running a Visual Studio Team Services agent as a Docker container: [https://hub.docker.com/r/\ microsoft/vsts-agent/](https://hub.docker.com/r/microsoft/vsts-agent/)</span></span>

<span data-ttu-id="a9737-163">Extensión de VSTS Docker: <https://aka.ms/vstsdockerextension></span><span class="sxs-lookup"><span data-stu-id="a9737-163">VSTS Docker extension: <https://aka.ms/vstsdockerextension></span></span>

<span data-ttu-id="a9737-164">Crear imágenes de .NET Core Linux Docker con Visual Studio Team Services: <https://blogs.msdn.microsoft.com/stevelasker/2016/06/13/building-net-core-linux-docker-images-with-visual-studio-team-services/></span><span class="sxs-lookup"><span data-stu-id="a9737-164">Building .NET Core Linux Docker images with Visual Studio Team Services: <https://blogs.msdn.microsoft.com/stevelasker/2016/06/13/building-net-core-linux-docker-images-with-visual-studio-team-services/></span></span>

<span data-ttu-id="a9737-165">Creación de un servicio de equipo basado en Linux, Visual Studio crea la máquina con el soporte técnico de Docker: <http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support></span><span class="sxs-lookup"><span data-stu-id="a9737-165">Building a Linux-based Visual Studio Team Service build machine with Docker support: <http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support></span></span>

### <a name="integrate-test-and-validate-multicontainer-docker-applications"></a><span data-ttu-id="a9737-166">Integrar, probar y validar las aplicaciones de Docker multicontainer</span><span class="sxs-lookup"><span data-stu-id="a9737-166">Integrate, test, and validate multicontainer Docker applications</span></span>

<span data-ttu-id="a9737-167">Normalmente, la mayoría de las aplicaciones de Docker se compone de varios contenedores en lugar de un único contenedor.</span><span class="sxs-lookup"><span data-stu-id="a9737-167">Typically, most Docker applications are composed of multiple containers rather than a single container.</span></span> <span data-ttu-id="a9737-168">Un buen ejemplo es una aplicación orientada a servicios de microservicios para el que tendría un contenedor por microservicio.</span><span class="sxs-lookup"><span data-stu-id="a9737-168">A good example is a microservices-oriented application for which you would have one container per microservice.</span></span> <span data-ttu-id="a9737-169">Sin embargo, incluso sin seguir estrictamente los patrones de enfoque microservicios, es muy probable que la aplicación de Docker podría estar compuesta de varios contenedores o servicios.</span><span class="sxs-lookup"><span data-stu-id="a9737-169">But, even without strictly following the microservices approach patterns, it is very probable that your Docker application would be composed of multiple containers or services.</span></span>

<span data-ttu-id="a9737-170">Por lo tanto, después de compilar los contenedores de la aplicación en la canalización de elemento de configuración, también debe implementar, integrar y probar la aplicación como un todo con todos sus contenedores dentro de un host de Docker de integración o incluso en un clúster de prueba a los que son los contenedores distribuir.</span><span class="sxs-lookup"><span data-stu-id="a9737-170">Therefore, after building the application containers in the CI pipeline, you also need to deploy, integrate, and test the application as a whole with all of its containers within an integration Docker host or even into a test cluster to which your containers are distributed.</span></span>

<span data-ttu-id="a9737-171">Si usa un solo host, puede utilizar comandos de Docker como docker-crear para generar e implementar contenedores relacionados para probar y validar el entorno de Docker en una sola máquina virtual.</span><span class="sxs-lookup"><span data-stu-id="a9737-171">If you're using a single host, you can use Docker commands such as docker-compose to build and deploy related containers to test and validate the Docker environment in a single VM.</span></span> <span data-ttu-id="a9737-172">Sin embargo, si está trabajando con un clúster de orchestrator como controlador de dominio/OS, Kubernetes o Docker Swarm, debe implementar los contenedores mediante un mecanismo diferente o orchestrator, dependiendo de su programador/clúster seleccionado.</span><span class="sxs-lookup"><span data-stu-id="a9737-172">But, if you are working with an orchestrator cluster like DC/OS, Kubernetes, or Docker Swarm, you need to deploy your containers through a different mechanism or orchestrator, depending on your selected cluster/scheduler.</span></span>

<span data-ttu-id="a9737-173">Estos son varios tipos de pruebas que pueden ejecutar en contenedores de Docker:</span><span class="sxs-lookup"><span data-stu-id="a9737-173">Following are several types of tests that you can run against Docker containers:</span></span>

-   <span data-ttu-id="a9737-174">Pruebas unitarias para contenedores de Docker</span><span class="sxs-lookup"><span data-stu-id="a9737-174">Unit tests for Docker containers</span></span>

-   <span data-ttu-id="a9737-175">Grupos de prueba de aplicaciones interrelacionadas o microservicios</span><span class="sxs-lookup"><span data-stu-id="a9737-175">Testing groups of interrelated applications or microservices</span></span>

-   <span data-ttu-id="a9737-176">En las versiones "Canarias" y de producción de prueba</span><span class="sxs-lookup"><span data-stu-id="a9737-176">Test in production and "canary" releases</span></span>

<span data-ttu-id="a9737-177">Lo importante es que cuando se ejecuta integración y pruebas funcionales, debe ejecutar las pruebas desde fuera de los contenedores.</span><span class="sxs-lookup"><span data-stu-id="a9737-177">The important point is that when running integration and functional tests, you must run those tests from outside of the containers.</span></span> <span data-ttu-id="a9737-178">Pruebas no deben definirse y ejecutar dentro de los contenedores que se va a implementar, porque los contenedores se basan en las imágenes estáticas que deben ser exactamente iguales a los que va a implementar en producción.</span><span class="sxs-lookup"><span data-stu-id="a9737-178">Tests must not be defined and run within the containers that you are deploying, because the containers are based on static images that should be exactly like those that you will be deploying into production.</span></span>

<span data-ttu-id="a9737-179">Es una opción muy factible al probar los escenarios más avanzados como pruebas para varios clústeres (probar clúster, clúster de ensayo y producción clúster) publicar las imágenes a un registro para probar en varios clústeres.</span><span class="sxs-lookup"><span data-stu-id="a9737-179">A very feasible option when testing more advanced scenarios like testing several clusters (test cluster, staging cluster, and production cluster) is to publish the images to a registry to test in various clusters.</span></span>

### <a name="push-the-custom-application-docker-image-into-your-global-docker-registry"></a><span data-ttu-id="a9737-180">Insertar la imagen de Docker de aplicación personalizada en el registro de Docker global</span><span class="sxs-lookup"><span data-stu-id="a9737-180">Push the custom application Docker image into your global Docker Registry</span></span>

<span data-ttu-id="a9737-181">Una vez probadas y validar las imágenes de Docker, desea etiquetar y publíquelos en el registro de Docker.</span><span class="sxs-lookup"><span data-stu-id="a9737-181">After the Docker images have been tested and validated, you'll want to tag and publish them to your Docker registry.</span></span> <span data-ttu-id="a9737-182">El registro de Docker es una pieza fundamental en el ciclo de vida de la aplicación de Docker porque es la ubicación central donde se almacenan sus pruebas personalizadas (también conocido como "designadas imágenes") para implementarse en entornos de producción y preguntas y respuestas.</span><span class="sxs-lookup"><span data-stu-id="a9737-182">The Docker registry is a critical piece in the Docker application life cycle because it is the central place where you store your custom test (aka "blessed images") to be deployed into QA and production environments.</span></span>

<span data-ttu-id="a9737-183">De forma similar a cómo el código de aplicación almacenado en el repositorio de control de código fuente (Git, etc.) es el "origen de verdad", el registro de Docker es su "origen de verdad" para su aplicación binaria o bits para su implementación en los entornos de producción o de preguntas y respuestas.</span><span class="sxs-lookup"><span data-stu-id="a9737-183">Similar to how the application code stored in your SCC repository (Git, etc.) is your "source of truth," the Docker registry is your "source of truth" for your binary application or bits to be deployed to the QA or production environments.</span></span>

<span data-ttu-id="a9737-184">Normalmente, desea tener sus repositorios privadas para las imágenes personalizadas en un repositorio privado en el registro de contenedor de Azure o en un registro local como registro de confianza de Docker o en un registro de la nube pública con acceso restringido (por ejemplo Docker Hub), aunque en este último caso, si el código no está abierto, debe confiar en seguridad del proveedor.</span><span class="sxs-lookup"><span data-stu-id="a9737-184">Typically, you might want to have your private repositories for your custom images either in a private repository in Azure Container Registry or in an on-premises registry like Docker Trusted Registry, or in a public-cloud registry with restricted access (like Docker Hub), although in this last case if your code is not open source, you must trust the vendor's security.</span></span> <span data-ttu-id="a9737-185">En cualquier caso, el método por el que hacer esto es bastante similar y en última instancia en función del comando de inserción de docker, como se muestra en la figura 5-4.</span><span class="sxs-lookup"><span data-stu-id="a9737-185">Either way, the method by which you do this is pretty similar and ultimately based on the docker push command, as depicted in Figure 5-4.</span></span>

![](./media/image4.png)

<span data-ttu-id="a9737-186">Figura 5-4: publicar imágenes personalizadas en el registro de Docker</span><span class="sxs-lookup"><span data-stu-id="a9737-186">Figure 5-4: Publishing custom images to Docker Registry</span></span>

<span data-ttu-id="a9737-187">Hay varias ofertas de los registros de Docker de proveedores de nube como registro de contenedor de Azure, registro de contenedor de Amazon Web Services, registro de contenedor de Google, del registro del muelle y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a9737-187">There are multiple offerings of Docker registries from cloud vendors like Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay Registry, and so on.</span></span>

<span data-ttu-id="a9737-188">Utilice la extensión de Visual Studio Team Services Docker, puede insertar un conjunto de imágenes de servicio definido por un archivo de compose.yml de docker, con varias etiquetas, en un registro de Docker autenticado (por ejemplo, registro de contenedor de Azure), tal como se muestra en la figura 5-5.</span><span class="sxs-lookup"><span data-stu-id="a9737-188">Using the Visual Studio Team Services Docker extension, you can push a set of service images defined by a docker-compose.yml file, with multiple tags, to an authenticated Docker registry (like Azure Container Registry), as shown in Figure 5-5.</span></span>

![](./media/image5.png)

<span data-ttu-id="a9737-189">Figura 5-5: usar Visual Studio Team Services para publicación imágenes personalizadas a un registro de Docker</span><span class="sxs-lookup"><span data-stu-id="a9737-189">Figure 5-5: Using Visual Studio Team Services to publishing custom images to a Docker Registry</span></span>

<span data-ttu-id="a9737-190">**Obtener más información** para obtener más acerca de la extensión Docker para Visual Studio Team Services, vaya a <https://aka.ms/vstsdockerextension>.</span><span class="sxs-lookup"><span data-stu-id="a9737-190">**More info** To read more about the Docker extension for Visual Studio Team Services, go to <https://aka.ms/vstsdockerextension>.</span></span> <span data-ttu-id="a9737-191">Para obtener más información acerca del registro de contenedor de Azure, vaya a <https://aka.ms/azurecontainerregistry>.</span><span class="sxs-lookup"><span data-stu-id="a9737-191">To learn more about Azure Container Registry, go to <https://aka.ms/azurecontainerregistry>.</span></span>

## <a name="step-4-cd-deploy"></a><span data-ttu-id="a9737-192">Paso 4: CD, implementar</span><span class="sxs-lookup"><span data-stu-id="a9737-192">Step 4: CD, Deploy</span></span>

<span data-ttu-id="a9737-193">La inmutabilidad de imágenes de Docker garantiza una implementación repetible con lo que ha desarrollado, probado a través de los elementos de configuración y ejecutadas en producción.</span><span class="sxs-lookup"><span data-stu-id="a9737-193">The immutability of Docker images ensures a repeatable deployment with what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="a9737-194">Una vez que las imágenes de Docker de la aplicación publicadas en el registro de Docker (privado o público), se pueden implementar en varios entornos de los que es posible que tenga (producción, preguntas y respuestas, almacenamiento provisional, etc.) de la canalización de CD mediante el uso de Visual Studio Team Services tareas de canalización o Visual Studio Team Services Release Management.</span><span class="sxs-lookup"><span data-stu-id="a9737-194">After you have the application Docker images published in your Docker registry (either private or public), you can deploy them to the several environments that you might have (production, QA, staging, etc.) from your CD pipeline by using Visual Studio Team Services pipeline tasks or Visual Studio Team Services Release Management.</span></span>

<span data-ttu-id="a9737-195">Sin embargo, en este punto depende de qué tipo de aplicación de Docker que va a implementar.</span><span class="sxs-lookup"><span data-stu-id="a9737-195">However, at this point it depends on what kind of Docker application you are deploying.</span></span> <span data-ttu-id="a9737-196">Implementar una aplicación simple (de una composición y la implementación de punto de vista) como un monolítico que comprenden unos contenedores o servicios de aplicación e implementada a unos servidores o máquinas virtuales es muy diferente de la implementación de una aplicación más compleja como una aplicación orientada a microservicios con capacidades de hiperescalar.</span><span class="sxs-lookup"><span data-stu-id="a9737-196">Deploying a simple application (from a composition and deployment point of view) like a monolithic application comprising a few containers or services and deployed to a few servers or VMs is very different from deploying a more complex application like a microservices-oriented application with hyperscale capabilities.</span></span> <span data-ttu-id="a9737-197">Estos dos escenarios se explican en las secciones siguientes.</span><span class="sxs-lookup"><span data-stu-id="a9737-197">These two scenarios are explained in the following sections.</span></span>

### <a name="deploying-composed-docker-applications-to-multiple-docker-environments"></a><span data-ttu-id="a9737-198">Implementación compuesto por las aplicaciones de Docker para varios entornos de Docker</span><span class="sxs-lookup"><span data-stu-id="a9737-198">Deploying composed Docker applications to multiple Docker environments</span></span>

<span data-ttu-id="a9737-199">Echemos un vistazo primero en el escenario menos complejo: la implementación en hosts de Docker simples (máquinas virtuales o servidores) en un entorno único o en varios entornos (QA, ensayo y producción).</span><span class="sxs-lookup"><span data-stu-id="a9737-199">Let's look first at the less-complex scenario: deploying to simple Docker hosts (VMs or servers) in a single environment or multiple environments (QA, staging, and production).</span></span> <span data-ttu-id="a9737-200">En este escenario, la canalización de CD puede utilicen internamente docker-crear (de las tareas de implementación de Visual Studio Team Services) para implementar las aplicaciones de Docker con su conjunto relacionado de contenedores o servicios, como se muestra en la figura 5-6.</span><span class="sxs-lookup"><span data-stu-id="a9737-200">In this scenario, internally your CD pipeline can use docker-compose (from your Visual Studio Team Services deployment tasks) to deploy the Docker applications with its related set of containers or services, as illustrated in Figure 5-6.</span></span>

![](./media/image6.png)

<span data-ttu-id="a9737-201">Figura 5-6: implementar contenedores de aplicaciones en el registro de los entornos de host de Docker simple</span><span class="sxs-lookup"><span data-stu-id="a9737-201">Figure 5-6: Deploying application containers to simple Docker host environments registry</span></span>

<span data-ttu-id="a9737-202">Figura 5-7 se destaca cómo puede conectarse el elemento de configuración de compilación a los entornos de prueba/QA a través de Visual Studio Team Services, haga clic en Docker Compose en el cuadro de diálogo Agregar tarea.</span><span class="sxs-lookup"><span data-stu-id="a9737-202">Figure 5-7 highlights how you can connect your build CI to QA/test environments via Visual Studio Team Services by clicking Docker Compose in the Add Task dialog box.</span></span> <span data-ttu-id="a9737-203">Sin embargo, cuando se implementa en entornos de ensayo o de producción, normalmente usaría varios entornos de control de características de administración de versión (al igual que preguntas y respuestas, ensayo y producción).</span><span class="sxs-lookup"><span data-stu-id="a9737-203">However, when deploying to staging or production environments, you would usually use Release Management features handling multiple environments (like QA, staging, and production).</span></span> <span data-ttu-id="a9737-204">Si va a implementar en hosts de Docker únicos, que está usando Visual Studio Team Services tarea "Docker Compose" (que está invocando el docker-crear comando bajo el paraguas).</span><span class="sxs-lookup"><span data-stu-id="a9737-204">If you're deploying to single Docker hosts, it is using the Visual Studio Team Services "Docker Compose" task (which is invoking the docker-compose up command under the hood).</span></span> <span data-ttu-id="a9737-205">Si va a implementar en un servicio de contenedor de Azure, utiliza la tarea de implementación de Docker, como se explica en la sección siguiente.</span><span class="sxs-lookup"><span data-stu-id="a9737-205">If you're deploying to Azure Container Service, it uses the Docker Deployment task, as explained in the section that follows.</span></span>

![](./media/image7.png)

<span data-ttu-id="a9737-206">Figura 5-7: agregar una tarea de Docker Compose en una canalización de Visual Studio Team Services</span><span class="sxs-lookup"><span data-stu-id="a9737-206">Figure 5-7: Adding a Docker Compose task in a Visual Studio Team Services pipeline</span></span>

<span data-ttu-id="a9737-207">Cuando se crea una versión de Visual Studio Team Services, tiene un conjunto de artefactos de entrada.</span><span class="sxs-lookup"><span data-stu-id="a9737-207">When you create a release in Visual Studio Team Services, it takes a set of input artifacts.</span></span> <span data-ttu-id="a9737-208">Éstos están pensados para ser inmutable durante toda la duración de la versión en varios entornos.</span><span class="sxs-lookup"><span data-stu-id="a9737-208">These are intended to be immutable throughout the lifetime of the release across multiple environments.</span></span> <span data-ttu-id="a9737-209">Cuando se introducen contenedores, los artefactos de entrada identifican imágenes en un registro para implementar.</span><span class="sxs-lookup"><span data-stu-id="a9737-209">When you introduce containers, the input artifacts identify images in a registry to deploy.</span></span> <span data-ttu-id="a9737-210">Dependiendo de cómo se identifican, no se garantiza que siguen siendo los mismos a lo largo de la duración de la versión, el caso más obvio que se va a cuando se hace referencia "myimage:latest" desde un archivo docker-compose.</span><span class="sxs-lookup"><span data-stu-id="a9737-210">Depending on how these are identified, they are not guaranteed to remain the same throughout the duration of the release, the most obvious case being when you reference "myimage:latest" from a docker-compose file.</span></span>

<span data-ttu-id="a9737-211">La extensión Docker para Visual Studio Team Services proporciona resúmenes de la capacidad de generar los artefactos de compilación que contienen la imagen específica del registro que se garantiza para identificar de forma única la misma imagen binaria.</span><span class="sxs-lookup"><span data-stu-id="a9737-211">The Docker extension for Visual Studio Team Services gives you the ability to generate build artifacts that contain specific registry image digests that are guaranteed to uniquely identify the same image binary.</span></span> <span data-ttu-id="a9737-212">Se trata de lo que realmente desea utilizar como entrada para una versión.</span><span class="sxs-lookup"><span data-stu-id="a9737-212">These are what you really want to use as input to a release.</span></span>

### <a name="managing-releases-to-docker-environments-by-using-visual-studio-team-services-release-management"></a><span data-ttu-id="a9737-213">Administración de versiones para entornos de Docker mediante Visual Studio Team Services Release Management</span><span class="sxs-lookup"><span data-stu-id="a9737-213">Managing releases to Docker environments by using Visual Studio Team Services Release Management</span></span>

<span data-ttu-id="a9737-214">A través de las extensiones de Visual Studio Team Services, puede crear una nueva imagen, publicarlo en un registro de Docker, ejecutarla en hosts de Linux o Windows y utilizar comandos como docker-crear para implementar varios contenedores como una aplicación completa, todo ello a través del objeto Visual Capacidades de administración de versiones de Team Services Studio destinadas a varios entornos, como se muestra en la figura 5-8.</span><span class="sxs-lookup"><span data-stu-id="a9737-214">Through the Visual Studio Team Services extensions, you can build a new image, publish it to a Docker registry, run it on Linux or Windows hosts, and use commands such as docker-compose to deploy multiple containers as an entire application, all through the Visual Studio Team Services Release Management capabilities intended for multiple environments, as shown in Figure 5-8.</span></span>

![](./media/image8.png)

<span data-ttu-id="a9737-215">Figura 5-8: configurar tareas de Visual Studio Team Services Docker Compose desde Visual Studio Team Services Release Management</span><span class="sxs-lookup"><span data-stu-id="a9737-215">Figure 5-8: Configuring Visual Studio Team Services Docker Compose tasks from Visual Studio Team Services Release Management</span></span>

<span data-ttu-id="a9737-216">Sin embargo, tenga en cuenta que el escenario se muestra en la figura 5-6 y se implementa en la figura 5-8 es bastante básico (se está implementando en hosts de Docker simples y máquinas virtuales, y habrá un único contenedor o una instancia por imagen) y probablemente se debe usar solo para desarrollo o prueba sc Router.</span><span class="sxs-lookup"><span data-stu-id="a9737-216">However, keep in mind that the scenario shown in Figure 5-6 and implemented in Figure 5-8 is pretty basic (it is deploying to simple Docker hosts and VMs, and there will be a single container or instance per image) and probably should be used only for development or test scenarios.</span></span> <span data-ttu-id="a9737-217">En la mayoría de los escenarios de producción empresarial, desearía tener alta disponibilidad (HA) y fácil de administrar la escalabilidad mediante Equilibrio de carga entre varios nodos, servidores y las máquinas virtuales, además de "inteligente las conmutaciones por error" así que si un servidor o un nodo produce un error, sus servicios y los contenedores se moverán a otro servidor de host o máquina virtual.</span><span class="sxs-lookup"><span data-stu-id="a9737-217">In most enterprise production scenarios, you would want to have High Availability (HA) and easy-to-manage scalability by load balancing across multiple nodes, servers, and VMs, plus "intelligent failovers" so that if a server or node fails, its services and containers will be moved to another host server or VM.</span></span> <span data-ttu-id="a9737-218">En ese caso, necesita las tecnologías más avanzadas como clústeres de contenedor, orchestrators y programadores.</span><span class="sxs-lookup"><span data-stu-id="a9737-218">In that case, you need more advanced technologies like container clusters, orchestrators, and schedulers.</span></span> <span data-ttu-id="a9737-219">Por lo tanto, la manera de implementar en esos clústeres es precisamente a través de los escenarios avanzados que se explica en la sección siguiente.</span><span class="sxs-lookup"><span data-stu-id="a9737-219">Thus, the way to deploy to those clusters is precisely through the advanced scenarios explained in the next section.</span></span>

### <a name="deploying-complex-docker-applications-to-docker-clusters-dcos-kubernetes-and-docker-swarm"></a><span data-ttu-id="a9737-220">Implementar aplicaciones complejas de Docker para clústeres de Docker (controlador de dominio/OS, Kubernetes y Docker Swarm)</span><span class="sxs-lookup"><span data-stu-id="a9737-220">Deploying complex Docker applications to Docker clusters (DC/OS, Kubernetes, and Docker Swarm)</span></span>

<span data-ttu-id="a9737-221">La naturaleza de las aplicaciones distribuidas requiere recursos de proceso que también se distribuyen.</span><span class="sxs-lookup"><span data-stu-id="a9737-221">The nature of distributed applications requires compute resources that are also distributed.</span></span> <span data-ttu-id="a9737-222">Para tener capacidades de escala de producción, debe tener la agrupación en clústeres capacidades que proporcionan una gran escalabilidad y alta disponibilidad en función de los recursos agrupados.</span><span class="sxs-lookup"><span data-stu-id="a9737-222">To have production-scale capabilities, you need to have clustering capabilities that provide high scalability and HA based on pooled resources.</span></span>

<span data-ttu-id="a9737-223">Puede implementar contenedores manualmente en esos clústeres desde una herramienta CLI como Docker Swarm (como el uso de [crear servicio docker](https://docs.docker.com/engine/swarm/swarm-tutorial/deploy-service/)) o una interfaz de usuario web como [Mesosphere maratón](https://mesosphere.github.io/marathon/docs/marathon-ui.html) para DC/OS clústeres, pero debe reservar sólo para pruebas de implementación punctual o para propósitos de administración como el escalamiento horizontal o con fines de supervisión.</span><span class="sxs-lookup"><span data-stu-id="a9737-223">You could deploy containers manually to those clusters from a CLI tool such as Docker Swarm (like using [docker service create](https://docs.docker.com/engine/swarm/swarm-tutorial/deploy-service/)) or a web UI such as [Mesosphere Marathon](https://mesosphere.github.io/marathon/docs/marathon-ui.html) for DC/OS clusters, but you should reserve that only for punctual deployment testing or for management purposes like scaling-out or monitoring purposes.</span></span>

<span data-ttu-id="a9737-224">Desde un punto de vista de CD y Visual Studio Team Services en concreto, puede ejecutar tareas de implementación especialmente realizadas desde los entornos de Visual Studio Team Services Release Management que se va a implementar las aplicaciones en contenedores a los clústeres distribuidos en Servicio de contenedor, como se muestra en la figura 5-9.</span><span class="sxs-lookup"><span data-stu-id="a9737-224">From a CD point of view, and Visual Studio Team Services specifically, you can run specially made deployment tasks from your Visual Studio Team Services Release Management environments which will deploy your containerized applications to distributed clusters in Container Service, as illustrated in Figure 5-9.</span></span>

![](./media/image9.png)

<span data-ttu-id="a9737-225">Figura 5-9: implementación de aplicaciones distribuidas en servicio de contenedor</span><span class="sxs-lookup"><span data-stu-id="a9737-225">Figure 5-9: Deploying distributed applications to Container Service</span></span>

<span data-ttu-id="a9737-226">En principio, cuando se implementa en ciertos clústeres o orchestrators, tradicionalmente usaría scripts de implementación específicos y mecanismos por cada orchestrator (es decir, Mesosphere DC/OS o Kubernetes tienen permisos para los diferentes mecanismos de Docker y Docker Swarm) en lugar de la más sencilla y fácil de usar docker-redacción herramienta basada en el archivo de definición de compose.yml de docker.</span><span class="sxs-lookup"><span data-stu-id="a9737-226">Initially, when deploying to certain clusters or orchestrators, you would traditionally use specific deployment scripts and mechanisms per each orchestrator (that is, Mesosphere DC/OS or Kubernetes have different deployment mechanisms than Docker and Docker Swarm) instead of the simpler and easy-to-use docker-compose tool based on the docker-compose.yml definition file.</span></span> <span data-ttu-id="a9737-227">Sin embargo, gracias a la tarea de Microsoft Visual Studio Team Services Docker implementar, se muestra en la figura 5-10, ahora también puede implementar en DC/OS usando solo el archivo compose.yml de docker familiar porque Microsoft realiza esa "traducción" automáticamente (desde el archivo compose.yml de docker a otros formatos necesita DC/OS).</span><span class="sxs-lookup"><span data-stu-id="a9737-227">However, thanks to the Microsoft Visual Studio Team Services Docker Deploy task, shown in Figure 5-10, you now also can deploy to DC/OS by just using your familiar docker-compose.yml file because Microsoft performs that "translation" for you (from your docker-compose.yml file to other formats needed by DC/OS).</span></span>

![](./media/image10.png)

<span data-ttu-id="a9737-228">Figura 5-10: agregar la tarea de implementación de Docker a su entorno de RM</span><span class="sxs-lookup"><span data-stu-id="a9737-228">Figure 5-10: Adding the Docker Deploy task to your Environment RM</span></span>

<span data-ttu-id="a9737-229">Figura 5-11 muestra cómo puede modificar la tarea de implementación de Docker y especificar el tipo de destino (contenedor de servicio DC/SO Azure, en este caso), el archivo de redacción de Docker y la conexión del registro de Docker (por ejemplo, registro de contenedor de Azure o Docker Hub).</span><span class="sxs-lookup"><span data-stu-id="a9737-229">Figure 5-11 demonstrates how you can edit the Docker Deploy task and specify the Target Type (Azure Container Service DC/OS, in this case), your Docker Compose File, and the Docker Registry connection (like Azure Container Registry or Docker Hub).</span></span> <span data-ttu-id="a9737-230">Esto es donde la tarea recuperará las imágenes del Docker personalizadas listos para usar para implementarse como contenedores en el clúster de DC/OS.</span><span class="sxs-lookup"><span data-stu-id="a9737-230">This is where the task will retrieve your ready-to-use custom Docker images to be deployed as containers in the DC/OS cluster.</span></span>

![](./media/image11.png)

<span data-ttu-id="a9737-231">Implementación de la figura 5-11: Docker implementar tarea definición para el servicio de contenedor de Azure DC/OS</span><span class="sxs-lookup"><span data-stu-id="a9737-231">Figure 5-11: Docker Deploy task definition deploying to Azure Container Service DC/OS</span></span>

<span data-ttu-id="a9737-232">**Obtener más información** para obtener más información acerca de la canalización de CD con Visual Studio Team Services y Docker, visite los siguientes sitios:</span><span class="sxs-lookup"><span data-stu-id="a9737-232">**More info** To read more about the CD pipeline with Visual Studio Team Services and Docker, visit the following sites:</span></span>

<span data-ttu-id="a9737-233">Extensión de Visual Studio Team Services para Docker y el servicio de contenedor de Azure: [https://aka.ms/ \ vstsdockerextension](https://aka.ms/vstsdockerextension)</span><span class="sxs-lookup"><span data-stu-id="a9737-233">Visual Studio Team Services extension for Docker and Azure Container Service: [https://aka.ms/\ vstsdockerextension](https://aka.ms/vstsdockerextension)</span></span>

<span data-ttu-id="a9737-234">Servicio de contenedor de Azure: <https://aka.ms/azurecontainerservice></span><span class="sxs-lookup"><span data-stu-id="a9737-234">Azure Container Service: <https://aka.ms/azurecontainerservice></span></span>

<span data-ttu-id="a9737-235">Controlador de dominio mesosphere/OS: <https://mesosphere.com/product/></span><span class="sxs-lookup"><span data-stu-id="a9737-235">Mesosphere DC/OS: <https://mesosphere.com/product/></span></span>

## <a name="step-5-run-and-manage"></a><span data-ttu-id="a9737-236">Paso 5: Ejecutar y administrar</span><span class="sxs-lookup"><span data-stu-id="a9737-236">Step 5: Run and manage</span></span>

<span data-ttu-id="a9737-237">Dado que ejecutar y administrar aplicaciones en producción enterprise nivel es un asunto principal en y de sí mismo y por el tipo de operaciones y personas que trabajan en ese nivel (operaciones de TI), así como la amplia gama de esta área, nos hemos dedicado toda la matriz junto capítulo a explicarlo.</span><span class="sxs-lookup"><span data-stu-id="a9737-237">Because running and managing applications at enterprise-production level is a major subject in and of itself, and due to the type of operations and people working at that level (IT operations) as well as the large scope of this area, we have devoted the entire next chapter to explaining it.</span></span>

## <a name="step-6-monitor-and-diagnose"></a><span data-ttu-id="a9737-238">Paso 6: Supervisar y diagnosticar</span><span class="sxs-lookup"><span data-stu-id="a9737-238">Step 6: Monitor and diagnose</span></span>

<span data-ttu-id="a9737-239">En este tema también se trata en el capítulo siguiente como parte de las tareas que realiza las operaciones de TI en sistemas de producción; Sin embargo, es importante resaltar que debe suministrar la información obtenida en este paso hacia el equipo de desarrollo para que la aplicación se ha mejorado la constantemente.</span><span class="sxs-lookup"><span data-stu-id="a9737-239">This topic also is covered in the next chapter as part of the tasks that IT operations performs in production systems; however, is important to highlight that the insights obtained in this step must feed back to the development team so that the application is constantly improved.</span></span> <span data-ttu-id="a9737-240">Desde ese punto de vista, también forma parte de DevOps, aunque normalmente se realizan las tareas y operaciones por TI.</span><span class="sxs-lookup"><span data-stu-id="a9737-240">From that point of view, it is also part of DevOps, although the tasks and operations are usually performed by IT.</span></span>

<span data-ttu-id="a9737-241">Solo cuando la supervisión y diagnóstico está al 100% en el dominio Kerberos de DevOps son los procesos de supervisión y análisis realizadas por el equipo de desarrollo en entornos de pruebas o beta.</span><span class="sxs-lookup"><span data-stu-id="a9737-241">Only when monitoring and diagnostics are 100 percent within the realm of DevOps are the monitoring processes and analytics performed by the development team against testing or beta environments.</span></span> <span data-ttu-id="a9737-242">Esto se realiza mediante la realización de pruebas de carga o simplemente mediante la supervisión de la versión beta o entornos de preguntas y respuestas, donde los evaluadores de beta están tratando de las nuevas versiones.</span><span class="sxs-lookup"><span data-stu-id="a9737-242">This is done either by performing load testing or simply by monitoring beta or QA environments, where beta testers are trying the new versions.</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="a9737-243">[Previous] (index.md) [Next] (../run-manage-monitor-docker-environments/index.md)</span><span class="sxs-lookup"><span data-stu-id="a9737-243">[Previous] (index.md) [Next] (../run-manage-monitor-docker-environments/index.md)</span></span>
