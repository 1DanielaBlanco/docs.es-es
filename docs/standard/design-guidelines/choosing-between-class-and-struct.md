---
title: Elegir entre clases y structs
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- class library design guidelines [.NET Framework], structures
- class library design guidelines [.NET Framework], classes
- structures [.NET Framework], vs. classes
- classes [.NET Framework], design guidelines
- type design guidelines, structures
- structures [.NET Framework], design guidelines
- classes [.NET Framework], vs. structures
- type design guidelines, classes
ms.assetid: f8b8ec9b-0ba7-4dea-aadf-a93395cd804f
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 7590d5628f4951a8c7c2199f0e954007ed9fa962
ms.sourcegitcommit: b5cd9d5d3b75a5537fc9ad8a3f085f0bb1845ee0
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 11/07/2018
ms.locfileid: "50757431"
---
# <a name="choosing-between-class-and-struct"></a><span data-ttu-id="06b6c-102">Elegir entre clases y structs</span><span class="sxs-lookup"><span data-stu-id="06b6c-102">Choosing Between Class and Struct</span></span>
<span data-ttu-id="06b6c-103">Una de las decisiones de diseño básicos que se enfrenta a cada diseñador framework es si va a diseñar un tipo como una clase (un tipo de referencia) o como un struct (un tipo de valor).</span><span class="sxs-lookup"><span data-stu-id="06b6c-103">One of the basic design decisions every framework designer faces is whether to design a type as a class (a reference type) or as a struct (a value type).</span></span> <span data-ttu-id="06b6c-104">Buen conocimiento de las diferencias en el comportamiento de los tipos de referencia y tipos de valor es fundamental para tomar esta decisión.</span><span class="sxs-lookup"><span data-stu-id="06b6c-104">Good understanding of the differences in the behavior of reference types and value types is crucial in making this choice.</span></span>  
  
 <span data-ttu-id="06b6c-105">La primera diferencia entre los tipos de referencia y tipos de valor que se tendrá en cuenta es que los tipos de referencia son asignados en el montón y se recolectan, mientras que se asignan los tipos de valor en la pila o en línea en que contiene los tipos y se desasigna cuando la pila desenreda o cuando se desasigna su tipo contenedor.</span><span class="sxs-lookup"><span data-stu-id="06b6c-105">The first difference between reference types and value types we will consider is that reference types are allocated on the heap and garbage-collected, whereas value types are allocated either on the stack or inline in containing types and deallocated when the stack unwinds or when their containing type gets deallocated.</span></span> <span data-ttu-id="06b6c-106">Por lo tanto, las asignaciones y desasignaciones de tipos de valor son en general, más barato que las asignaciones y desasignaciones de tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="06b6c-106">Therefore, allocations and deallocations of value types are in general cheaper than allocations and deallocations of reference types.</span></span>  
  
 <span data-ttu-id="06b6c-107">A continuación, matrices de referencia son tipos asignan fuera de línea, lo que significa que la matriz de elementos son las referencias a las instancias del tipo de referencia que se encuentran en el montón.</span><span class="sxs-lookup"><span data-stu-id="06b6c-107">Next, arrays of reference types are allocated out-of-line, meaning the array elements are just references to instances of the reference type residing on the heap.</span></span> <span data-ttu-id="06b6c-108">Matrices de tipos de valor se asignan en línea, lo que significa que los elementos de matriz son las instancias reales del tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="06b6c-108">Value type arrays are allocated inline, meaning that the array elements are the actual instances of the value type.</span></span> <span data-ttu-id="06b6c-109">Por lo tanto, las asignaciones y desasignaciones de matrices de tipos de valor son mucho más baratos que las asignaciones y desasignaciones de matrices de tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="06b6c-109">Therefore, allocations and deallocations of value type arrays are much cheaper than allocations and deallocations of reference type arrays.</span></span> <span data-ttu-id="06b6c-110">Además, en la mayoría de los casos las matrices de tipo de valor presentan mucho mejor localidad de referencia.</span><span class="sxs-lookup"><span data-stu-id="06b6c-110">In addition, in a majority of cases value type arrays exhibit much better locality of reference.</span></span>  
  
 <span data-ttu-id="06b6c-111">La diferencia siguiente está relacionada con el uso de memoria.</span><span class="sxs-lookup"><span data-stu-id="06b6c-111">The next difference is related to memory usage.</span></span> <span data-ttu-id="06b6c-112">Tipos de valor obtengan conversión boxing cuando se convierte a un tipo de referencia o una de las interfaces que implementan.</span><span class="sxs-lookup"><span data-stu-id="06b6c-112">Value types get boxed when cast to a reference type or one of the interfaces they implement.</span></span> <span data-ttu-id="06b6c-113">Obtienen conversión unboxing cuando se convierte al tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="06b6c-113">They get unboxed when cast back to the value type.</span></span> <span data-ttu-id="06b6c-114">Dado que los cuadros son objetos que se asignan en el montón y están recolección, demasiado conversión boxing y unboxing puede tener un impacto negativo en el montón, el recolector de elementos no utilizados y, en última instancia, el rendimiento de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="06b6c-114">Because boxes are objects that are allocated on the heap and are garbage-collected, too much boxing and unboxing can have a negative impact on the heap, the garbage collector, and ultimately the performance of the application.</span></span>  <span data-ttu-id="06b6c-115">Por el contrario, se produce ninguna conversión boxing tal como se convierten tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="06b6c-115">In contrast, no such boxing occurs as reference types are cast.</span></span> <span data-ttu-id="06b6c-116">(Para obtener más información, consulte [conversión Boxing y Unboxing](../../csharp/programming-guide/types/boxing-and-unboxing.md)).</span><span class="sxs-lookup"><span data-stu-id="06b6c-116">(For more information, see [Boxing and Unboxing](../../csharp/programming-guide/types/boxing-and-unboxing.md)).</span></span>
  
 <span data-ttu-id="06b6c-117">A continuación, las asignaciones de tipo de referencia copia la referencia, mientras que las asignaciones de tipo de valor copian el valor completo.</span><span class="sxs-lookup"><span data-stu-id="06b6c-117">Next, reference type assignments copy the reference, whereas value type assignments copy the entire value.</span></span> <span data-ttu-id="06b6c-118">Por lo tanto, las asignaciones de tipos de referencia de gran tamaño son menos costosas que las asignaciones de tipos de valor grande.</span><span class="sxs-lookup"><span data-stu-id="06b6c-118">Therefore, assignments of large reference types are cheaper than assignments of large value types.</span></span>  
  
 <span data-ttu-id="06b6c-119">Por último, los tipos de referencia se pasan por referencia, mientras que los tipos de valor se pasan por valor.</span><span class="sxs-lookup"><span data-stu-id="06b6c-119">Finally, reference types are passed by reference, whereas value types are passed by value.</span></span> <span data-ttu-id="06b6c-120">Cambios en una instancia de un tipo de referencia afectan a todas las referencias que apunta a la instancia.</span><span class="sxs-lookup"><span data-stu-id="06b6c-120">Changes to an instance of a reference type affect all references pointing to the instance.</span></span> <span data-ttu-id="06b6c-121">Cuando se pasan por valor, se copian las instancias del tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="06b6c-121">Value type instances are copied when they are passed by value.</span></span> <span data-ttu-id="06b6c-122">Cuando se cambia una instancia de un tipo de valor, por supuesto no afecta cualquiera de sus copias.</span><span class="sxs-lookup"><span data-stu-id="06b6c-122">When an instance of a value type is changed, it of course does not affect any of its copies.</span></span> <span data-ttu-id="06b6c-123">Dado que las copias no se crean explícitamente por el usuario, pero se crean implícitamente cuando se pasan argumentos o se devuelven los valores se devuelven, que se pueden cambiar los tipos de valor pueden ser confusos para muchos usuarios.</span><span class="sxs-lookup"><span data-stu-id="06b6c-123">Because the copies are not created explicitly by the user but are implicitly created when arguments are passed or return values are returned, value types that can be changed can be confusing to many users.</span></span> <span data-ttu-id="06b6c-124">Por lo tanto, los tipos de valor deben ser inmutables.</span><span class="sxs-lookup"><span data-stu-id="06b6c-124">Therefore, value types should be immutable.</span></span>  
  
 <span data-ttu-id="06b6c-125">Como regla general, la mayoría de los tipos en un marco de trabajo debe ser clases.</span><span class="sxs-lookup"><span data-stu-id="06b6c-125">As a rule of thumb, the majority of types in a framework should be classes.</span></span> <span data-ttu-id="06b6c-126">Sin embargo, hay algunas situaciones en que las características de un tipo de valor que sea más adecuado usar structs.</span><span class="sxs-lookup"><span data-stu-id="06b6c-126">There are, however, some situations in which the characteristics of a value type make it more appropriate to use structs.</span></span>  
  
 <span data-ttu-id="06b6c-127">**✓ CONSIDER** definir una estructura en lugar de una clase si instancias del tipo son pequeñas y normalmente corta duración o suelen estar incrustadas en otros objetos.</span><span class="sxs-lookup"><span data-stu-id="06b6c-127">**✓ CONSIDER** defining a struct instead of a class if instances of the type are small and commonly short-lived or are commonly embedded in other objects.</span></span>  
  
 <span data-ttu-id="06b6c-128">**X AVOID** definir un struct a menos que el tipo tenga todas las características siguientes:</span><span class="sxs-lookup"><span data-stu-id="06b6c-128">**X AVOID** defining a struct unless the type has all of the following characteristics:</span></span>  
  
-   <span data-ttu-id="06b6c-129">Representa un valor único, similar a los tipos primitivos lógicamente (`int`, `double`, etcetera.).</span><span class="sxs-lookup"><span data-stu-id="06b6c-129">It logically represents a single value, similar to primitive types (`int`, `double`, etc.).</span></span>  
  
-   <span data-ttu-id="06b6c-130">Tiene un tamaño de instancia inferior a 16 bytes.</span><span class="sxs-lookup"><span data-stu-id="06b6c-130">It has an instance size under 16 bytes.</span></span>  
  
-   <span data-ttu-id="06b6c-131">Es inmutable.</span><span class="sxs-lookup"><span data-stu-id="06b6c-131">It is immutable.</span></span>  
  
-   <span data-ttu-id="06b6c-132">No tendrá que realizar la conversión boxing con frecuencia.</span><span class="sxs-lookup"><span data-stu-id="06b6c-132">It will not have to be boxed frequently.</span></span>  
  
 <span data-ttu-id="06b6c-133">En todos los demás casos, debe definir los tipos como clases.</span><span class="sxs-lookup"><span data-stu-id="06b6c-133">In all other cases, you should define your types as classes.</span></span>  
  
 <span data-ttu-id="06b6c-134">*Portions © 2005, 2009 Microsoft Corporation. Reservados todos los derechos.*</span><span class="sxs-lookup"><span data-stu-id="06b6c-134">*Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*</span></span>  
  
 <span data-ttu-id="06b6c-135">*Material reimpreso con el consentimiento de Pearson Education, Inc. y extraído de [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) (Instrucciones de diseño de .NET Framework: convenciones, expresiones y patrones para bibliotecas .NET reutilizables, 2.ª edición), de Krzysztof Cwalina y Brad Abrams, publicado el 22 de octubre de 2008 por Addison-Wesley Professional como parte de la serie Microsoft Windows Development.*</span><span class="sxs-lookup"><span data-stu-id="06b6c-135">*Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="06b6c-136">Vea también</span><span class="sxs-lookup"><span data-stu-id="06b6c-136">See also</span></span>

- [<span data-ttu-id="06b6c-137">Instrucciones de diseño de tipos</span><span class="sxs-lookup"><span data-stu-id="06b6c-137">Type Design Guidelines</span></span>](../../../docs/standard/design-guidelines/type.md)  
- [<span data-ttu-id="06b6c-138">Instrucciones de diseño de .NET Framework</span><span class="sxs-lookup"><span data-stu-id="06b6c-138">Framework Design Guidelines</span></span>](../../../docs/standard/design-guidelines/index.md)
